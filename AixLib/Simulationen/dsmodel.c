/* DSblock model generated by Dymola from Modelica model AixLib.Building.Benchmark.Test.TestTBA
 Dymola Version 2018 (32-bit), 2017-06-01 translated this at Mon Jul 09 16:15:55 2018

   */

#include <matrixop.h>
static const char* DymArrays0[1]={"SimpleLiquidWater"};
/* Declaration of C-structs */
struct DymStruc0;
struct DymStruc0 {
  int  id_0member;
};
DYMOLA_STATIC struct DymStruc0 DymStruc0_construct(int   id_02) {
  struct DymStruc0 dummy_0;
  dummy_0.id_0member = id_02;
  return dummy_0;
}
/* Prototypes for functions used in model */
DYMOLA_STATIC double   Modelica_Blocks_Tables_CombiTable1Ds_getDerTableValue_M(
  struct DymStruc0 tableID0_0, int  icol0_0, double  u0_0, double  
  tableAvailable0_0, double  derx_0u);
DYMOLA_STATIC double   Modelica_Blocks_Tables_CombiTable1Ds_getTableValue_M(
  struct DymStruc0 tableID0_0, int  icol0_0, double  u0_0, double  
  tableAvailable0_0);
DYMOLA_STATIC struct DymStruc0  Modelica_Blocks_Types_ExternalCombiTable1D_M(
  const char*  tableName0_0, const char*  fileName0_0, RealArray   table0_0, 
  IntegerArray   columns0_0, int  smoothness0_0, int id_, int alwaysMakeNew_);
DYMOLA_STATIC void Modelica_Blocks_Types_ExternalCombiTable1D_destructor_M(
  void* externalCombiTable1D0_0);
struct Modelica_Fluid_Pipes_BaseClasses_WallFriction_Detailed_Internal_mx_0flowx_0ofx_0dpx_0fric_struct {
  double   mx_0flow_0member;
  double   dmx_0flowx_0ddpx_0fric_0member;
};
DYMOLA_STATIC struct Modelica_Fluid_Pipes_BaseClasses_WallFriction_Detailed_Internal_mx_0flowx_0ofx_0dpx_0fric_struct
   Modelica_Fluid_Pipes_BaseClasses_WallFriction_Detailed_Internal_mx_0flowx_0ofx_0dpx_0fric
  (double  dpx_0fric, double  rhox_0a, double  rhox_0b, double  mux_0a, double  
  mux_0b, double  length0_0, double  diameter0_0, double  crossArea0_0, double  
  Re10_0, double  Re20_0, double  Delta0_0);
struct Modelica_Fluid_Pipes_BaseClasses_WallFriction_Detailed_Internal_mx_0flowx_0ofx_0dpx_0fric_interpolateInRegion2x_0withDerivative_struct {
  double   Re0_0_0member;
  double   dRex_0ddp_0member;
};
DYMOLA_STATIC struct Modelica_Fluid_Pipes_BaseClasses_WallFriction_Detailed_Internal_mx_0flowx_0ofx_0dpx_0fric_interpolateInRegion2x_0withDerivative_struct
   Modelica_Fluid_Pipes_BaseClasses_WallFriction_Detailed_Internal_mx_0flowx_0ofx_0dpx_0fric_interpolateInRegion2x_0withDerivative
  (double  lambda20_0, double  Re10_0, double  Re20_0, double  Delta0_0, double 
   dpx_0fric);
struct Modelica_Fluid_Pipes_BaseClasses_WallFriction_Detailed_Internal_mx_0flowx_0ofx_0dpx_0fric_interpolateInRegion2x_0withDerivative__der_struct {
  double   Rex_0der_0member;
  double   dRex_0ddpx_0der_0member;
};
DYMOLA_STATIC struct Modelica_Fluid_Pipes_BaseClasses_WallFriction_Detailed_Internal_mx_0flowx_0ofx_0dpx_0fric_interpolateInRegion2x_0withDerivative__der_struct
   Modelica_Fluid_Pipes_BaseClasses_WallFriction_Detailed_Internal_mx_0flowx_0ofx_0dpx_0fric_interpolateInRegion2x_0withDerivative__der
  (double  lambda20_0, double  Re10_0, double  Re20_0, double  Delta0_0, double 
   dpx_0fric, double  lambda2x_0der, double  Re1x_0der, double  Re2x_0der, 
  double  Deltax_0der, double  dpx_0fricx_0der);
struct Modelica_Fluid_Pipes_BaseClasses_WallFriction_Detailed_Internal_mx_0flowx_0ofx_0dpx_0fric__der_struct {
  double   mx_0flowx_0der_0member;
  double   dmx_0flowx_0ddpx_0fricx_0der_0member;
};
DYMOLA_STATIC struct Modelica_Fluid_Pipes_BaseClasses_WallFriction_Detailed_Internal_mx_0flowx_0ofx_0dpx_0fric__der_struct
   Modelica_Fluid_Pipes_BaseClasses_WallFriction_Detailed_Internal_mx_0flowx_0ofx_0dpx_0fric__der
  (double  dpx_0fric, double  rhox_0a, double  rhox_0b, double  mux_0a, double  
  mux_0b, double  length0_0, double  diameter0_0, double  crossArea0_0, double  
  Re10_0, double  Re20_0, double  Delta0_0, double  dpx_0fricx_0der, double  
  rhox_0ax_0der, double  rhox_0bx_0der, double  mux_0ax_0der, double  
  mux_0bx_0der, double  lengthx_0der, double  diameterx_0der, double  
  crossAreax_0der, double  Re1x_0der, double  Re2x_0der, double  Deltax_0der);
DYMOLA_STATIC void Modelica_Fluid_Utilities_checkBoundary(const char*  
  mediumName0_0, StringArray   substanceNames0_0, int  singleState0_0, int  
  definex_0p, RealArray   Xx_0boundary, const char*  modelName0_0);
struct Modelica_Fluid_Utilities_cubicHermitex_0withDerivative_struct {
  double   y0_0_0member;
  double   dyx_0dx_0member;
};
DYMOLA_STATIC struct Modelica_Fluid_Utilities_cubicHermitex_0withDerivative_struct
   Modelica_Fluid_Utilities_cubicHermitex_0withDerivative(double  x0_0, double  
  x10_0, double  x20_0, double  y10_0, double  y20_0, double  y1d0_0, double  
  y2d0_0);
struct Modelica_Fluid_Utilities_cubicHermitex_0withDerivative__der_struct {
  double   yx_0der_0member;
  double   dyx_0dxx_0der_0member;
};
DYMOLA_STATIC struct Modelica_Fluid_Utilities_cubicHermitex_0withDerivative__der_struct
   Modelica_Fluid_Utilities_cubicHermitex_0withDerivative__der(double  x0_0, 
  double  x10_0, double  x20_0, double  y10_0, double  y20_0, double  y1d0_0, 
  double  y2d0_0, double  xx_0der, double  x1x_0der, double  x2x_0der, double  
  y1x_0der, double  y2x_0der, double  y1dx_0der, double  y2dx_0der);
struct Modelica_Fluid_Utilities_regFun3_struct {
  double   y0_0_0member;
  double   c0_0_0member;
};
DYMOLA_STATIC struct Modelica_Fluid_Utilities_regFun3_struct Modelica_Fluid_Utilities_regFun3
  (double  x0_0, double  x00_0, double  x10_0, double  y00_0, double  y10_0, 
  double  y0d0_0, double  y1d0_0);
struct Modelica_Fluid_Utilities_regFun3__der_struct {
  double   yx_0der_0member;
  double   cx_0der_0member;
};
DYMOLA_STATIC struct Modelica_Fluid_Utilities_regFun3__der_struct 
  Modelica_Fluid_Utilities_regFun3__der(double  x0_0, double  x00_0, double  
  x10_0, double  y00_0, double  y10_0, double  y0d0_0, double  y1d0_0, double  
  xx_0der, double  x0x_0der, double  x1x_0der, double  y0x_0der, double  
  y1x_0der, double  y0dx_0der, double  y1dx_0der);
DYMOLA_STATIC double   interpolateInRegion2x_0Unique10(double  Re0_0, double  
  Re10_0, double  Re20_0, double  Delta0_0);
DYMOLA_STATIC double   massFlowRatex_0dpx_0staticHeadx_0Unique13(double  dp0_0, 
  double  rhox_0a, double  rhox_0b, double  mux_0a, double  mux_0b, double  
  length0_0, double  diameter0_0, double  gx_0timesx_0heightx_0ab, double  
  crossArea0_0, double  roughness0_0, double  dpx_0small, double  Rex_0turbulent);
DYMOLA_STATIC double   massFlowRatex_0dpx_0staticHeadx_0Unique13__der(double  
  dp0_0, double  rhox_0a, double  rhox_0b, double  mux_0a, double  mux_0b, 
  double  length0_0, double  diameter0_0, double  gx_0timesx_0heightx_0ab, 
  double  crossArea0_0, double  roughness0_0, double  dpx_0small, double  
  Rex_0turbulent, double  dpx_0der, double  rhox_0ax_0der, double  rhox_0bx_0der,
   double  mux_0ax_0der, double  mux_0bx_0der, double  lengthx_0der, double  
  diameterx_0der, double  gx_0timesx_0heightx_0abx_0der, double  crossAreax_0der,
   double  roughnessx_0der, double  dpx_0smallx_0der, double  Rex_0turbulentx_0der);
DYMOLA_STATIC double   pressureLossx_0mx_0flowx_0Unique9(double  mx_0flow, 
  double  rhox_0a, double  rhox_0b, double  mux_0a, double  mux_0b, double  
  length0_0, double  diameter0_0, double  crossArea0_0, double  roughness0_0, 
  double  mx_0flowx_0small, double  Rex_0turbulent);
/* Codes used in model */

/* Flattened Modelica model:

function Modelica.Blocks.Tables.CombiTable1Ds.getDerTableValue
input Modelica.Blocks.Types.ExternalCombiTable1D tableID;
input Integer icol;
discrete input Real u;
discrete input Real tableAvailable "Dummy input to ensure correct sorting of function calls";
discrete input Real der_u;
discrete output Real der_y;

external "C" der_y = ModelicaStandardTables_CombiTable1D_getDerValue(tableID, icol, u, der_u);
annotation(Library={"ModelicaMatIO", "ModelicaStandardTables", "zlib"}, LibraryDirectory"C:/Program Files (x86)/Dymola 2018/Modelica/Library/Modelica 3.2.2/Resources/Library");
end Modelica.Blocks.Tables.CombiTable1Ds.getDerTableValue;

  */
extern double (ModelicaStandardTables_CombiTable1D_getDerValue)(void*, int , 
  double , double );
DYMOLA_STATIC double   Modelica_Blocks_Tables_CombiTable1Ds_getDerTableValue_M(
  struct DymStruc0 tableID0_0, int  icol0_0, double  u0_0, double  
  tableAvailable0_0, double  derx_0u) {
  PushContext("Modelica.Blocks.Tables.CombiTable1Ds.getDerTableValue")
  {
    /* Declare outputs and temporaries */
    double   derx_0y;
    derx_0y=0;
    /* Start of real code */
    {
      derx_0y = (ModelicaStandardTables_CombiTable1D_getDerValue)(
        externalTable_[tableID0_0.id_0member].obj_, icol0_0, u0_0, derx_0u);
      }
    /* Output section */
    PopContext()
    return derx_0y;
  }}

/* Flattened Modelica model:

function Modelica.Blocks.Tables.CombiTable1Ds.getTableValue
input Modelica.Blocks.Types.ExternalCombiTable1D tableID;
input Integer icol;
discrete input Real u;
discrete input Real tableAvailable "Dummy input to ensure correct sorting of function calls";
discrete output Real y;

external "C" y = ModelicaStandardTables_CombiTable1D_getValue(tableID, icol, u);
annotation(derivative(noDerivative=tableAvailable)=Modelica.Blocks.Tables.CombiTable1Ds.getDerTableValue, Library={"ModelicaMatIO", "ModelicaStandardTables", "zlib"}, LibraryDirectory"C:/Program Files (x86)/Dymola 2018/Modelica/Library/Modelica 3.2.2/Resources/Library");
end Modelica.Blocks.Tables.CombiTable1Ds.getTableValue;

  */
extern double (ModelicaStandardTables_CombiTable1D_getValue)(void*, int , double );
DYMOLA_STATIC double   Modelica_Blocks_Tables_CombiTable1Ds_getTableValue_M(
  struct DymStruc0 tableID0_0, int  icol0_0, double  u0_0, double  
  tableAvailable0_0) {
  PushContext("Modelica.Blocks.Tables.CombiTable1Ds.getTableValue")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    y0_0=0;
    /* Start of real code */
    {
      y0_0 = (ModelicaStandardTables_CombiTable1D_getValue)(externalTable_[
        tableID0_0.id_0member].obj_, icol0_0, u0_0);
      }
    /* Output section */
    PopContext()
    return y0_0;
  }}

/* Flattened Modelica model:

function Modelica.Blocks.Types.ExternalCombiTable1D
input String tableName "Table name";
input String fileName "File name";
discrete input Real table[:, :];
input Integer columns[:];
input Modelica.Blocks.Types.Smoothness smoothness;
output Modelica.Blocks.Types.ExternalCombiTable1D externalCombiTable1D;

external "C" externalCombiTable1D = ModelicaStandardTables_CombiTable1D_init(tableName, fileName, table, size(table, 1), size(table, 2), columns, size(columns, 1), smoothness);
annotation(Library={"ModelicaStandardTables"}, LibraryDirectory"C:/Program Files (x86)/Dymola 2018/Modelica/Library/Modelica 3.2.2/Resources/Library");
end Modelica.Blocks.Types.ExternalCombiTable1D;

  */
extern void* (ModelicaStandardTables_CombiTable1D_init)(const char* , 
  const char* , double  const *, size_t, size_t, int  const *, size_t, int );
DYMOLA_STATIC struct DymStruc0  Modelica_Blocks_Types_ExternalCombiTable1D_M(
  const char*  tableName0_0, const char*  fileName0_0, RealArray   table0_0, 
  IntegerArray   columns0_0, int  smoothness0_0, int id_, int alwaysMakeNew_) {
  PushContext("Modelica.Blocks.Types.ExternalCombiTable1D")
  {
    /* Declare outputs and temporaries */
    struct DymStruc0  externalCombiTable1D0_0;
    externalCombiTable1D0_0.id_0member=0;
    /* Start of real code */
    {
      externalCombiTable1D0_0.id_0member=id_;
      if (externalTable_[id_].destructor_ && externalTable_[id_].obj_ && alwaysMakeNew_) {
      void*x_=externalTable_[id_].obj_;
      externalTable_[id_].obj_=0;
      (*(externalTable_[id_].destructor_))(x_);
      } else if (!externalTable_[id_].destructor_) {externalTable_[id_].obj_=0;}
      externalTable_[id_].destructor_=Modelica_Blocks_Types_ExternalCombiTable1D_destructor_M;

        if (!externalTable_[id_].obj_) externalTable_[id_].obj_ = (
        ModelicaStandardTables_CombiTable1D_init)(tableName0_0, fileName0_0, 
        table0_0.data, table0_0.dims[1-1], table0_0.dims[2-1], columns0_0.data, 
        columns0_0.dims[1-1], smoothness0_0);
      }
    /* Output section */
    PopContext()
    return externalCombiTable1D0_0;
  }}

/* Flattened Modelica model:

function Modelica.Blocks.Types.ExternalCombiTable1D.destructor
input Modelica.Blocks.Types.ExternalCombiTable1D externalCombiTable1D;

external "C" ModelicaStandardTables_CombiTable1D_close(externalCombiTable1D);
annotation(Library={"ModelicaStandardTables"}, LibraryDirectory"C:/Program Files (x86)/Dymola 2018/Modelica/Library/Modelica 3.2.2/Resources/Library");
end Modelica.Blocks.Types.ExternalCombiTable1D.destructor;

  */
extern void (ModelicaStandardTables_CombiTable1D_close)(void*);
DYMOLA_STATIC void Modelica_Blocks_Types_ExternalCombiTable1D_destructor_M(
  void* externalCombiTable1D0_0) {
  PushContext("Modelica.Blocks.Types.ExternalCombiTable1D.destructor")
  {
    /* Declare outputs and temporaries */
    /* Start of real code */
    {
      (ModelicaStandardTables_CombiTable1D_close)(externalCombiTable1D0_0);
      }
    /* Output section */
    PopContext()
    return ;
  }}

/* Flattened Modelica model:

function Modelica.Fluid.Utilities.checkBoundary
input String mediumName;
input String substanceNames[:] "Names of substances";
input Boolean singleState;
input Boolean define_p;
discrete input Real X_boundary[:];
input String modelName(start = "??? boundary ???");
protected 
Integer nX(start = size(X_boundary, 1));
String X_str;
public 
algorithm 
assert( not singleState or singleState and define_p, "
Wrong value of parameter define_p (= false) in model \""+modelName+"\":
The selected medium \""+mediumName+"\" has Medium.singleState=true.
Therefore, an boundary density cannot be defined and
define_p = true is required.
");
for i in (1:nX) loop
assert(X_boundary[i] >= 0.0, "
Wrong boundary mass fractions in medium \""+mediumName+"\" in model \""+modelName+"\":
The boundary value X_boundary("+       String(i, true, 0)+") = "+       String(X_boundary[i], true, 0)+"
is negative. It must be positive.
");
end for;
if (nX > 0 and abs(sum(X_boundary)-1.0) > 1E-010) then 
X_str := "";
for i in (1:nX) loop
X_str := X_str+"   X_boundary["+       String(i, true, 0)+"] = "+       String(X_boundary[i], true, 0)+" \""+substanceNames[i]+"\"\n";
end for;
ModelicaError("The boundary mass fractions in medium \""+mediumName+"\" in model \""+modelName+"\"\n"+"do not sum up to 1. Instead, sum(X_boundary) = "+       String(sum(X_boundary), true, 0)+":\n"+X_str);
end if;
end Modelica.Fluid.Utilities.checkBoundary;

  */
DYMOLA_STATIC void Modelica_Fluid_Utilities_checkBoundary(const char*  
  mediumName0_0, StringArray   substanceNames0_0, int  singleState0_0, int  
  definex_0p, RealArray   Xx_0boundary, const char*  modelName0_0) {
  char*retSMark_=GetStringMark();
  PushContext("Modelica.Fluid.Utilities.checkBoundary")
  {
    /* Declare outputs and temporaries */
    int   nX0_0;
    const char*   Xx_0str;
    MarkObject retmark_ = PushMark();
    nX0_0 = DYNSizeSimple(Xx_0boundary, 1);
    Xx_0str="";
    /* Start of real code */
      AssertModelica( NOT singleState0_0 OR singleState0_0 AND definex_0p,
        " not singleState or singleState and define_p", StringAdd(StringAdd(
        StringAdd(StringAdd("\nWrong value of parameter define_p (= false) in model \"",
        modelName0_0),"\":\nThe selected medium \""),mediumName0_0),
        "\" has Medium.singleState=true.\nTherefore, an boundary density cannot be defined and\ndefine_p = true is required.\n"));
      {
        int end_ = nX0_0;
        int i0_0_0;
        for(i0_0_0 = 1;i0_0_0 <= end_;i0_0_0 += 1) {
          AssertModelica(RealElement( Xx_0boundary, (SizeType)(i0_0_0)) >= 0.0,
            "X_boundary[i] >= 0.0", StringAdd(StringAdd(StringAdd(StringAdd(
            StringAdd(StringAdd(StringAdd(StringAdd("\nWrong boundary mass fractions in medium \"",
            mediumName0_0),"\" in model \""),modelName0_0),"\":\nThe boundary value X_boundary("),
            Integer2String2(i0_0_0, true, 0)),") = "),Real2String2(RealElement( 
            Xx_0boundary, (SizeType)(i0_0_0)), true, 0)),"\nis negative. It must be positive.\n"));
        }
      }
      if (nX0_0 > 0 AND fabs(Realsum( Xx_0boundary)-1.0) > 1E-010) {
        Xx_0str = SqueezeString("", retSMark_);
        Release();
        {
          int end_ = nX0_0;
          int i0_0_0;
          for(i0_0_0 = 1;i0_0_0 <= end_;i0_0_0 += 1) {
            Xx_0str = SqueezeString(StringAdd(StringAdd(StringAdd(StringAdd(
              StringAdd(StringAdd(StringAdd(Xx_0str,"   X_boundary["),
              Integer2String2(i0_0_0, true, 0)),"] = "),Real2String2(
              RealElement( Xx_0boundary, (SizeType)(i0_0_0)), true, 0))," \""),
              StringElement( substanceNames0_0, (SizeType)(i0_0_0))),"\"\n"), retSMark_);
          }
        }
        ModelicaError(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(
          StringAdd(StringAdd(StringAdd("The boundary mass fractions in medium \"",
          mediumName0_0),"\" in model \""),modelName0_0),"\"\n"),
          "do not sum up to 1. Instead, sum(X_boundary) = "),Real2String2(
          Realsum( Xx_0boundary), true, 0)),":\n"),Xx_0str));
        Release();
      }
    /* Output section */
    PopMark(retmark_);
    SetStringMark(retSMark_);
    PopContext()
    return ;
  }}

/* Flattened Modelica model:

function massFlowRate_dp_staticHead_Unique13
discrete input Real dp(unit = "Pa", displayUnit = "bar") "Pressure loss (dp = port_a.p - port_b.p)";
discrete input Real rho_a(unit = "kg/m3", displayUnit = "g/cm3", min = 0.0) "Density at port_a";
discrete input Real rho_b(unit = "kg/m3", displayUnit = "g/cm3", min = 0.0) "Density at port_b";
discrete input Real mu_a(unit = "Pa.s", min = 0.0) "Dynamic viscosity at port_a (dummy if use_mu = false)";
discrete input Real mu_b(unit = "Pa.s", min = 0.0) "Dynamic viscosity at port_b (dummy if use_mu = false)";
discrete input Real length(unit = "m") "Length of pipe";
discrete input Real diameter(unit = "m", min = 0.0) "Inner (hydraulic) diameter of pipe";
discrete input Real g_times_height_ab "Gravity times (Height(port_b) - Height(port_a))";
discrete input Real crossArea(start = 0.7853981633974483*diameter^2, unit = "m2") "Inner cross section area";
discrete input Real roughness(start = 2.5E-005, unit = "m", min = 0.0) "Absolute roughness of pipe, with a default for a smooth steel pipe (dummy if use_roughness = false)";
discrete input Real dp_small(start = 1, nominal = 100000.0, unit = "Pa", displayUnit = "bar", min = 0.0) "Regularization of zero flow if |dp| < dp_small (dummy if use_dp_small = false)";
discrete input Real Re_turbulent(start = 4000, unit = "1") "Turbulent flow if Re >= Re_turbulent (dummy if use_Re_turbulent = false)";
discrete output Real m_flow(unit = "kg/s") "Mass flow rate from port_a to port_b";
protected 
discrete Real Delta(start = roughness/diameter) "Relative roughness";
discrete Real Re(unit = "1") "Reynolds number";
discrete Real Re1(start = min((745*exp((if Delta <= 0.0065 then 1 else 0.0065/Delta)))^0.97, Re_turbulent), unit = "1") "Boundary between laminar regime and transition";
discrete Real Re2(start = Re_turbulent, unit = "1") "Boundary between transition and turbulent regime";
discrete Real dp_a(unit = "Pa", displayUnit = "bar") "Upper end of regularization domain of the m_flow(dp) relation";
discrete Real dp_b(unit = "Pa", displayUnit = "bar") "Lower end of regularization domain of the m_flow(dp) relation";
discrete Real m_flow_a(unit = "kg/s") "Value at upper end of regularization domain";
discrete Real m_flow_b(unit = "kg/s") "Value at lower end of regularization domain";
discrete Real dm_flow_ddp_fric_a(unit = "kg/s") "Derivative at upper end of regularization domain";
discrete Real dm_flow_ddp_fric_b(unit = "kg/s") "Derivative at lower end of regularization domain";
discrete Real dp_grav_a(start = g_times_height_ab*rho_a, unit = "Pa", displayUnit = "bar") "Static head if mass flows in design direction (a to b)";
discrete Real dp_grav_b(start = g_times_height_ab*rho_b, unit = "Pa", displayUnit = "bar") "Static head if mass flows against design direction (b to a)";
discrete Real m_flow_zero(start = 0, unit = "kg/s");
discrete Real dp_zero(start = 0.5*(dp_grav_a+dp_grav_b), unit = "Pa", displayUnit = "bar");
discrete Real dm_flow_ddp_fric_zero;
public 
algorithm 
dp_a := max(dp_grav_a, dp_grav_b)+dp_small;
dp_b := min(dp_grav_a, dp_grav_b)-dp_small;
if (dp >= dp_a) then 
m_flow := Modelica.Fluid.Pipes.BaseClasses.WallFriction.Detailed.Internal.m_flow_of_dp_fric(dp-dp_grav_a, rho_a, rho_b, mu_a, mu_b, length, diameter, crossArea, Re1, Re2, Delta);
elseif (dp <= dp_b) then 
m_flow := Modelica.Fluid.Pipes.BaseClasses.WallFriction.Detailed.Internal.m_flow_of_dp_fric(dp-dp_grav_b, rho_a, rho_b, mu_a, mu_b, length, diameter, crossArea, Re1, Re2, Delta);
else
(m_flow_a, dm_flow_ddp_fric_a)  := Modelica.Fluid.Pipes.BaseClasses.WallFriction.Detailed.Internal.m_flow_of_dp_fric(dp_a-dp_grav_a, rho_a, rho_b, mu_a, mu_b, length, diameter, crossArea, Re1, Re2, Delta);
(m_flow_b, dm_flow_ddp_fric_b)  := Modelica.Fluid.Pipes.BaseClasses.WallFriction.Detailed.Internal.m_flow_of_dp_fric(dp_b-dp_grav_b, rho_a, rho_b, mu_a, mu_b, length, diameter, crossArea, Re1, Re2, Delta);
(m_flow, dm_flow_ddp_fric_zero)  := Modelica.Fluid.Utilities.regFun3(dp_zero, dp_b, dp_a, m_flow_b, m_flow_a, dm_flow_ddp_fric_b, dm_flow_ddp_fric_a);
if (dp > dp_zero) then 
m_flow := Modelica.Fluid.Utilities.regFun3(dp, dp_zero, dp_a, m_flow_zero, m_flow_a, dm_flow_ddp_fric_zero, dm_flow_ddp_fric_a);
else
m_flow := Modelica.Fluid.Utilities.regFun3(dp, dp_b, dp_zero, m_flow_b, m_flow_zero, dm_flow_ddp_fric_b, dm_flow_ddp_fric_zero);
end if;
end if;
annotation(derivative=massFlowRate_dp_staticHead_Unique13:der, smoothOrder=1);
end massFlowRate_dp_staticHead_Unique13;

  */
DYMOLA_STATIC double   massFlowRatex_0dpx_0staticHeadx_0Unique13(double  dp0_0, 
  double  rhox_0a, double  rhox_0b, double  mux_0a, double  mux_0b, double  
  length0_0, double  diameter0_0, double  gx_0timesx_0heightx_0ab, double  
  crossArea0_0, double  roughness0_0, double  dpx_0small, double  Rex_0turbulent)
   {
  PushContext("massFlowRate_dp_staticHead_Unique13")
  {
    /* Declare outputs and temporaries */
    double   mx_0flow;
    double   Delta0_0;
    double   Re0_0;
    double   Re10_0;
    double   Re20_0;
    double   dpx_0a;
    double   dpx_0b;
    double   mx_0flowx_0a;
    double   mx_0flowx_0b;
    double   dmx_0flowx_0ddpx_0fricx_0a;
    double   dmx_0flowx_0ddpx_0fricx_0b;
    double   dpx_0gravx_0a;
    double   dpx_0gravx_0b;
    double   mx_0flowx_0zero;
    double   dpx_0zero;
    double   dmx_0flowx_0ddpx_0fricx_0zero;
    mx_0flow=0;
    Delta0_0 = divmacro(roughness0_0,"roughness",diameter0_0,"diameter");
    Re0_0=0;
    Re10_0 = RealBmin(powmacro(745*exp(IF Delta0_0 <= 0.0065 THEN 1 ELSE 
      divmacro(0.0065,"0.0065",Delta0_0,"Delta")),"745*exp((if Delta <= 0.0065 then 1 else 0.0065/Delta))",
      0.97,"0.97"), Rex_0turbulent);
    Re20_0 = Rex_0turbulent;
    dpx_0a=0;
    dpx_0b=0;
    mx_0flowx_0a=0;
    mx_0flowx_0b=0;
    dmx_0flowx_0ddpx_0fricx_0a=0;
    dmx_0flowx_0ddpx_0fricx_0b=0;
    dpx_0gravx_0a = gx_0timesx_0heightx_0ab*rhox_0a;
    dpx_0gravx_0b = gx_0timesx_0heightx_0ab*rhox_0b;
    mx_0flowx_0zero = 0;
    dpx_0zero = 0.5*(dpx_0gravx_0a+dpx_0gravx_0b);
    dmx_0flowx_0ddpx_0fricx_0zero=0;
    /* Start of real code */
      dpx_0a = RealBmax(dpx_0gravx_0a, dpx_0gravx_0b)+dpx_0small;
      dpx_0b = RealBmin(dpx_0gravx_0a, dpx_0gravx_0b)-dpx_0small;
      if (dp0_0 >= dpx_0a) {
        mx_0flow = Modelica_Fluid_Pipes_BaseClasses_WallFriction_Detailed_Internal_mx_0flowx_0ofx_0dpx_0fric
          (dp0_0-dpx_0gravx_0a, rhox_0a, rhox_0b, mux_0a, mux_0b, length0_0, 
          diameter0_0, crossArea0_0, Re10_0, Re20_0, Delta0_0).mx_0flow_0member;
      }
      else if (dp0_0 <= dpx_0b) {
        mx_0flow = Modelica_Fluid_Pipes_BaseClasses_WallFriction_Detailed_Internal_mx_0flowx_0ofx_0dpx_0fric
          (dp0_0-dpx_0gravx_0b, rhox_0a, rhox_0b, mux_0a, mux_0b, length0_0, 
          diameter0_0, crossArea0_0, Re10_0, Re20_0, Delta0_0).mx_0flow_0member;
      }
      else{
        {
          struct Modelica_Fluid_Pipes_BaseClasses_WallFriction_Detailed_Internal_mx_0flowx_0ofx_0dpx_0fric_struct
             dummy_mult_=Modelica_Fluid_Pipes_BaseClasses_WallFriction_Detailed_Internal_mx_0flowx_0ofx_0dpx_0fric
            (dpx_0a-dpx_0gravx_0a, rhox_0a, rhox_0b, mux_0a, mux_0b, length0_0, 
            diameter0_0, crossArea0_0, Re10_0, Re20_0, Delta0_0);
          mx_0flowx_0a = dummy_mult_.mx_0flow_0member;
          dmx_0flowx_0ddpx_0fricx_0a = dummy_mult_.dmx_0flowx_0ddpx_0fric_0member;
        }
        {
          struct Modelica_Fluid_Pipes_BaseClasses_WallFriction_Detailed_Internal_mx_0flowx_0ofx_0dpx_0fric_struct
             dummy_mult_=Modelica_Fluid_Pipes_BaseClasses_WallFriction_Detailed_Internal_mx_0flowx_0ofx_0dpx_0fric
            (dpx_0b-dpx_0gravx_0b, rhox_0a, rhox_0b, mux_0a, mux_0b, length0_0, 
            diameter0_0, crossArea0_0, Re10_0, Re20_0, Delta0_0);
          mx_0flowx_0b = dummy_mult_.mx_0flow_0member;
          dmx_0flowx_0ddpx_0fricx_0b = dummy_mult_.dmx_0flowx_0ddpx_0fric_0member;
        }
        {
          struct Modelica_Fluid_Utilities_regFun3_struct dummy_mult_=
            Modelica_Fluid_Utilities_regFun3(dpx_0zero, dpx_0b, dpx_0a, 
            mx_0flowx_0b, mx_0flowx_0a, dmx_0flowx_0ddpx_0fricx_0b, 
            dmx_0flowx_0ddpx_0fricx_0a);
          mx_0flow = dummy_mult_.y0_0_0member;
          dmx_0flowx_0ddpx_0fricx_0zero = dummy_mult_.c0_0_0member;
        }
        if (dp0_0 > dpx_0zero) {
          mx_0flow = Modelica_Fluid_Utilities_regFun3(dp0_0, dpx_0zero, dpx_0a, 
            mx_0flowx_0zero, mx_0flowx_0a, dmx_0flowx_0ddpx_0fricx_0zero, 
            dmx_0flowx_0ddpx_0fricx_0a).y0_0_0member;
        }
        else{
          mx_0flow = Modelica_Fluid_Utilities_regFun3(dp0_0, dpx_0b, dpx_0zero, 
            mx_0flowx_0b, mx_0flowx_0zero, dmx_0flowx_0ddpx_0fricx_0b, 
            dmx_0flowx_0ddpx_0fricx_0zero).y0_0_0member;
        }
      }
    /* Output section */
    PopContext()
    return mx_0flow;
  }}

/* Flattened Modelica model:

function massFlowRate_dp_staticHead_Unique13:der
discrete input Real dp;
discrete input Real rho_a;
discrete input Real rho_b;
discrete input Real mu_a;
discrete input Real mu_b;
discrete input Real length;
discrete input Real diameter;
discrete input Real g_times_height_ab;
discrete input Real crossArea(start = 0.7853981633974483*diameter^2);
discrete input Real roughness(start = 2.5E-005);
discrete input Real dp_small(start = 1);
discrete input Real Re_turbulent(start = 4000);
protected 
discrete Real m_flow;
discrete Real Delta(start = roughness/diameter);
discrete Real Re;
discrete Real Re1(start = min((745*exp((if Delta <= 0.0065 then 1 else 0.0065/Delta)))^0.97, Re_turbulent));
discrete Real Re2(start = Re_turbulent);
discrete Real dp_a;
discrete Real dp_b;
discrete Real m_flow_a;
discrete Real m_flow_b;
discrete Real dm_flow_ddp_fric_a;
discrete Real dm_flow_ddp_fric_b;
discrete Real dp_grav_a(start = g_times_height_ab*rho_a);
discrete Real dp_grav_b(start = g_times_height_ab*rho_b);
discrete Real m_flow_zero(start = 0);
discrete Real dp_zero(start = 0.5*(dp_grav_a+dp_grav_b));
discrete Real dm_flow_ddp_fric_zero;
public 
discrete input Real dp_der;
discrete input Real rho_a_der;
discrete input Real rho_b_der;
discrete input Real mu_a_der;
discrete input Real mu_b_der;
discrete input Real length_der;
discrete input Real diameter_der;
discrete input Real g_times_height_ab_der;
discrete input Real crossArea_der(start = 1.5707963267948966*(diameter*diameter_der));
discrete input Real roughness_der(start = 0.0);
discrete input Real dp_small_der(start = 0);
discrete input Real Re_turbulent_der(start = 0);
discrete output Real m_flow_der;
protected 
discrete Real Delta_der(start = roughness_der/diameter-roughness*diameter_der/diameter^2);
discrete Real Re_der;
discrete Real Re1_der(start = (if noEvent((745*exp((if Delta <= 0.0065 then 1 else 0.0065/Delta)))^0.97 < Re_turbulent) then 722.65*((745*exp((if Delta <= 0.0065 then 1 else 0.0065/Delta)))^(-0.030000000000000027)*((if Delta <= 0.0065 then 0 else  -0.0065*Delta_der/Delta^2)*exp((if Delta <= 0.0065 then 1 else 0.0065/Delta)))) else Re_turbulent_der));
discrete Real Re2_der(start = Re_turbulent_der);
discrete Real dp_a_der;
discrete Real dp_b_der;
discrete Real m_flow_a_der;
discrete Real m_flow_b_der;
discrete Real dm_flow_ddp_fric_a_der;
discrete Real dm_flow_ddp_fric_b_der;
discrete Real dp_grav_a_der(start = g_times_height_ab_der*rho_a+g_times_height_ab*rho_a_der);
discrete Real dp_grav_b_der(start = g_times_height_ab_der*rho_b+g_times_height_ab*rho_b_der);
discrete Real m_flow_zero_der(start = 0);
discrete Real dp_zero_der(start = 0.5*(dp_grav_a_der+dp_grav_b_der));
discrete Real dm_flow_ddp_fric_zero_der;
public 
algorithm 
dp_a_der := (if noEvent(dp_grav_a > dp_grav_b) then dp_grav_a_der else dp_grav_b_der)+dp_small_der;
dp_a := max(dp_grav_a, dp_grav_b)+dp_small;
dp_b_der := (if noEvent(dp_grav_a < dp_grav_b) then dp_grav_a_der else dp_grav_b_der)-dp_small_der;
dp_b := min(dp_grav_a, dp_grav_b)-dp_small;
if (dp >= dp_a) then 
m_flow_der := Modelica.Fluid.Pipes.BaseClasses.WallFriction.Detailed.Internal.m_flow_of_dp_fric:der(dp-dp_grav_a, rho_a, rho_b, mu_a, mu_b, length, diameter, crossArea, Re1, Re2, Delta, dp_der-dp_grav_a_der, rho_a_der, rho_b_der, mu_a_der, mu_b_der, length_der, diameter_der, crossArea_der, Re1_der, Re2_der, Delta_der);
elseif (dp <= dp_b) then 
m_flow_der := Modelica.Fluid.Pipes.BaseClasses.WallFriction.Detailed.Internal.m_flow_of_dp_fric:der(dp-dp_grav_b, rho_a, rho_b, mu_a, mu_b, length, diameter, crossArea, Re1, Re2, Delta, dp_der-dp_grav_b_der, rho_a_der, rho_b_der, mu_a_der, mu_b_der, length_der, diameter_der, crossArea_der, Re1_der, Re2_der, Delta_der);
else
(m_flow_a_der, dm_flow_ddp_fric_a_der)  := Modelica.Fluid.Pipes.BaseClasses.WallFriction.Detailed.Internal.m_flow_of_dp_fric:der(dp_a-dp_grav_a, rho_a, rho_b, mu_a, mu_b, length, diameter, crossArea, Re1, Re2, Delta, dp_a_der-dp_grav_a_der, rho_a_der, rho_b_der, mu_a_der, mu_b_der, length_der, diameter_der, crossArea_der, Re1_der, Re2_der, Delta_der);
(m_flow_a, dm_flow_ddp_fric_a)  := Modelica.Fluid.Pipes.BaseClasses.WallFriction.Detailed.Internal.m_flow_of_dp_fric(dp_a-dp_grav_a, rho_a, rho_b, mu_a, mu_b, length, diameter, crossArea, Re1, Re2, Delta);
(m_flow_b_der, dm_flow_ddp_fric_b_der)  := Modelica.Fluid.Pipes.BaseClasses.WallFriction.Detailed.Internal.m_flow_of_dp_fric:der(dp_b-dp_grav_b, rho_a, rho_b, mu_a, mu_b, length, diameter, crossArea, Re1, Re2, Delta, dp_b_der-dp_grav_b_der, rho_a_der, rho_b_der, mu_a_der, mu_b_der, length_der, diameter_der, crossArea_der, Re1_der, Re2_der, Delta_der);
(m_flow_b, dm_flow_ddp_fric_b)  := Modelica.Fluid.Pipes.BaseClasses.WallFriction.Detailed.Internal.m_flow_of_dp_fric(dp_b-dp_grav_b, rho_a, rho_b, mu_a, mu_b, length, diameter, crossArea, Re1, Re2, Delta);
(m_flow_der, dm_flow_ddp_fric_zero_der)  := Modelica.Fluid.Utilities.regFun3:der(dp_zero, dp_b, dp_a, m_flow_b, m_flow_a, dm_flow_ddp_fric_b, dm_flow_ddp_fric_a, dp_zero_der, dp_b_der, dp_a_der, m_flow_b_der, m_flow_a_der, dm_flow_ddp_fric_b_der, dm_flow_ddp_fric_a_der);
(m_flow, dm_flow_ddp_fric_zero)  := Modelica.Fluid.Utilities.regFun3(dp_zero, dp_b, dp_a, m_flow_b, m_flow_a, dm_flow_ddp_fric_b, dm_flow_ddp_fric_a);
if (dp > dp_zero) then 
m_flow_der := Modelica.Fluid.Utilities.regFun3:der(dp, dp_zero, dp_a, 0.0, m_flow_a, dm_flow_ddp_fric_zero, dm_flow_ddp_fric_a, dp_der, dp_zero_der, dp_a_der, 0.0, m_flow_a_der, dm_flow_ddp_fric_zero_der, dm_flow_ddp_fric_a_der);
else
m_flow_der := Modelica.Fluid.Utilities.regFun3:der(dp, dp_b, dp_zero, m_flow_b, 0.0, dm_flow_ddp_fric_b, dm_flow_ddp_fric_zero, dp_der, dp_b_der, dp_zero_der, m_flow_b_der, 0.0, dm_flow_ddp_fric_b_der, dm_flow_ddp_fric_zero_der);
end if;
end if;
annotation(smoothOrder=0);
end massFlowRate_dp_staticHead_Unique13:der;

  */
DYMOLA_STATIC double   massFlowRatex_0dpx_0staticHeadx_0Unique13__der(double  
  dp0_0, double  rhox_0a, double  rhox_0b, double  mux_0a, double  mux_0b, 
  double  length0_0, double  diameter0_0, double  gx_0timesx_0heightx_0ab, 
  double  crossArea0_0, double  roughness0_0, double  dpx_0small, double  
  Rex_0turbulent, double  dpx_0der, double  rhox_0ax_0der, double  rhox_0bx_0der,
   double  mux_0ax_0der, double  mux_0bx_0der, double  lengthx_0der, double  
  diameterx_0der, double  gx_0timesx_0heightx_0abx_0der, double  crossAreax_0der,
   double  roughnessx_0der, double  dpx_0smallx_0der, double  Rex_0turbulentx_0der)
   {
  PushContext("massFlowRate_dp_staticHead_Unique13:der")
  {
    /* Declare outputs and temporaries */
    double   mx_0flow;
    double   Delta0_0;
    double   Re0_0;
    double   Re10_0;
    double   Re20_0;
    double   dpx_0a;
    double   dpx_0b;
    double   mx_0flowx_0a;
    double   mx_0flowx_0b;
    double   dmx_0flowx_0ddpx_0fricx_0a;
    double   dmx_0flowx_0ddpx_0fricx_0b;
    double   dpx_0gravx_0a;
    double   dpx_0gravx_0b;
    double   mx_0flowx_0zero;
    double   dpx_0zero;
    double   dmx_0flowx_0ddpx_0fricx_0zero;
    double   mx_0flowx_0der;
    double   Deltax_0der;
    double   Rex_0der;
    double   Re1x_0der;
    double   Re2x_0der;
    double   dpx_0ax_0der;
    double   dpx_0bx_0der;
    double   mx_0flowx_0ax_0der;
    double   mx_0flowx_0bx_0der;
    double   dmx_0flowx_0ddpx_0fricx_0ax_0der;
    double   dmx_0flowx_0ddpx_0fricx_0bx_0der;
    double   dpx_0gravx_0ax_0der;
    double   dpx_0gravx_0bx_0der;
    double   mx_0flowx_0zerox_0der;
    double   dpx_0zerox_0der;
    double   dmx_0flowx_0ddpx_0fricx_0zerox_0der;
    mx_0flow=0;
    Delta0_0 = divmacro(roughness0_0,"roughness",diameter0_0,"diameter");
    Re0_0=0;
    Re10_0 = RealBmin(powmacro(745*exp(IF Delta0_0 <= 0.0065 THEN 1 ELSE 
      divmacro(0.0065,"0.0065",Delta0_0,"Delta")),"745*exp((if Delta <= 0.0065 then 1 else 0.0065/Delta))",
      0.97,"0.97"), Rex_0turbulent);
    Re20_0 = Rex_0turbulent;
    dpx_0a=0;
    dpx_0b=0;
    mx_0flowx_0a=0;
    mx_0flowx_0b=0;
    dmx_0flowx_0ddpx_0fricx_0a=0;
    dmx_0flowx_0ddpx_0fricx_0b=0;
    dpx_0gravx_0a = gx_0timesx_0heightx_0ab*rhox_0a;
    dpx_0gravx_0b = gx_0timesx_0heightx_0ab*rhox_0b;
    mx_0flowx_0zero = 0;
    dpx_0zero = 0.5*(dpx_0gravx_0a+dpx_0gravx_0b);
    dmx_0flowx_0ddpx_0fricx_0zero=0;
    mx_0flowx_0der=0;
    Deltax_0der = divmacro(roughnessx_0der,"roughness_der",diameter0_0,
      "diameter")-divmacro(roughness0_0*diameterx_0der,"roughness*diameter_der",
      sqr(diameter0_0),"diameter^2");
    Rex_0der=0;
    Re1x_0der = IF powmacro(745*exp(IF Delta0_0 <= 0.0065 THEN 1 ELSE divmacro(
      0.0065,"0.0065",Delta0_0,"Delta")),"745*exp((if Delta <= 0.0065 then 1 else 0.0065/Delta))",
      0.97,"0.97") < Rex_0turbulent THEN 722.65*powmacro(745*exp(IF Delta0_0 <= 
      0.0065 THEN 1 ELSE divmacro(0.0065,"0.0065",Delta0_0,"Delta")),
      "745*exp((if Delta <= 0.0065 then 1 else 0.0065/Delta))",-0.030000000000000027,
      "-0.030000000000000027")*(IF Delta0_0 <= 0.0065 THEN 0 ELSE  -divmacro(
      0.0065*Deltax_0der,"0.0065*Delta_der",sqr(Delta0_0),"Delta^2"))*exp(IF 
      Delta0_0 <= 0.0065 THEN 1 ELSE divmacro(0.0065,"0.0065",Delta0_0,"Delta"))
       ELSE Rex_0turbulentx_0der;
    Re2x_0der = Rex_0turbulentx_0der;
    dpx_0ax_0der=0;
    dpx_0bx_0der=0;
    mx_0flowx_0ax_0der=0;
    mx_0flowx_0bx_0der=0;
    dmx_0flowx_0ddpx_0fricx_0ax_0der=0;
    dmx_0flowx_0ddpx_0fricx_0bx_0der=0;
    dpx_0gravx_0ax_0der = gx_0timesx_0heightx_0abx_0der*rhox_0a+gx_0timesx_0heightx_0ab
      *rhox_0ax_0der;
    dpx_0gravx_0bx_0der = gx_0timesx_0heightx_0abx_0der*rhox_0b+gx_0timesx_0heightx_0ab
      *rhox_0bx_0der;
    mx_0flowx_0zerox_0der = 0;
    dpx_0zerox_0der = 0.5*(dpx_0gravx_0ax_0der+dpx_0gravx_0bx_0der);
    dmx_0flowx_0ddpx_0fricx_0zerox_0der=0;
    /* Start of real code */
      dpx_0ax_0der = (IF dpx_0gravx_0a > dpx_0gravx_0b THEN dpx_0gravx_0ax_0der
         ELSE dpx_0gravx_0bx_0der)+dpx_0smallx_0der;
      dpx_0a = RealBmax(dpx_0gravx_0a, dpx_0gravx_0b)+dpx_0small;
      dpx_0bx_0der = (IF dpx_0gravx_0a < dpx_0gravx_0b THEN dpx_0gravx_0ax_0der
         ELSE dpx_0gravx_0bx_0der)-dpx_0smallx_0der;
      dpx_0b = RealBmin(dpx_0gravx_0a, dpx_0gravx_0b)-dpx_0small;
      if (dp0_0 >= dpx_0a) {
        mx_0flowx_0der = Modelica_Fluid_Pipes_BaseClasses_WallFriction_Detailed_Internal_mx_0flowx_0ofx_0dpx_0fric__der
          (dp0_0-dpx_0gravx_0a, rhox_0a, rhox_0b, mux_0a, mux_0b, length0_0, 
          diameter0_0, crossArea0_0, Re10_0, Re20_0, Delta0_0, dpx_0der-
          dpx_0gravx_0ax_0der, rhox_0ax_0der, rhox_0bx_0der, mux_0ax_0der, 
          mux_0bx_0der, lengthx_0der, diameterx_0der, crossAreax_0der, Re1x_0der,
           Re2x_0der, Deltax_0der).mx_0flowx_0der_0member;
      }
      else if (dp0_0 <= dpx_0b) {
        mx_0flowx_0der = Modelica_Fluid_Pipes_BaseClasses_WallFriction_Detailed_Internal_mx_0flowx_0ofx_0dpx_0fric__der
          (dp0_0-dpx_0gravx_0b, rhox_0a, rhox_0b, mux_0a, mux_0b, length0_0, 
          diameter0_0, crossArea0_0, Re10_0, Re20_0, Delta0_0, dpx_0der-
          dpx_0gravx_0bx_0der, rhox_0ax_0der, rhox_0bx_0der, mux_0ax_0der, 
          mux_0bx_0der, lengthx_0der, diameterx_0der, crossAreax_0der, Re1x_0der,
           Re2x_0der, Deltax_0der).mx_0flowx_0der_0member;
      }
      else{
        {
          struct Modelica_Fluid_Pipes_BaseClasses_WallFriction_Detailed_Internal_mx_0flowx_0ofx_0dpx_0fric__der_struct
             dummy_mult_=Modelica_Fluid_Pipes_BaseClasses_WallFriction_Detailed_Internal_mx_0flowx_0ofx_0dpx_0fric__der
            (dpx_0a-dpx_0gravx_0a, rhox_0a, rhox_0b, mux_0a, mux_0b, length0_0, 
            diameter0_0, crossArea0_0, Re10_0, Re20_0, Delta0_0, dpx_0ax_0der-
            dpx_0gravx_0ax_0der, rhox_0ax_0der, rhox_0bx_0der, mux_0ax_0der, 
            mux_0bx_0der, lengthx_0der, diameterx_0der, crossAreax_0der, 
            Re1x_0der, Re2x_0der, Deltax_0der);
          mx_0flowx_0ax_0der = dummy_mult_.mx_0flowx_0der_0member;
          dmx_0flowx_0ddpx_0fricx_0ax_0der = dummy_mult_.dmx_0flowx_0ddpx_0fricx_0der_0member;
        }
        {
          struct Modelica_Fluid_Pipes_BaseClasses_WallFriction_Detailed_Internal_mx_0flowx_0ofx_0dpx_0fric_struct
             dummy_mult_=Modelica_Fluid_Pipes_BaseClasses_WallFriction_Detailed_Internal_mx_0flowx_0ofx_0dpx_0fric
            (dpx_0a-dpx_0gravx_0a, rhox_0a, rhox_0b, mux_0a, mux_0b, length0_0, 
            diameter0_0, crossArea0_0, Re10_0, Re20_0, Delta0_0);
          mx_0flowx_0a = dummy_mult_.mx_0flow_0member;
          dmx_0flowx_0ddpx_0fricx_0a = dummy_mult_.dmx_0flowx_0ddpx_0fric_0member;
        }
        {
          struct Modelica_Fluid_Pipes_BaseClasses_WallFriction_Detailed_Internal_mx_0flowx_0ofx_0dpx_0fric__der_struct
             dummy_mult_=Modelica_Fluid_Pipes_BaseClasses_WallFriction_Detailed_Internal_mx_0flowx_0ofx_0dpx_0fric__der
            (dpx_0b-dpx_0gravx_0b, rhox_0a, rhox_0b, mux_0a, mux_0b, length0_0, 
            diameter0_0, crossArea0_0, Re10_0, Re20_0, Delta0_0, dpx_0bx_0der-
            dpx_0gravx_0bx_0der, rhox_0ax_0der, rhox_0bx_0der, mux_0ax_0der, 
            mux_0bx_0der, lengthx_0der, diameterx_0der, crossAreax_0der, 
            Re1x_0der, Re2x_0der, Deltax_0der);
          mx_0flowx_0bx_0der = dummy_mult_.mx_0flowx_0der_0member;
          dmx_0flowx_0ddpx_0fricx_0bx_0der = dummy_mult_.dmx_0flowx_0ddpx_0fricx_0der_0member;
        }
        {
          struct Modelica_Fluid_Pipes_BaseClasses_WallFriction_Detailed_Internal_mx_0flowx_0ofx_0dpx_0fric_struct
             dummy_mult_=Modelica_Fluid_Pipes_BaseClasses_WallFriction_Detailed_Internal_mx_0flowx_0ofx_0dpx_0fric
            (dpx_0b-dpx_0gravx_0b, rhox_0a, rhox_0b, mux_0a, mux_0b, length0_0, 
            diameter0_0, crossArea0_0, Re10_0, Re20_0, Delta0_0);
          mx_0flowx_0b = dummy_mult_.mx_0flow_0member;
          dmx_0flowx_0ddpx_0fricx_0b = dummy_mult_.dmx_0flowx_0ddpx_0fric_0member;
        }
        {
          struct Modelica_Fluid_Utilities_regFun3__der_struct dummy_mult_=
            Modelica_Fluid_Utilities_regFun3__der(dpx_0zero, dpx_0b, dpx_0a, 
            mx_0flowx_0b, mx_0flowx_0a, dmx_0flowx_0ddpx_0fricx_0b, 
            dmx_0flowx_0ddpx_0fricx_0a, dpx_0zerox_0der, dpx_0bx_0der, 
            dpx_0ax_0der, mx_0flowx_0bx_0der, mx_0flowx_0ax_0der, 
            dmx_0flowx_0ddpx_0fricx_0bx_0der, dmx_0flowx_0ddpx_0fricx_0ax_0der);
          mx_0flowx_0der = dummy_mult_.yx_0der_0member;
          dmx_0flowx_0ddpx_0fricx_0zerox_0der = dummy_mult_.cx_0der_0member;
        }
        {
          struct Modelica_Fluid_Utilities_regFun3_struct dummy_mult_=
            Modelica_Fluid_Utilities_regFun3(dpx_0zero, dpx_0b, dpx_0a, 
            mx_0flowx_0b, mx_0flowx_0a, dmx_0flowx_0ddpx_0fricx_0b, 
            dmx_0flowx_0ddpx_0fricx_0a);
          mx_0flow = dummy_mult_.y0_0_0member;
          dmx_0flowx_0ddpx_0fricx_0zero = dummy_mult_.c0_0_0member;
        }
        if (dp0_0 > dpx_0zero) {
          mx_0flowx_0der = Modelica_Fluid_Utilities_regFun3__der(dp0_0, 
            dpx_0zero, dpx_0a, 0.0, mx_0flowx_0a, dmx_0flowx_0ddpx_0fricx_0zero,
             dmx_0flowx_0ddpx_0fricx_0a, dpx_0der, dpx_0zerox_0der, dpx_0ax_0der,
             0.0, mx_0flowx_0ax_0der, dmx_0flowx_0ddpx_0fricx_0zerox_0der, 
            dmx_0flowx_0ddpx_0fricx_0ax_0der).yx_0der_0member;
        }
        else{
          mx_0flowx_0der = Modelica_Fluid_Utilities_regFun3__der(dp0_0, dpx_0b, 
            dpx_0zero, mx_0flowx_0b, 0.0, dmx_0flowx_0ddpx_0fricx_0b, 
            dmx_0flowx_0ddpx_0fricx_0zero, dpx_0der, dpx_0bx_0der, 
            dpx_0zerox_0der, mx_0flowx_0bx_0der, 0.0, dmx_0flowx_0ddpx_0fricx_0bx_0der,
             dmx_0flowx_0ddpx_0fricx_0zerox_0der).yx_0der_0member;
        }
      }
    /* Output section */
    PopContext()
    return mx_0flowx_0der;
  }}

/* Flattened Modelica model:

function pressureLoss_m_flow_Unique9
discrete input Real m_flow(unit = "kg/s") "Mass flow rate from port_a to port_b";
discrete input Real rho_a(unit = "kg/m3", displayUnit = "g/cm3", min = 0.0) "Density at port_a";
discrete input Real rho_b(unit = "kg/m3", displayUnit = "g/cm3", min = 0.0) "Density at port_b";
discrete input Real mu_a(unit = "Pa.s", min = 0.0) "Dynamic viscosity at port_a (dummy if use_mu = false)";
discrete input Real mu_b(unit = "Pa.s", min = 0.0) "Dynamic viscosity at port_b (dummy if use_mu = false)";
discrete input Real length(unit = "m") "Length of pipe";
discrete input Real diameter(unit = "m", min = 0.0) "Inner (hydraulic) diameter of pipe";
discrete input Real crossArea(start = 0.7853981633974483*diameter^2, unit = "m2") "Inner cross section area";
discrete input Real roughness(start = 2.5E-005, unit = "m", min = 0.0) "Absolute roughness of pipe, with a default for a smooth steel pipe (dummy if use_roughness = false)";
discrete input Real m_flow_small(start = 0.01, unit = "kg/s") "Regularization of zero flow if |m_flow| < m_flow_small (dummy if use_m_flow_small = false)";
discrete input Real Re_turbulent(start = 4000, unit = "1") "Turbulent flow if Re >= Re_turbulent (dummy if use_Re_turbulent = false)";
discrete output Real dp(unit = "Pa", displayUnit = "bar") "Pressure loss (dp = port_a.p - port_b.p)";
protected 
discrete Real Delta(start = roughness/diameter) "Relative roughness";
discrete Real Re1(start = min(745*exp((if Delta <= 0.0065 then 1 else 0.0065/Delta)), Re_turbulent), unit = "1") "Re leaving laminar curve";
discrete Real Re2(start = Re_turbulent, unit = "1") "Re entering turbulent curve";
discrete Real mu(unit = "Pa.s", min = 0.0) "Upstream viscosity";
discrete Real rho(unit = "kg/m3", displayUnit = "g/cm3", min = 0.0) "Upstream density";
discrete Real Re(unit = "1") "Reynolds number";
discrete Real lambda2 "Modified friction coefficient (= lambda*Re^2)";
public 
algorithm 
rho := (if m_flow >= 0 then rho_a else rho_b);
mu := (if m_flow >= 0 then mu_a else mu_b);
Re := diameter*abs(m_flow)/(crossArea*mu);
lambda2 := (if Re <= Re1 then 64*Re else (if Re >= Re2 then 0.25*(Re/log10(Delta/3.7+5.74/Re^0.9))^2 else interpolateInRegion2_Unique10(Re, Re1, Re2, Delta)));
dp := length*mu*mu/(2*rho*diameter*diameter*diameter)*(if m_flow >= 0 then lambda2 else  -lambda2);
annotation(smoothOrder=1);
end pressureLoss_m_flow_Unique9;

  */
DYMOLA_STATIC double   pressureLossx_0mx_0flowx_0Unique9(double  mx_0flow, 
  double  rhox_0a, double  rhox_0b, double  mux_0a, double  mux_0b, double  
  length0_0, double  diameter0_0, double  crossArea0_0, double  roughness0_0, 
  double  mx_0flowx_0small, double  Rex_0turbulent) {
  PushContext("pressureLoss_m_flow_Unique9")
  {
    /* Declare outputs and temporaries */
    double   dp0_0;
    double   Delta0_0;
    double   Re10_0;
    double   Re20_0;
    double   mu0_0;
    double   rho0_0;
    double   Re0_0;
    double   lambda20_0;
    dp0_0=0;
    Delta0_0 = divmacro(roughness0_0,"roughness",diameter0_0,"diameter");
    Re10_0 = RealBmin(745*exp(IF Delta0_0 <= 0.0065 THEN 1 ELSE divmacro(0.0065,
      "0.0065",Delta0_0,"Delta")), Rex_0turbulent);
    Re20_0 = Rex_0turbulent;
    mu0_0=0;
    rho0_0=0;
    Re0_0=0;
    lambda20_0=0;
    /* Start of real code */
      rho0_0 = IF mx_0flow >= 0 THEN rhox_0a ELSE rhox_0b;
      mu0_0 = IF mx_0flow >= 0 THEN mux_0a ELSE mux_0b;
      Re0_0 = divmacro(diameter0_0*fabs(mx_0flow),"diameter*abs(m_flow)",
        crossArea0_0*mu0_0,"crossArea*mu");
      lambda20_0 = IF Re0_0 <= Re10_0 THEN 64*Re0_0 ELSE IF Re0_0 >= Re20_0
         THEN 0.25*sqr(divmacro(Re0_0,"Re",log10Guarded(Delta0_0/(double)(3.7)+
        divmacro(5.74,"5.74",powmacro(Re0_0,"Re",0.9,"0.9"),"Re^0.9"),
        "Delta/3.7+5.74/Re^0.9"),"log10(Delta/3.7+5.74/Re^0.9)")) ELSE 
        interpolateInRegion2x_0Unique10(Re0_0, Re10_0, Re20_0, Delta0_0);
      dp0_0 = divmacro(length0_0*mu0_0*mu0_0,"length*mu*mu",2*rho0_0*diameter0_0
        *diameter0_0*diameter0_0,"2*rho*diameter*diameter*diameter")*(IF 
        mx_0flow >= 0 THEN lambda20_0 ELSE  -lambda20_0);
    /* Output section */
    PopContext()
    return dp0_0;
  }}

/* Flattened Modelica model:

function Modelica.Fluid.Pipes.BaseClasses.WallFriction.Detailed.Internal.m_flow_of_dp_fric
discrete input Real dp_fric(unit = "Pa", displayUnit = "bar") "Pressure loss due to friction (dp = port_a.p - port_b.p)";
discrete input Real rho_a(unit = "kg/m3", displayUnit = "g/cm3", min = 0.0) "Density at port_a";
discrete input Real rho_b(unit = "kg/m3", displayUnit = "g/cm3", min = 0.0) "Density at port_b";
discrete input Real mu_a(unit = "Pa.s", min = 0.0) "Dynamic viscosity at port_a (dummy if use_mu = false)";
discrete input Real mu_b(unit = "Pa.s", min = 0.0) "Dynamic viscosity at port_b (dummy if use_mu = false)";
discrete input Real length(unit = "m") "Length of pipe";
discrete input Real diameter(unit = "m", min = 0.0) "Inner (hydraulic) diameter of pipe";
discrete input Real crossArea(unit = "m2") "Inner cross section area";
discrete input Real Re1(unit = "1") "Boundary between laminar regime and transition";
discrete input Real Re2(unit = "1") "Boundary between transition and turbulent regime";
discrete input Real Delta "Relative roughness";
discrete output Real m_flow(unit = "kg/s") "Mass flow rate from port_a to port_b";
discrete output Real dm_flow_ddp_fric "Derivative of mass flow rate with dp_fric";
protected 
discrete Real mu(unit = "Pa.s", min = 0.0) "Upstream viscosity";
discrete Real rho(unit = "kg/m3", displayUnit = "g/cm3", min = 0.0) "Upstream density";
discrete Real lambda2 "Modified friction coefficient (= lambda*Re^2)";
discrete Real Re(unit = "1") "Reynolds number";
discrete Real dRe_ddp "dRe/ddp";
discrete Real aux1;
discrete Real aux2;
public 
algorithm 
if (dp_fric >= 0) then 
rho := rho_a;
mu := mu_a;
else
rho := rho_b;
mu := mu_b;
end if;
lambda2 := abs(dp_fric)*2*diameter^3*rho/(length*mu*mu);
aux1 := 2*diameter^3*rho/(length*mu^2);
Re := lambda2/64;
dRe_ddp := aux1/64;
if (Re > Re1) then 
Re :=  -2*sqrt(lambda2)*log10(2.51/sqrt(lambda2)+0.27*Delta);
aux2 := sqrt(aux1*abs(dp_fric));
dRe_ddp := 0.43429448190325176*(( -2*log(2.51/aux2+0.27*Delta)*aux1/(2*aux2))+5.02/(2*abs(dp_fric)*(2.51/aux2+0.27*Delta)));
if (Re < Re2) then 
(Re, dRe_ddp)  := Modelica.Fluid.Pipes.BaseClasses.WallFriction.Detailed.Internal.m_flow_of_dp_fric.interpolateInRegion2_withDerivative(lambda2, Re1, Re2, Delta, dp_fric);
end if;
end if;
m_flow := crossArea/diameter*mu*(if dp_fric >= 0 then Re else  -Re);
dm_flow_ddp_fric := crossArea/diameter*mu*dRe_ddp;
annotation(derivative=Modelica.Fluid.Pipes.BaseClasses.WallFriction.Detailed.Internal.m_flow_of_dp_fric:der, smoothOrder=1);
end Modelica.Fluid.Pipes.BaseClasses.WallFriction.Detailed.Internal.m_flow_of_dp_fric;

  */
DYMOLA_STATIC struct Modelica_Fluid_Pipes_BaseClasses_WallFriction_Detailed_Internal_mx_0flowx_0ofx_0dpx_0fric_struct
   Modelica_Fluid_Pipes_BaseClasses_WallFriction_Detailed_Internal_mx_0flowx_0ofx_0dpx_0fric
  (double  dpx_0fric, double  rhox_0a, double  rhox_0b, double  mux_0a, double  
  mux_0b, double  length0_0, double  diameter0_0, double  crossArea0_0, double  
  Re10_0, double  Re20_0, double  Delta0_0) {
  PushContext("Modelica.Fluid.Pipes.BaseClasses.WallFriction.Detailed.Internal.m_flow_of_dp_fric")
  {
    /* Declare outputs and temporaries */
    double   mx_0flow;
    double   dmx_0flowx_0ddpx_0fric;
    double   mu0_0;
    double   rho0_0;
    double   lambda20_0;
    double   Re0_0;
    double   dRex_0ddp;
    double   aux10_0;
    double   aux20_0;
    mx_0flow=0;
    dmx_0flowx_0ddpx_0fric=0;
    mu0_0=0;
    rho0_0=0;
    lambda20_0=0;
    Re0_0=0;
    dRex_0ddp=0;
    aux10_0=0;
    aux20_0=0;
    /* Start of real code */
      if (dpx_0fric >= 0) {
        rho0_0 = rhox_0a;
        mu0_0 = mux_0a;
      }
      else{
        rho0_0 = rhox_0b;
        mu0_0 = mux_0b;
      }
      lambda20_0 = divmacro(fabs(dpx_0fric)*2*powmacro2(diameter0_0,"diameter",3,
        "3")*rho0_0,"abs(dp_fric)*2*diameter^3*rho",length0_0*mu0_0*mu0_0,
        "length*mu*mu");
      aux10_0 = divmacro(2*powmacro2(diameter0_0,"diameter",3,"3")*rho0_0,
        "2*diameter^3*rho",length0_0*sqr(mu0_0),"length*mu^2");
      Re0_0 = lambda20_0/(double)(64);
      dRex_0ddp = aux10_0/(double)(64);
      if (Re0_0 > Re10_0) {
        Re0_0 =  -2*sqrtGuarded(lambda20_0,"lambda2")*log10Guarded(divmacro(2.51,
          "2.51",sqrtGuarded(lambda20_0,"lambda2"),"sqrt(lambda2)")+0.27*
          Delta0_0,"2.51/sqrt(lambda2)+0.27*Delta");
        aux20_0 = sqrtGuarded(aux10_0*fabs(dpx_0fric),"aux1*abs(dp_fric)");
        dRex_0ddp = 0.43429448190325176*(( -divmacro(2*logGuarded(divmacro(2.51,
          "2.51",aux20_0,"aux2")+0.27*Delta0_0,"2.51/aux2+0.27*Delta")*aux10_0,
          "2*log(2.51/aux2+0.27*Delta)*aux1",2*aux20_0,"2*aux2"))+divmacro(5.02,
          "5.02",2*fabs(dpx_0fric)*(divmacro(2.51,"2.51",aux20_0,"aux2")+0.27*
          Delta0_0),"2*abs(dp_fric)*(2.51/aux2+0.27*Delta)"));
        if (Re0_0 < Re20_0) {
          {
            struct Modelica_Fluid_Pipes_BaseClasses_WallFriction_Detailed_Internal_mx_0flowx_0ofx_0dpx_0fric_interpolateInRegion2x_0withDerivative_struct
               dummy_mult_=Modelica_Fluid_Pipes_BaseClasses_WallFriction_Detailed_Internal_mx_0flowx_0ofx_0dpx_0fric_interpolateInRegion2x_0withDerivative
              (lambda20_0, Re10_0, Re20_0, Delta0_0, dpx_0fric);
            Re0_0 = dummy_mult_.Re0_0_0member;
            dRex_0ddp = dummy_mult_.dRex_0ddp_0member;
          }
        }
      }
      mx_0flow = divmacro(crossArea0_0,"crossArea",diameter0_0,"diameter")*mu0_0
        *(IF dpx_0fric >= 0 THEN Re0_0 ELSE  -Re0_0);
      dmx_0flowx_0ddpx_0fric = divmacro(crossArea0_0,"crossArea",diameter0_0,
        "diameter")*mu0_0*dRex_0ddp;
    /* Output section */
    PopContext()
    {
      struct Modelica_Fluid_Pipes_BaseClasses_WallFriction_Detailed_Internal_mx_0flowx_0ofx_0dpx_0fric_struct out_;
      out_.mx_0flow_0member = mx_0flow;
      out_.dmx_0flowx_0ddpx_0fric_0member = dmx_0flowx_0ddpx_0fric;
      return out_;
    }
  }}

/* Flattened Modelica model:

function Modelica.Fluid.Pipes.BaseClasses.WallFriction.Detailed.Internal.m_flow_of_dp_fric.interpolateInRegion2_withDerivative
discrete input Real lambda2 "Known independent variable";
discrete input Real Re1(unit = "1") "Boundary between laminar regime and transition";
discrete input Real Re2(unit = "1") "Boundary between transition and turbulent regime";
discrete input Real Delta "Relative roughness";
discrete input Real dp_fric(unit = "Pa", displayUnit = "bar") "Pressure loss due to friction (dp = port_a.p - port_b.p)";
discrete output Real Re(unit = "1") "Unknown return variable";
discrete output Real dRe_ddp "Derivative of return value";
protected 
discrete Real x1(start = log10(64*Re1));
discrete Real y1(start = log10(Re1));
discrete Real y1d(start = 1);
discrete Real aux2(start = Delta/3.7+5.74/Re2^0.9);
discrete Real aux3(start = log10(aux2));
discrete Real L2(start = 0.25*(Re2/aux3)^2);
discrete Real aux4(start = 2.51/sqrt(L2)+0.27*Delta);
discrete Real aux5(start = (-2.0)*(sqrt(L2)*log10(aux4)));
discrete Real x2(start = log10(L2));
discrete Real y2(start = log10(aux5));
discrete Real y2d(start = 0.5+1.0900791495771618/(aux5*aux4));
discrete Real x(start = log10(lambda2));
discrete Real y;
discrete Real dy_dx "Derivative in transformed space";
public 
algorithm 
(y, dy_dx)  := Modelica.Fluid.Utilities.cubicHermite_withDerivative(x, x1, x2, y1, y2, y1d, y2d);
Re := 10^y;
dRe_ddp := Re/abs(dp_fric)*dy_dx;
annotation(derivative=Modelica.Fluid.Pipes.BaseClasses.WallFriction.Detailed.Internal.m_flow_of_dp_fric.interpolateInRegion2_withDerivative:der, smoothOrder=1);
end Modelica.Fluid.Pipes.BaseClasses.WallFriction.Detailed.Internal.m_flow_of_dp_fric.interpolateInRegion2_withDerivative;

  */
DYMOLA_STATIC struct Modelica_Fluid_Pipes_BaseClasses_WallFriction_Detailed_Internal_mx_0flowx_0ofx_0dpx_0fric_interpolateInRegion2x_0withDerivative_struct
   Modelica_Fluid_Pipes_BaseClasses_WallFriction_Detailed_Internal_mx_0flowx_0ofx_0dpx_0fric_interpolateInRegion2x_0withDerivative
  (double  lambda20_0, double  Re10_0, double  Re20_0, double  Delta0_0, double 
   dpx_0fric) {
  PushContext("Modelica.Fluid.Pipes.BaseClasses.WallFriction.Detailed.Internal.m_flow_of_dp_fric.interpolateInRegion2_withDerivative")
  {
    /* Declare outputs and temporaries */
    double   Re0_0;
    double   dRex_0ddp;
    double   x10_0;
    double   y10_0;
    double   y1d0_0;
    double   aux20_0;
    double   aux30_0;
    double   L20_0;
    double   aux40_0;
    double   aux50_0;
    double   x20_0;
    double   y20_0;
    double   y2d0_0;
    double   x0_0;
    double   y0_0;
    double   dyx_0dx;
    Re0_0=0;
    dRex_0ddp=0;
    x10_0 = log10Guarded(64*Re10_0,"64*Re1");
    y10_0 = log10Guarded(Re10_0,"Re1");
    y1d0_0 = 1;
    aux20_0 = Delta0_0/(double)(3.7)+divmacro(5.74,"5.74",powmacro(Re20_0,"Re2",
      0.9,"0.9"),"Re2^0.9");
    aux30_0 = log10Guarded(aux20_0,"aux2");
    L20_0 = 0.25*sqr(divmacro(Re20_0,"Re2",aux30_0,"aux3"));
    aux40_0 = divmacro(2.51,"2.51",sqrtGuarded(L20_0,"L2"),"sqrt(L2)")+0.27*
      Delta0_0;
    aux50_0 = (-2.0)*sqrtGuarded(L20_0,"L2")*log10Guarded(aux40_0,"aux4");
    x20_0 = log10Guarded(L20_0,"L2");
    y20_0 = log10Guarded(aux50_0,"aux5");
    y2d0_0 = 0.5+divmacro(1.0900791495771618,"1.0900791495771618",aux50_0*
      aux40_0,"aux5*aux4");
    x0_0 = log10Guarded(lambda20_0,"lambda2");
    y0_0=0;
    dyx_0dx=0;
    /* Start of real code */
      {
        struct Modelica_Fluid_Utilities_cubicHermitex_0withDerivative_struct
           dummy_mult_=Modelica_Fluid_Utilities_cubicHermitex_0withDerivative(
          x0_0, x10_0, x20_0, y10_0, y20_0, y1d0_0, y2d0_0);
        y0_0 = dummy_mult_.y0_0_0member;
        dyx_0dx = dummy_mult_.dyx_0dx_0member;
      }
      Re0_0 = powmacro(10,"10",y0_0,"y");
      dRex_0ddp = divmacro(Re0_0,"Re",fabs(dpx_0fric),"abs(dp_fric)")*dyx_0dx;
    /* Output section */
    PopContext()
    {
      struct Modelica_Fluid_Pipes_BaseClasses_WallFriction_Detailed_Internal_mx_0flowx_0ofx_0dpx_0fric_interpolateInRegion2x_0withDerivative_struct out_;
      out_.Re0_0_0member = Re0_0;
      out_.dRex_0ddp_0member = dRex_0ddp;
      return out_;
    }
  }}

/* Flattened Modelica model:

function Modelica.Fluid.Pipes.BaseClasses.WallFriction.Detailed.Internal.m_flow_of_dp_fric:der
discrete input Real dp_fric;
discrete input Real rho_a;
discrete input Real rho_b;
discrete input Real mu_a;
discrete input Real mu_b;
discrete input Real length;
discrete input Real diameter;
discrete input Real crossArea;
discrete input Real Re1;
discrete input Real Re2;
discrete input Real Delta;
protected 
discrete Real m_flow;
discrete Real dm_flow_ddp_fric;
discrete Real mu;
discrete Real rho;
discrete Real lambda2;
discrete Real Re;
discrete Real dRe_ddp;
discrete Real aux1;
discrete Real aux2;
public 
discrete input Real dp_fric_der;
discrete input Real rho_a_der;
discrete input Real rho_b_der;
discrete input Real mu_a_der;
discrete input Real mu_b_der;
discrete input Real length_der;
discrete input Real diameter_der;
discrete input Real crossArea_der;
discrete input Real Re1_der;
discrete input Real Re2_der;
discrete input Real Delta_der;
discrete output Real m_flow_der;
discrete output Real dm_flow_ddp_fric_der;
protected 
discrete Real mu_der;
discrete Real rho_der;
discrete Real lambda2_der;
discrete Real Re_der;
discrete Real dRe_ddp_der;
discrete Real aux1_der;
discrete Real aux2_der;
public 
algorithm 
if (dp_fric >= 0) then 
rho_der := rho_a_der;
rho := rho_a;
mu_der := mu_a_der;
mu := mu_a;
else
rho_der := rho_b_der;
rho := rho_b;
mu_der := mu_b_der;
mu := mu_b;
end if;
lambda2_der := 2.0*((dp_fric_der*noEvent((if dp_fric > 0 then 1 else -1))*diameter^3+3.0*(abs(dp_fric)*(diameter^2*diameter_der)))*rho+abs(dp_fric)*diameter^3*rho_der)/(length*mu*mu)-2.0*(abs(dp_fric)*diameter^3*rho*((length_der*mu+length*mu_der)*mu+length*mu*mu_der))/(length*mu*mu)^2;
lambda2 := 2.0*(abs(dp_fric)*diameter^3*rho)/(length*mu*mu);
aux1_der := 2.0*(3.0*(diameter^2*diameter_der*rho)+diameter^3*rho_der)/(length*mu^2)-2.0*(diameter^3*rho*(length_der*mu^2+2.0*(length*(mu*mu_der))))/(length*mu^2)^2;
aux1 := 2.0*(diameter^3*rho)/(length*mu^2);
Re_der := 0.015625*lambda2_der;
Re := 0.015625*lambda2;
dRe_ddp_der := 0.015625*aux1_der;
dRe_ddp := 0.015625*aux1;
if (Re > Re1) then 
Re_der := (-2.0)*(0.5*(lambda2_der*log10(2.51/sqrt(lambda2)+0.27*Delta))/sqrt(lambda2)+sqrt(lambda2)*(0.27*Delta_der-1.255*lambda2_der/sqrt(lambda2)/sqrt(lambda2)^2)/(2.302585092994046*(2.51/sqrt(lambda2)+0.27*Delta)));
Re := (-2.0)*(sqrt(lambda2)*log10(2.51/sqrt(lambda2)+0.27*Delta));
aux2_der := 0.5*(aux1_der*abs(dp_fric)+aux1*(dp_fric_der*noEvent((if dp_fric > 0 then 1 else -1))))/sqrt(aux1*abs(dp_fric));
aux2 := sqrt(aux1*abs(dp_fric));
dRe_ddp_der := (-0.43429448190325176)*(10.04*(dp_fric_der*noEvent((if dp_fric > 0 then 1 else -1))*(2.51/aux2+0.27*Delta)+abs(dp_fric)*(0.27*Delta_der-2.51*aux2_der/aux2^2))/(2.0*(abs(dp_fric)*(2.51/aux2+0.27*Delta)))^2+2.0*((0.27*Delta_der-2.51*aux2_der/aux2^2)*aux1/(2.51/aux2+0.27*Delta)+log(2.51/aux2+0.27*Delta)*aux1_der)/(2*aux2)-4.0*(log(2.51/aux2+0.27*Delta)*aux1*aux2_der)/(2*aux2)^2);
dRe_ddp := 0.43429448190325176*(5.02/(2.0*(abs(dp_fric)*(2.51/aux2+0.27*Delta)))-2.0*(log(2.51/aux2+0.27*Delta)*aux1)/(2*aux2));
if (Re < Re2) then 
(Re_der, dRe_ddp_der)  := Modelica.Fluid.Pipes.BaseClasses.WallFriction.Detailed.Internal.m_flow_of_dp_fric.interpolateInRegion2_withDerivative:der(lambda2, Re1, Re2, Delta, dp_fric, lambda2_der, Re1_der, Re2_der, Delta_der, dp_fric_der);
(Re, dRe_ddp)  := Modelica.Fluid.Pipes.BaseClasses.WallFriction.Detailed.Internal.m_flow_of_dp_fric.interpolateInRegion2_withDerivative(lambda2, Re1, Re2, Delta, dp_fric);
end if;
end if;
m_flow_der := ((crossArea_der*mu+crossArea*mu_der)*(if dp_fric >= 0 then Re else  -Re)+crossArea*mu*(if dp_fric >= 0 then Re_der else  -Re_der))/diameter-crossArea*mu*(if dp_fric >= 0 then Re else  -Re)*diameter_der/diameter^2;
m_flow := crossArea*mu*(if dp_fric >= 0 then Re else  -Re)/diameter;
dm_flow_ddp_fric_der := ((crossArea_der*mu+crossArea*mu_der)*dRe_ddp+crossArea*mu*dRe_ddp_der)/diameter-crossArea*mu*dRe_ddp*diameter_der/diameter^2;
annotation(smoothOrder=0);
end Modelica.Fluid.Pipes.BaseClasses.WallFriction.Detailed.Internal.m_flow_of_dp_fric:der;

  */
DYMOLA_STATIC struct Modelica_Fluid_Pipes_BaseClasses_WallFriction_Detailed_Internal_mx_0flowx_0ofx_0dpx_0fric__der_struct
   Modelica_Fluid_Pipes_BaseClasses_WallFriction_Detailed_Internal_mx_0flowx_0ofx_0dpx_0fric__der
  (double  dpx_0fric, double  rhox_0a, double  rhox_0b, double  mux_0a, double  
  mux_0b, double  length0_0, double  diameter0_0, double  crossArea0_0, double  
  Re10_0, double  Re20_0, double  Delta0_0, double  dpx_0fricx_0der, double  
  rhox_0ax_0der, double  rhox_0bx_0der, double  mux_0ax_0der, double  
  mux_0bx_0der, double  lengthx_0der, double  diameterx_0der, double  
  crossAreax_0der, double  Re1x_0der, double  Re2x_0der, double  Deltax_0der) {
  PushContext("Modelica.Fluid.Pipes.BaseClasses.WallFriction.Detailed.Internal.m_flow_of_dp_fric:der")
  {
    /* Declare outputs and temporaries */
    double   mx_0flow;
    double   dmx_0flowx_0ddpx_0fric;
    double   mu0_0;
    double   rho0_0;
    double   lambda20_0;
    double   Re0_0;
    double   dRex_0ddp;
    double   aux10_0;
    double   aux20_0;
    double   mx_0flowx_0der;
    double   dmx_0flowx_0ddpx_0fricx_0der;
    double   mux_0der;
    double   rhox_0der;
    double   lambda2x_0der;
    double   Rex_0der;
    double   dRex_0ddpx_0der;
    double   aux1x_0der;
    double   aux2x_0der;
    mx_0flow=0;
    dmx_0flowx_0ddpx_0fric=0;
    mu0_0=0;
    rho0_0=0;
    lambda20_0=0;
    Re0_0=0;
    dRex_0ddp=0;
    aux10_0=0;
    aux20_0=0;
    mx_0flowx_0der=0;
    dmx_0flowx_0ddpx_0fricx_0der=0;
    mux_0der=0;
    rhox_0der=0;
    lambda2x_0der=0;
    Rex_0der=0;
    dRex_0ddpx_0der=0;
    aux1x_0der=0;
    aux2x_0der=0;
    /* Start of real code */
      if (dpx_0fric >= 0) {
        rhox_0der = rhox_0ax_0der;
        rho0_0 = rhox_0a;
        mux_0der = mux_0ax_0der;
        mu0_0 = mux_0a;
      }
      else{
        rhox_0der = rhox_0bx_0der;
        rho0_0 = rhox_0b;
        mux_0der = mux_0bx_0der;
        mu0_0 = mux_0b;
      }
      /* Introducing 11 common subexpressions used in 9 expressions */
      /* Of the common subexpressions 11 are reals, 0 are integers, and 0
         are booleans. */

      { double helpvarF[11];
      DYNX(helpvarF,0) = powmacro2(diameter0_0,"diameter",3,"3");
      DYNX(helpvarF,1) = fabs(dpx_0fric);
      DYNX(helpvarF,2) = dpx_0fricx_0der*(IF dpx_0fric > 0 THEN 1 ELSE -1)*
        DYNX(helpvarF,0)+3.0*DYNX(helpvarF,1)*sqr(diameter0_0)*diameterx_0der;
      DYNX(helpvarF,3) = DYNX(helpvarF,1)*DYNX(helpvarF,0);
      DYNX(helpvarF,4) = length0_0*mu0_0;
      DYNX(helpvarF,5) = DYNX(helpvarF,4)*mu0_0;
      DYNX(helpvarF,6) = divmacro(1.0,"1.0",DYNX(helpvarF,5),"length*mu*mu");
      DYNX(helpvarF,7) = (lengthx_0der*mu0_0+length0_0*mux_0der)*mu0_0;
      DYNX(helpvarF,8) = DYNX(helpvarF,4)*mux_0der;
      DYNX(helpvarF,9) = sqr(DYNX(helpvarF,5));
      DYNX(helpvarF,10) = divmacro(1.0,"1.0",DYNX(helpvarF,9),"(length*mu*mu)^2");
      lambda2x_0der = DYNX(helpvarF,6)*2.0*(DYNX(helpvarF,2)*rho0_0+
        DYNX(helpvarF,3)*rhox_0der)-DYNX(helpvarF,10)*2.0*DYNX(helpvarF,3)*
        rho0_0*(DYNX(helpvarF,7)+DYNX(helpvarF,8));
      }
      lambda20_0 = divmacro(2.0*fabs(dpx_0fric)*powmacro2(diameter0_0,"diameter",3,
        "3")*rho0_0,"2.0*(abs(dp_fric)*diameter^3*rho)",length0_0*mu0_0*mu0_0,
        "length*mu*mu");
      aux1x_0der = divmacro(2.0*(3.0*sqr(diameter0_0)*diameterx_0der*rho0_0+
        powmacro2(diameter0_0,"diameter",3,"3")*rhox_0der),"2.0*(3.0*(diameter^2*diameter_der*rho)+diameter^3*rho_der)",
        length0_0*sqr(mu0_0),"length*mu^2")-divmacro(2.0*powmacro2(diameter0_0,
        "diameter",3,"3")*rho0_0*(lengthx_0der*sqr(mu0_0)+2.0*length0_0*mu0_0*
        mux_0der),"2.0*(diameter^3*rho*(length_der*mu^2+2.0*(length*(mu*mu_der))))",
        sqr(length0_0*sqr(mu0_0)),"(length*mu^2)^2");
      aux10_0 = divmacro(2.0*powmacro2(diameter0_0,"diameter",3,"3")*rho0_0,
        "2.0*(diameter^3*rho)",length0_0*sqr(mu0_0),"length*mu^2");
      Rex_0der = 0.015625*lambda2x_0der;
      Re0_0 = 0.015625*lambda20_0;
      dRex_0ddpx_0der = 0.015625*aux1x_0der;
      dRex_0ddp = 0.015625*aux10_0;
      if (Re0_0 > Re10_0) {
        Rex_0der = (-2.0)*(divmacro(0.5*lambda2x_0der*log10Guarded(divmacro(2.51,
          "2.51",sqrtGuarded(lambda20_0,"lambda2"),"sqrt(lambda2)")+0.27*
          Delta0_0,"2.51/sqrt(lambda2)+0.27*Delta"),"0.5*(lambda2_der*log10(2.51/sqrt(lambda2)+0.27*Delta))",
          sqrtGuarded(lambda20_0,"lambda2"),"sqrt(lambda2)")+divmacro(
          sqrtGuarded(lambda20_0,"lambda2")*(0.27*Deltax_0der-divmacro(divmacro(
          1.255*lambda2x_0der,"1.255*lambda2_der",sqrtGuarded(lambda20_0,
          "lambda2"),"sqrt(lambda2)"),"1.255*lambda2_der/sqrt(lambda2)",sqr(
          sqrtGuarded(lambda20_0,"lambda2")),"sqrt(lambda2)^2")),
          "sqrt(lambda2)*(0.27*Delta_der-1.255*lambda2_der/sqrt(lambda2)/sqrt(lambda2)^2)",
          2.302585092994046*(divmacro(2.51,"2.51",sqrtGuarded(lambda20_0,
          "lambda2"),"sqrt(lambda2)")+0.27*Delta0_0),"2.302585092994046*(2.51/sqrt(lambda2)+0.27*Delta)"));
        Re0_0 = (-2.0)*sqrtGuarded(lambda20_0,"lambda2")*log10Guarded(divmacro(
          2.51,"2.51",sqrtGuarded(lambda20_0,"lambda2"),"sqrt(lambda2)")+0.27*
          Delta0_0,"2.51/sqrt(lambda2)+0.27*Delta");
        aux2x_0der = divmacro(0.5*(aux1x_0der*fabs(dpx_0fric)+aux10_0*
          dpx_0fricx_0der*(IF dpx_0fric > 0 THEN 1 ELSE -1)),"0.5*(aux1_der*abs(dp_fric)+aux1*(dp_fric_der*noEvent((if dp_fric > 0 then 1 else -1))))",
          sqrtGuarded(aux10_0*fabs(dpx_0fric),"aux1*abs(dp_fric)"),
          "sqrt(aux1*abs(dp_fric))");
        aux20_0 = sqrtGuarded(aux10_0*fabs(dpx_0fric),"aux1*abs(dp_fric)");
        /* Introducing 19 common subexpressions used in 18 expressions */
        /* Of the common subexpressions 19 are reals, 0 are integers, and 0
           are booleans. */

        { double helpvarF[19];
        DYNX(helpvarF,0) = divmacro(1.0,"1.0",aux20_0,"aux2");
        DYNX(helpvarF,1) = DYNX(helpvarF,0)*2.51+0.27*Delta0_0;
        DYNX(helpvarF,2) = dpx_0fricx_0der*(IF dpx_0fric > 0 THEN 1 ELSE -1)*
          DYNX(helpvarF,1);
        DYNX(helpvarF,3) = fabs(dpx_0fric);
        DYNX(helpvarF,4) = sqr(aux20_0);
        DYNX(helpvarF,5) = divmacro(1.0,"1.0",DYNX(helpvarF,4),"aux2^2");
        DYNX(helpvarF,6) = 0.27*Deltax_0der-DYNX(helpvarF,5)*2.51*aux2x_0der;
        DYNX(helpvarF,7) = DYNX(helpvarF,3)*DYNX(helpvarF,6);
        DYNX(helpvarF,8) = DYNX(helpvarF,3)*DYNX(helpvarF,1);
        DYNX(helpvarF,9) = sqr(2.0*DYNX(helpvarF,8));
        DYNX(helpvarF,10) = divmacro(1.0,"1.0",DYNX(helpvarF,9),"(2.0*(abs(dp_fric)*(2.51/aux2+0.27*Delta)))^2");
        DYNX(helpvarF,11) = divmacro(1.0,"1.0",DYNX(helpvarF,1),"2.51/aux2+0.27*Delta");
        DYNX(helpvarF,12) = logGuarded(DYNX(helpvarF,1),"2.51/aux2+0.27*Delta");
        DYNX(helpvarF,13) = DYNX(helpvarF,11)*DYNX(helpvarF,6)*aux10_0+
          DYNX(helpvarF,12)*aux1x_0der;
        DYNX(helpvarF,14) = 2*aux20_0;
        DYNX(helpvarF,15) = divmacro(1.0,"1.0",DYNX(helpvarF,14),"2*aux2");
        DYNX(helpvarF,16) = DYNX(helpvarF,12)*aux10_0*aux2x_0der;
        DYNX(helpvarF,17) = sqr(DYNX(helpvarF,14));
        DYNX(helpvarF,18) = divmacro(1.0,"1.0",DYNX(helpvarF,17),"(2*aux2)^2");
        dRex_0ddpx_0der = (-0.43429448190325176)*(DYNX(helpvarF,10)*10.04*(
          DYNX(helpvarF,2)+DYNX(helpvarF,7))+DYNX(helpvarF,15)*2.0*
          DYNX(helpvarF,13)-DYNX(helpvarF,18)*4.0*DYNX(helpvarF,16));
        }
        dRex_0ddp = 0.43429448190325176*(divmacro(5.02,"5.02",2.0*fabs(dpx_0fric)
          *(divmacro(2.51,"2.51",aux20_0,"aux2")+0.27*Delta0_0),"2.0*(abs(dp_fric)*(2.51/aux2+0.27*Delta))")
          -divmacro(2.0*logGuarded(divmacro(2.51,"2.51",aux20_0,"aux2")+0.27*
          Delta0_0,"2.51/aux2+0.27*Delta")*aux10_0,"2.0*(log(2.51/aux2+0.27*Delta)*aux1)",2
          *aux20_0,"2*aux2"));
        if (Re0_0 < Re20_0) {
          {
            struct Modelica_Fluid_Pipes_BaseClasses_WallFriction_Detailed_Internal_mx_0flowx_0ofx_0dpx_0fric_interpolateInRegion2x_0withDerivative__der_struct
               dummy_mult_=Modelica_Fluid_Pipes_BaseClasses_WallFriction_Detailed_Internal_mx_0flowx_0ofx_0dpx_0fric_interpolateInRegion2x_0withDerivative__der
              (lambda20_0, Re10_0, Re20_0, Delta0_0, dpx_0fric, lambda2x_0der, 
              Re1x_0der, Re2x_0der, Deltax_0der, dpx_0fricx_0der);
            Rex_0der = dummy_mult_.Rex_0der_0member;
            dRex_0ddpx_0der = dummy_mult_.dRex_0ddpx_0der_0member;
          }
          {
            struct Modelica_Fluid_Pipes_BaseClasses_WallFriction_Detailed_Internal_mx_0flowx_0ofx_0dpx_0fric_interpolateInRegion2x_0withDerivative_struct
               dummy_mult_=Modelica_Fluid_Pipes_BaseClasses_WallFriction_Detailed_Internal_mx_0flowx_0ofx_0dpx_0fric_interpolateInRegion2x_0withDerivative
              (lambda20_0, Re10_0, Re20_0, Delta0_0, dpx_0fric);
            Re0_0 = dummy_mult_.Re0_0_0member;
            dRex_0ddp = dummy_mult_.dRex_0ddp_0member;
          }
        }
      }
      mx_0flowx_0der = divmacro((crossAreax_0der*mu0_0+crossArea0_0*mux_0der)*(
        IF dpx_0fric >= 0 THEN Re0_0 ELSE  -Re0_0)+crossArea0_0*mu0_0*(IF 
        dpx_0fric >= 0 THEN Rex_0der ELSE  -Rex_0der),"(crossArea_der*mu+crossArea*mu_der)*(if dp_fric >= 0 then Re else  -Re)+crossArea*mu*(if dp_fric >= 0 then Re_der else  -Re_der)",
        diameter0_0,"diameter")-divmacro(crossArea0_0*mu0_0*(IF dpx_0fric >= 0
         THEN Re0_0 ELSE  -Re0_0)*diameterx_0der,"crossArea*mu*(if dp_fric >= 0 then Re else  -Re)*diameter_der",
        sqr(diameter0_0),"diameter^2");
      mx_0flow = divmacro(crossArea0_0*mu0_0*(IF dpx_0fric >= 0 THEN Re0_0 ELSE 
         -Re0_0),"crossArea*mu*(if dp_fric >= 0 then Re else  -Re)",diameter0_0,
        "diameter");
      dmx_0flowx_0ddpx_0fricx_0der = divmacro((crossAreax_0der*mu0_0+
        crossArea0_0*mux_0der)*dRex_0ddp+crossArea0_0*mu0_0*dRex_0ddpx_0der,
        "(crossArea_der*mu+crossArea*mu_der)*dRe_ddp+crossArea*mu*dRe_ddp_der",
        diameter0_0,"diameter")-divmacro(crossArea0_0*mu0_0*dRex_0ddp*
        diameterx_0der,"crossArea*mu*dRe_ddp*diameter_der",sqr(diameter0_0),
        "diameter^2");
    /* Output section */
    PopContext()
    {
      struct Modelica_Fluid_Pipes_BaseClasses_WallFriction_Detailed_Internal_mx_0flowx_0ofx_0dpx_0fric__der_struct out_;
      out_.mx_0flowx_0der_0member = mx_0flowx_0der;
      out_.dmx_0flowx_0ddpx_0fricx_0der_0member = dmx_0flowx_0ddpx_0fricx_0der;
      return out_;
    }
  }}

/* Flattened Modelica model:

function Modelica.Fluid.Utilities.cubicHermite_withDerivative
discrete input Real x "Abscissa value";
discrete input Real x1 "Lower abscissa value";
discrete input Real x2 "Upper abscissa value";
discrete input Real y1 "Lower ordinate value";
discrete input Real y2 "Upper ordinate value";
discrete input Real y1d "Lower gradient";
discrete input Real y2d "Upper gradient";
discrete output Real y "Interpolated ordinate value";
discrete output Real dy_dx "Derivative dy/dx at abscissa value x";
protected 
discrete Real h "Distance between x1 and x2";
discrete Real t "abscissa scaled with h, i.e., t=[0..1] within x=[x1..x2]";
discrete Real h00 "Basis function 00 of cubic Hermite spline";
discrete Real h10 "Basis function 10 of cubic Hermite spline";
discrete Real h01 "Basis function 01 of cubic Hermite spline";
discrete Real h11 "Basis function 11 of cubic Hermite spline";
discrete Real h00d "d/dt h00";
discrete Real h10d "d/dt h10";
discrete Real h01d "d/dt h01";
discrete Real h11d "d/dt h11";
discrete Real aux3 "t cube";
discrete Real aux2 "t square";
public 
algorithm 
h := x2-x1;
if (abs(h) > 0) then 
t := (x-x1)/h;
aux3 := t^3;
aux2 := t^2;
h00 := 2*aux3-3*aux2+1;
h10 := aux3-2*aux2+t;
h01 := ( -2*aux3)+3*aux2;
h11 := aux3-aux2;
h00d := 6*(aux2-t);
h10d := 3*aux2-4*t+1;
h01d := 6*(t-aux2);
h11d := 3*aux2-2*t;
y := y1*h00+h*y1d*h10+y2*h01+h*y2d*h11;
dy_dx := y1*h00d/h+y1d*h10d+y2*h01d/h+y2d*h11d;
else
y := (y1+y2)/2;
dy_dx := noEvent((if y2-y1 > 0 then 1 else (if y2-y1 < 0 then -1 else 0)))*1E+060;
end if;
annotation(derivative=Modelica.Fluid.Utilities.cubicHermite_withDerivative:der, smoothOrder=3);
end Modelica.Fluid.Utilities.cubicHermite_withDerivative;

  */
DYMOLA_STATIC struct Modelica_Fluid_Utilities_cubicHermitex_0withDerivative_struct
   Modelica_Fluid_Utilities_cubicHermitex_0withDerivative(double  x0_0, double  
  x10_0, double  x20_0, double  y10_0, double  y20_0, double  y1d0_0, double  
  y2d0_0) {
  PushContext("Modelica.Fluid.Utilities.cubicHermite_withDerivative")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    double   dyx_0dx;
    double   h0_0;
    double   t0_0;
    double   h000_0;
    double   h100_0;
    double   h010_0;
    double   h110_0;
    double   h00d0_0;
    double   h10d0_0;
    double   h01d0_0;
    double   h11d0_0;
    double   aux30_0;
    double   aux20_0;
    y0_0=0;
    dyx_0dx=0;
    h0_0=0;
    t0_0=0;
    h000_0=0;
    h100_0=0;
    h010_0=0;
    h110_0=0;
    h00d0_0=0;
    h10d0_0=0;
    h01d0_0=0;
    h11d0_0=0;
    aux30_0=0;
    aux20_0=0;
    /* Start of real code */
      h0_0 = x20_0-x10_0;
      if (fabs(h0_0) > 0) {
        t0_0 = divmacro(x0_0-x10_0,"x-x1",h0_0,"h");
        aux30_0 = powmacro2(t0_0,"t",3,"3");
        aux20_0 = sqr(t0_0);
        h000_0 = 2*aux30_0-3*aux20_0+1;
        h100_0 = aux30_0-2*aux20_0+t0_0;
        h010_0 = ( -2*aux30_0)+3*aux20_0;
        h110_0 = aux30_0-aux20_0;
        h00d0_0 = 6*(aux20_0-t0_0);
        h10d0_0 = 3*aux20_0-4*t0_0+1;
        h01d0_0 = 6*(t0_0-aux20_0);
        h11d0_0 = 3*aux20_0-2*t0_0;
        y0_0 = y10_0*h000_0+h0_0*y1d0_0*h100_0+y20_0*h010_0+h0_0*y2d0_0*h110_0;
        dyx_0dx = divmacro(y10_0*h00d0_0,"y1*h00d",h0_0,"h")+y1d0_0*h10d0_0+
          divmacro(y20_0*h01d0_0,"y2*h01d",h0_0,"h")+y2d0_0*h11d0_0;
      }
      else{
        y0_0 = (y10_0+y20_0)/(double)(2);
        dyx_0dx = (IF y20_0-y10_0 > 0 THEN 1 ELSE IF y20_0-y10_0 < 0 THEN -1
           ELSE 0)*1E+060;
      }
    /* Output section */
    PopContext()
    {
      struct Modelica_Fluid_Utilities_cubicHermitex_0withDerivative_struct out_;
      out_.y0_0_0member = y0_0;
      out_.dyx_0dx_0member = dyx_0dx;
      return out_;
    }
  }}

/* Flattened Modelica model:

function Modelica.Fluid.Utilities.regFun3
discrete input Real x "Abscissa value";
discrete input Real x0 "Lower abscissa value";
discrete input Real x1 "Upper abscissa value";
discrete input Real y0 "Ordinate value at lower abscissa value";
discrete input Real y1 "Ordinate value at upper abscissa value";
discrete input Real y0d "Derivative at lower abscissa value";
discrete input Real y1d "Derivative at upper abscissa value";
discrete output Real y "Ordinate value";
discrete output Real c "Slope of linear section between two cubic polynomials or dummy linear section slope if single cubic is used";
protected 
discrete Real h0 "Width of interval i=0";
discrete Real Delta0 "Slope of secant on interval i=0";
discrete Real xstar "Inflection point of cubic polynomial S0";
discrete Real mu "Distance of inflection point and left limit x0";
discrete Real eta "Distance of right limit x1 and inflection point";
discrete Real omega "Slope of cubic polynomial S0 at inflection point";
discrete Real rho "Weighting factor of eta and eta_tilde, mu and mu_tilde";
discrete Real theta0 "Slope metric";
discrete Real mu_tilde "Distance of start of linear section and left limit x0";
discrete Real eta_tilde "Distance of right limit x1 and end of linear section";
discrete Real xi1 "Start of linear section";
discrete Real xi2 "End of linear section";
discrete Real a1 "Leading coefficient of cubic on the left";
discrete Real a2 "Leading coefficient of cubic on the right";
discrete Real const12 "Integration constant of left cubic, linear section";
discrete Real const3 "Integration constant of right cubic";
discrete Real aux01;
discrete Real aux02;
Boolean useSingleCubicPolynomial(start = false) "Indicate to override further logic and use single cubic";
public 
algorithm 
assert(x0 < x1, "regFun3(): Data points not sorted appropriately (x0 = "+       String(x0, true, 0)+" > x1 = "+       String(x1, true, 0)+"). Please flip arguments.");
if (y0d*y1d >= 0) then 
// No equations
else
assert(abs(y0d) < 1E-015 or abs(y1d) < 1E-015, "regFun3(): Derivatives at data points do not allow co-monotone interpolation, as both are non-zero, of opposite sign and have an absolute value larger than machine eps (y0d = "+       String(y0d, true, 0)+", y1d = "+       String(y1d, true, 0)+"). Please correct arguments.");
end if;
h0 := x1-x0;
Delta0 := (y1-y0)/h0;
if (abs(Delta0) <= 0) then 
y := y0+Delta0*(x-x0);
c := 0;
elseif (abs(y1d+y0d-2*Delta0) < 1E-013) then 
y := y0+(x-x0)*(y0d+(x-x0)/h0*(( -2*y0d)-y1d+3*Delta0+(x-x0)*(y0d+y1d-2*Delta0)/h0));
aux01 := (x0+x1)/2;
c := 3*(y0d+y1d-2*Delta0)*(aux01-x0)^2/h0^2+2*(( -2*y0d)-y1d+3*Delta0)*(aux01-x0)/h0+y0d;
else
xstar := 0.3333333333333333*(( -3*x0*y0d)-3*x0*y1d+6*x0*Delta0-2*h0*y0d-h0*y1d+3*h0*Delta0)/(( -y0d)-y1d+2*Delta0);
mu := xstar-x0;
eta := x1-xstar;
omega := 3*(y0d+y1d-2*Delta0)*(xstar-x0)^2/h0^2+2*(( -2*y0d)-y1d+3*Delta0)*(xstar-x0)/h0+y0d;
aux01 := 0.25*noEvent((if Delta0 > 0 then 1 else (if Delta0 < 0 then -1 else 0)))*min(abs(omega), abs(Delta0));
if (abs(y0d-y1d) <= 1E-013) then 
aux02 := y0d;
if (y1 > y0+y0d*(x1-x0)) then 
useSingleCubicPolynomial := true;
end if;
elseif (abs(y1d+y0d-2*Delta0) < 1E-013) then 
aux02 := (6*Delta0*(y1d+y0d-1.5*Delta0)-y1d*y0d-y1d^2-y0d^2)*(if y1d+y0d-2*Delta0 >= 0 then 1 else -1)*1E+060;
else
aux02 := (6*Delta0*(y1d+y0d-1.5*Delta0)-y1d*y0d-y1d^2-y0d^2)/(3*(y1d+y0d-2*Delta0));
end if;
if ((mu > 0 and eta < h0 and Delta0*omega <= 0 or abs(aux01) < abs(aux02) and aux02*Delta0 >= 0 or abs(aux01) < abs(0.1*Delta0)) and  not useSingleCubicPolynomial) then 
c := aux01;
if (abs(c) < abs(aux02) and aux02*Delta0 >= 0) then 
c := aux02;
end if;
if (abs(c) < abs(0.1*Delta0)) then 
c := 0.1*Delta0;
end if;
theta0 := (y0d*mu+y1d*eta)/h0;
if (abs(theta0-c) < 1E-006) then 
c := 0.999999*theta0;
end if;
rho := 3*(Delta0-c)/(theta0-c);
mu_tilde := rho*mu;
eta_tilde := rho*eta;
xi1 := x0+mu_tilde;
xi2 := x1-eta_tilde;
a1 := (y0d-c)/max(mu_tilde^2, 1E-013);
a2 := (y1d-c)/max(eta_tilde^2, 1E-013);
const12 := y0-a1/3*(x0-xi1)^3-c*x0;
const3 := y1-a2/3*(x1-xi2)^3-c*x1;
if (x < xi1) then 
y := a1/3*(x-xi1)^3+c*x+const12;
elseif (x < xi2) then 
y := c*x+const12;
else
y := a2/3*(x-xi2)^3+c*x+const3;
end if;
else
y := y0+(x-x0)*(y0d+(x-x0)/h0*(( -2*y0d)-y1d+3*Delta0+(x-x0)*(y0d+y1d-2*Delta0)/h0));
aux01 := (x0+x1)/2;
c := 3*(y0d+y1d-2*Delta0)*(aux01-x0)^2/h0^2+2*(( -2*y0d)-y1d+3*Delta0)*(aux01-x0)/h0+y0d;
end if;
end if;
annotation(derivative=Modelica.Fluid.Utilities.regFun3:der, smoothOrder=1);
end Modelica.Fluid.Utilities.regFun3;

  */
DYMOLA_STATIC struct Modelica_Fluid_Utilities_regFun3_struct Modelica_Fluid_Utilities_regFun3
  (double  x0_0, double  x00_0, double  x10_0, double  y00_0, double  y10_0, 
  double  y0d0_0, double  y1d0_0) {
  char*retSMark_=GetStringMark();
  PushContext("Modelica.Fluid.Utilities.regFun3")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    double   c0_0;
    double   h00_0;
    double   Delta00_0;
    double   xstar0_0;
    double   mu0_0;
    double   eta0_0;
    double   omega0_0;
    double   rho0_0;
    double   theta00_0;
    double   mux_0tilde;
    double   etax_0tilde;
    double   xi10_0;
    double   xi20_0;
    double   a10_0;
    double   a20_0;
    double   const120_0;
    double   const30_0;
    double   aux010_0;
    double   aux020_0;
    int   useSingleCubicPolynomial0_0;
    y0_0=0;
    c0_0=0;
    h00_0=0;
    Delta00_0=0;
    xstar0_0=0;
    mu0_0=0;
    eta0_0=0;
    omega0_0=0;
    rho0_0=0;
    theta00_0=0;
    mux_0tilde=0;
    etax_0tilde=0;
    xi10_0=0;
    xi20_0=0;
    a10_0=0;
    a20_0=0;
    const120_0=0;
    const30_0=0;
    aux010_0=0;
    aux020_0=0;
    useSingleCubicPolynomial0_0 = false;
    /* Start of real code */
      AssertModelica(x00_0 < x10_0,"x0 < x1", StringAdd(StringAdd(StringAdd(
        StringAdd("regFun3(): Data points not sorted appropriately (x0 = ",
        Real2String2(x00_0, true, 0))," > x1 = "),Real2String2(x10_0, true, 0)),
        "). Please flip arguments."));
      if (y0d0_0*y1d0_0 >= 0) {
        /* No equations */
      }
      else{
        AssertModelica(fabs(y0d0_0) < 1E-015 OR fabs(y1d0_0) < 1E-015,
          "abs(y0d) < 1E-015 or abs(y1d) < 1E-015", StringAdd(StringAdd(
          StringAdd(StringAdd("regFun3(): Derivatives at data points do not allow co-monotone interpolation, as both are non-zero, of opposite sign and have an absolute value larger than machine eps (y0d = ",
          Real2String2(y0d0_0, true, 0)),", y1d = "),Real2String2(y1d0_0, true, 0)),
          "). Please correct arguments."));
      }
      h00_0 = x10_0-x00_0;
      Delta00_0 = divmacro(y10_0-y00_0,"y1-y0",h00_0,"h0");
      if (fabs(Delta00_0) <= 0) {
        y0_0 = y00_0+Delta00_0*(x0_0-x00_0);
        c0_0 = 0;
      }
      else if (fabs(y1d0_0+y0d0_0-2*Delta00_0) < 1E-013) {
        y0_0 = y00_0+(x0_0-x00_0)*(y0d0_0+divmacro(x0_0-x00_0,"x-x0",h00_0,"h0")
          *(( -2*y0d0_0)-y1d0_0+3*Delta00_0+divmacro((x0_0-x00_0)*(y0d0_0+y1d0_0
          -2*Delta00_0),"(x-x0)*(y0d+y1d-2*Delta0)",h00_0,"h0")));
        aux010_0 = (x00_0+x10_0)/(double)(2);
        c0_0 = divmacro(3*(y0d0_0+y1d0_0-2*Delta00_0)*sqr(aux010_0-x00_0),
          "3*(y0d+y1d-2*Delta0)*(aux01-x0)^2",sqr(h00_0),"h0^2")+divmacro(2*(( -2
          *y0d0_0)-y1d0_0+3*Delta00_0)*(aux010_0-x00_0),"2*(( -2*y0d)-y1d+3*Delta0)*(aux01-x0)",
          h00_0,"h0")+y0d0_0;
      }
      else{
        xstar0_0 = divmacro(0.3333333333333333*(( -3*x00_0*y0d0_0)-3*x00_0*
          y1d0_0+6*x00_0*Delta00_0-2*h00_0*y0d0_0-h00_0*y1d0_0+3*h00_0*Delta00_0),
          "0.3333333333333333*(( -3*x0*y0d)-3*x0*y1d+6*x0*Delta0-2*h0*y0d-h0*y1d+3*h0*Delta0)",
          ( -y0d0_0)-y1d0_0+2*Delta00_0,"( -y0d)-y1d+2*Delta0");
        mu0_0 = xstar0_0-x00_0;
        eta0_0 = x10_0-xstar0_0;
        omega0_0 = divmacro(3*(y0d0_0+y1d0_0-2*Delta00_0)*sqr(xstar0_0-x00_0),
          "3*(y0d+y1d-2*Delta0)*(xstar-x0)^2",sqr(h00_0),"h0^2")+divmacro(2*(( -2
          *y0d0_0)-y1d0_0+3*Delta00_0)*(xstar0_0-x00_0),"2*(( -2*y0d)-y1d+3*Delta0)*(xstar-x0)",
          h00_0,"h0")+y0d0_0;
        aux010_0 = 0.25*(IF Delta00_0 > 0 THEN 1 ELSE IF Delta00_0 < 0 THEN -1
           ELSE 0)*RealBmin(fabs(omega0_0), fabs(Delta00_0));
        if (fabs(y0d0_0-y1d0_0) <= 1E-013) {
          aux020_0 = y0d0_0;
          if (y10_0 > y00_0+y0d0_0*(x10_0-x00_0)) {
            useSingleCubicPolynomial0_0 = true;
          }
        }
        else if (fabs(y1d0_0+y0d0_0-2*Delta00_0) < 1E-013) {
          aux020_0 = (6*Delta00_0*(y1d0_0+y0d0_0-1.5*Delta00_0)-y1d0_0*y0d0_0-
            sqr(y1d0_0)-sqr(y0d0_0))*(IF y1d0_0+y0d0_0-2*Delta00_0 >= 0 THEN 1
             ELSE -1)*1E+060;
        }
        else{
          aux020_0 = divmacro(6*Delta00_0*(y1d0_0+y0d0_0-1.5*Delta00_0)-y1d0_0*
            y0d0_0-sqr(y1d0_0)-sqr(y0d0_0),"6*Delta0*(y1d+y0d-1.5*Delta0)-y1d*y0d-y1d^2-y0d^2",3
            *(y1d0_0+y0d0_0-2*Delta00_0),"3*(y1d+y0d-2*Delta0)");
        }
        if ((mu0_0 > 0 AND eta0_0 < h00_0 AND Delta00_0*omega0_0 <= 0 OR fabs(
          aux010_0) < fabs(aux020_0) AND aux020_0*Delta00_0 >= 0 OR fabs(
          aux010_0) < fabs(0.1*Delta00_0)) AND  NOT useSingleCubicPolynomial0_0)
           {
          c0_0 = aux010_0;
          if (fabs(c0_0) < fabs(aux020_0) AND aux020_0*Delta00_0 >= 0) {
            c0_0 = aux020_0;
          }
          if (fabs(c0_0) < fabs(0.1*Delta00_0)) {
            c0_0 = 0.1*Delta00_0;
          }
          theta00_0 = divmacro(y0d0_0*mu0_0+y1d0_0*eta0_0,"y0d*mu+y1d*eta",h00_0,
            "h0");
          if (fabs(theta00_0-c0_0) < 1E-006) {
            c0_0 = 0.999999*theta00_0;
          }
          rho0_0 = divmacro(3*(Delta00_0-c0_0),"3*(Delta0-c)",theta00_0-c0_0,
            "theta0-c");
          mux_0tilde = rho0_0*mu0_0;
          etax_0tilde = rho0_0*eta0_0;
          xi10_0 = x00_0+mux_0tilde;
          xi20_0 = x10_0-etax_0tilde;
          a10_0 = divmacro(y0d0_0-c0_0,"y0d-c",RealBmax(sqr(mux_0tilde), 1E-013),
            "max(mu_tilde^2, 1E-013)");
          a20_0 = divmacro(y1d0_0-c0_0,"y1d-c",RealBmax(sqr(etax_0tilde), 1E-013),
            "max(eta_tilde^2, 1E-013)");
          const120_0 = y00_0-a10_0/(double)(3)*powmacro2(x00_0-xi10_0,"x0-xi1",3,
            "3")-c0_0*x00_0;
          const30_0 = y10_0-a20_0/(double)(3)*powmacro2(x10_0-xi20_0,"x1-xi2",3,
            "3")-c0_0*x10_0;
          if (x0_0 < xi10_0) {
            y0_0 = a10_0/(double)(3)*powmacro2(x0_0-xi10_0,"x-xi1",3,"3")+c0_0*
              x0_0+const120_0;
          }
          else if (x0_0 < xi20_0) {
            y0_0 = c0_0*x0_0+const120_0;
          }
          else{
            y0_0 = a20_0/(double)(3)*powmacro2(x0_0-xi20_0,"x-xi2",3,"3")+c0_0*
              x0_0+const30_0;
          }
        }
        else{
          y0_0 = y00_0+(x0_0-x00_0)*(y0d0_0+divmacro(x0_0-x00_0,"x-x0",h00_0,
            "h0")*(( -2*y0d0_0)-y1d0_0+3*Delta00_0+divmacro((x0_0-x00_0)*(y0d0_0
            +y1d0_0-2*Delta00_0),"(x-x0)*(y0d+y1d-2*Delta0)",h00_0,"h0")));
          aux010_0 = (x00_0+x10_0)/(double)(2);
          c0_0 = divmacro(3*(y0d0_0+y1d0_0-2*Delta00_0)*sqr(aux010_0-x00_0),
            "3*(y0d+y1d-2*Delta0)*(aux01-x0)^2",sqr(h00_0),"h0^2")+divmacro(2*((
             -2*y0d0_0)-y1d0_0+3*Delta00_0)*(aux010_0-x00_0),"2*(( -2*y0d)-y1d+3*Delta0)*(aux01-x0)",
            h00_0,"h0")+y0d0_0;
        }
      }
    /* Output section */
    SetStringMark(retSMark_);
    PopContext()
    {
      struct Modelica_Fluid_Utilities_regFun3_struct out_;
      out_.y0_0_0member = y0_0;
      out_.c0_0_0member = c0_0;
      return out_;
    }
  }}

/* Flattened Modelica model:

function Modelica.Fluid.Utilities.regFun3:der
discrete input Real x;
discrete input Real x0;
discrete input Real x1;
discrete input Real y0;
discrete input Real y1;
discrete input Real y0d;
discrete input Real y1d;
protected 
discrete Real y;
discrete Real c;
discrete Real h0;
discrete Real Delta0;
discrete Real xstar;
discrete Real mu;
discrete Real eta;
discrete Real omega;
discrete Real rho;
discrete Real theta0;
discrete Real mu_tilde;
discrete Real eta_tilde;
discrete Real xi1;
discrete Real xi2;
discrete Real a1;
discrete Real a2;
discrete Real const12;
discrete Real const3;
discrete Real aux01;
discrete Real aux02;
Boolean useSingleCubicPolynomial(start = false);
public 
discrete input Real x_der;
discrete input Real x0_der;
discrete input Real x1_der;
discrete input Real y0_der;
discrete input Real y1_der;
discrete input Real y0d_der;
discrete input Real y1d_der;
discrete output Real y_der;
discrete output Real c_der;
protected 
discrete Real h0_der;
discrete Real Delta0_der;
discrete Real xstar_der;
discrete Real mu_der;
discrete Real eta_der;
discrete Real omega_der;
discrete Real rho_der;
discrete Real theta0_der;
discrete Real mu_tilde_der;
discrete Real eta_tilde_der;
discrete Real xi1_der;
discrete Real xi2_der;
discrete Real a1_der;
discrete Real a2_der;
discrete Real const12_der;
discrete Real const3_der;
discrete Real aux01_der;
discrete Real aux02_der;
public 
algorithm 
assert(x0 < x1, "regFun3(): Data points not sorted appropriately (x0 = "+       String(x0, true, 0)+" > x1 = "+       String(x1, true, 0)+"). Please flip arguments.");
if (y0d*y1d >= 0) then 
// No equations
else
assert(abs(y0d) < 1E-015 or abs(y1d) < 1E-015, "regFun3(): Derivatives at data points do not allow co-monotone interpolation, as both are non-zero, of opposite sign and have an absolute value larger than machine eps (y0d = "+       String(y0d, true, 0)+", y1d = "+       String(y1d, true, 0)+"). Please correct arguments.");
end if;
h0_der := x1_der-x0_der;
h0 := x1-x0;
Delta0_der := (y1_der-y0_der)/h0-(y1-y0)*h0_der/h0^2;
Delta0 := (y1-y0)/h0;
if (abs(Delta0) <= 0) then 
y_der := y0_der+Delta0_der*(x-x0)+Delta0*(x_der-x0_der);
y := y0+Delta0*(x-x0);
c_der := 0;
elseif (abs(y1d+y0d-2*Delta0) < 1E-013) then 
y_der := y0_der+(x_der-x0_der)*(y0d+(x-x0)*((-2)*y0d-y1d+3*Delta0+(x-x0)*(y0d+y1d-2*Delta0)/h0)/h0)+(x-x0)*(y0d_der+((x_der-x0_der)*((-2)*y0d-y1d+3*Delta0+(x-x0)*(y0d+y1d-2*Delta0)/h0)+(x-x0)*((-2)*y0d_der-y1d_der+3*Delta0_der+((x_der-x0_der)*(y0d+y1d-2*Delta0)+(x-x0)*(y0d_der+y1d_der-2*Delta0_der))/h0-(x-x0)*(y0d+y1d-2*Delta0)*h0_der/h0^2))/h0-(x-x0)*((-2)*y0d-y1d+3*Delta0+(x-x0)*(y0d+y1d-2*Delta0)/h0)*h0_der/h0^2);
y := y0+(x-x0)*(y0d+(x-x0)*((-2)*y0d-y1d+3*Delta0+(x-x0)*(y0d+y1d-2*Delta0)/h0)/h0);
aux01_der := 0.5*(x0_der+x1_der);
aux01 := 0.5*(x0+x1);
c_der := 3.0*((y0d_der+y1d_der-2*Delta0_der)*(aux01-x0)^2+2.0*((y0d+y1d-2*Delta0)*((aux01-x0)*(aux01_der-x0_der))))/h0^2-6.0*((y0d+y1d-2*Delta0)*(aux01-x0)^2*(h0*h0_der))/(h0^2)^2+2.0*(((-2)*y0d_der-y1d_der+3*Delta0_der)*(aux01-x0)+((-2)*y0d-y1d+3*Delta0)*(aux01_der-x0_der))/h0-2.0*(((-2)*y0d-y1d+3*Delta0)*(aux01-x0)*h0_der)/h0^2+y0d_der;
else
xstar_der := 0.3333333333333333*(6.0*(x0_der*Delta0+x0*Delta0_der)-3.0*(x0_der*y0d+x0*y0d_der+x0_der*y1d+x0*y1d_der)-2.0*(h0_der*y0d+h0*y0d_der)-(h0_der*y1d+h0*y1d_der)+3.0*(h0_der*Delta0+h0*Delta0_der))/(2*Delta0-(y0d+y1d))-0.3333333333333333*((6.0*(x0*Delta0)-3.0*(x0*y0d+x0*y1d)-2.0*(h0*y0d)-h0*y1d+3.0*(h0*Delta0))*(2*Delta0_der-(y0d_der+y1d_der)))/(2*Delta0-(y0d+y1d))^2;
xstar := 0.3333333333333333*(6.0*(x0*Delta0)-3.0*(x0*y0d+x0*y1d)-2.0*(h0*y0d)-h0*y1d+3.0*(h0*Delta0))/(2*Delta0-(y0d+y1d));
mu_der := xstar_der-x0_der;
mu := xstar-x0;
eta_der := x1_der-xstar_der;
eta := x1-xstar;
omega_der := 3.0*((y0d_der+y1d_der-2*Delta0_der)*(xstar-x0)^2+2.0*((y0d+y1d-2*Delta0)*((xstar-x0)*(xstar_der-x0_der))))/h0^2-6.0*((y0d+y1d-2*Delta0)*(xstar-x0)^2*(h0*h0_der))/(h0^2)^2+2.0*(((-2)*y0d_der-y1d_der+3*Delta0_der)*(xstar-x0)+((-2)*y0d-y1d+3*Delta0)*(xstar_der-x0_der))/h0-2.0*(((-2)*y0d-y1d+3*Delta0)*(xstar-x0)*h0_der)/h0^2+y0d_der;
omega := 3.0*((y0d+y1d-2*Delta0)*(xstar-x0)^2)/h0^2+2.0*(((-2)*y0d-y1d+3*Delta0)*(xstar-x0))/h0+y0d;
aux01_der := 0.25*(noEvent((if Delta0 > 0 then 1 else (if Delta0 < 0 then -1 else 0)))*(if noEvent(abs(omega) < abs(Delta0)) then omega_der*noEvent((if omega > 0 then 1 else -1)) else Delta0_der*noEvent((if Delta0 > 0 then 1 else -1))));
aux01 := 0.25*(noEvent((if Delta0 > 0 then 1 else (if Delta0 < 0 then -1 else 0)))*min(abs(omega), abs(Delta0)));
if (abs(y0d-y1d) <= 1E-013) then 
aux02_der := y0d_der;
aux02 := y0d;
if (y1 > y0+y0d*(x1-x0)) then 
useSingleCubicPolynomial := true;
end if;
elseif (abs(y1d+y0d-2*Delta0) < 1E-013) then 
aux02_der := 1E+060*((6.0*(Delta0_der*(y1d+y0d-1.5*Delta0)+Delta0*(y1d_der+y0d_der-1.5*Delta0_der))-(y1d_der*y0d+y1d*y0d_der)-2.0*(y1d*y1d_der)-2.0*(y0d*y0d_der))*(if y1d+y0d-2*Delta0 >= 0 then 1 else -1));
aux02 := 1E+060*((6.0*(Delta0*(y1d+y0d-1.5*Delta0))-y1d*y0d-y1d^2-y0d^2)*(if y1d+y0d-2*Delta0 >= 0 then 1 else -1));
else
aux02_der := (6.0*(Delta0_der*(y1d+y0d-1.5*Delta0)+Delta0*(y1d_der+y0d_der-1.5*Delta0_der))-(y1d_der*y0d+y1d*y0d_der)-2.0*(y1d*y1d_der)-2.0*(y0d*y0d_der))/(3*(y1d+y0d-2*Delta0))-3.0*((6.0*(Delta0*(y1d+y0d-1.5*Delta0))-y1d*y0d-y1d^2-y0d^2)*(y1d_der+y0d_der-2*Delta0_der))/(3*(y1d+y0d-2*Delta0))^2;
aux02 := (6.0*(Delta0*(y1d+y0d-1.5*Delta0))-y1d*y0d-y1d^2-y0d^2)/(3*(y1d+y0d-2*Delta0));
end if;
if ((mu > 0 and eta < h0 and Delta0*omega <= 0 or abs(aux01) < abs(aux02) and aux02*Delta0 >= 0 or abs(aux01) < abs(0.1*Delta0)) and  not useSingleCubicPolynomial) then 
c_der := aux01_der;
c := aux01;
if (abs(c) < abs(aux02) and aux02*Delta0 >= 0) then 
c_der := aux02_der;
c := aux02;
end if;
if (abs(c) < abs(0.1*Delta0)) then 
c_der := 0.1*Delta0_der;
c := 0.1*Delta0;
end if;
theta0_der := (y0d_der*mu+y0d*mu_der+y1d_der*eta+y1d*eta_der)/h0-(y0d*mu+y1d*eta)*h0_der/h0^2;
theta0 := (y0d*mu+y1d*eta)/h0;
if (abs(theta0-c) < 1E-006) then 
c_der := 0.999999*theta0_der;
c := 0.999999*theta0;
end if;
rho_der := 3*(Delta0_der-c_der)/(theta0-c)-3.0*((Delta0-c)*(theta0_der-c_der))/(theta0-c)^2;
rho := 3*(Delta0-c)/(theta0-c);
mu_tilde_der := rho_der*mu+rho*mu_der;
mu_tilde := rho*mu;
eta_tilde_der := rho_der*eta+rho*eta_der;
eta_tilde := rho*eta;
xi1_der := x0_der+mu_tilde_der;
xi1 := x0+mu_tilde;
xi2_der := x1_der-eta_tilde_der;
xi2 := x1-eta_tilde;
a1_der := (y0d_der-c_der)/max(mu_tilde^2, 1E-013)-(y0d-c)*(if noEvent(mu_tilde^2 > 1E-013) then 2.0*(mu_tilde*mu_tilde_der) else 0.0)/max(mu_tilde^2, 1E-013)^2;
a1 := (y0d-c)/max(mu_tilde^2, 1E-013);
a2_der := (y1d_der-c_der)/max(eta_tilde^2, 1E-013)-(y1d-c)*(if noEvent(eta_tilde^2 > 1E-013) then 2.0*(eta_tilde*eta_tilde_der) else 0.0)/max(eta_tilde^2, 1E-013)^2;
a2 := (y1d-c)/max(eta_tilde^2, 1E-013);
const12_der := y0_der-0.3333333333333333*(a1_der*(x0-xi1)^3+3.0*(a1*((x0-xi1)^2*(x0_der-xi1_der))))-(c_der*x0+c*x0_der);
const12 := y0-0.3333333333333333*(a1*(x0-xi1)^3)-c*x0;
const3_der := y1_der-0.3333333333333333*(a2_der*(x1-xi2)^3+3.0*(a2*((x1-xi2)^2*(x1_der-xi2_der))))-(c_der*x1+c*x1_der);
const3 := y1-0.3333333333333333*(a2*(x1-xi2)^3)-c*x1;
if (x < xi1) then 
y_der := 0.3333333333333333*(a1_der*(x-xi1)^3+3.0*(a1*((x-xi1)^2*(x_der-xi1_der))))+c_der*x+c*x_der+const12_der;
elseif (x < xi2) then 
y_der := c_der*x+c*x_der+const12_der;
else
y_der := 0.3333333333333333*(a2_der*(x-xi2)^3+3.0*(a2*((x-xi2)^2*(x_der-xi2_der))))+c_der*x+c*x_der+const3_der;
end if;
else
y_der := y0_der+(x_der-x0_der)*(y0d+(x-x0)*((-2)*y0d-y1d+3*Delta0+(x-x0)*(y0d+y1d-2*Delta0)/h0)/h0)+(x-x0)*(y0d_der+((x_der-x0_der)*((-2)*y0d-y1d+3*Delta0+(x-x0)*(y0d+y1d-2*Delta0)/h0)+(x-x0)*((-2)*y0d_der-y1d_der+3*Delta0_der+((x_der-x0_der)*(y0d+y1d-2*Delta0)+(x-x0)*(y0d_der+y1d_der-2*Delta0_der))/h0-(x-x0)*(y0d+y1d-2*Delta0)*h0_der/h0^2))/h0-(x-x0)*((-2)*y0d-y1d+3*Delta0+(x-x0)*(y0d+y1d-2*Delta0)/h0)*h0_der/h0^2);
y := y0+(x-x0)*(y0d+(x-x0)*((-2)*y0d-y1d+3*Delta0+(x-x0)*(y0d+y1d-2*Delta0)/h0)/h0);
aux01_der := 0.5*(x0_der+x1_der);
aux01 := 0.5*(x0+x1);
c_der := 3.0*((y0d_der+y1d_der-2*Delta0_der)*(aux01-x0)^2+2.0*((y0d+y1d-2*Delta0)*((aux01-x0)*(aux01_der-x0_der))))/h0^2-6.0*((y0d+y1d-2*Delta0)*(aux01-x0)^2*(h0*h0_der))/(h0^2)^2+2.0*(((-2)*y0d_der-y1d_der+3*Delta0_der)*(aux01-x0)+((-2)*y0d-y1d+3*Delta0)*(aux01_der-x0_der))/h0-2.0*(((-2)*y0d-y1d+3*Delta0)*(aux01-x0)*h0_der)/h0^2+y0d_der;
end if;
end if;
annotation(smoothOrder=0);
end Modelica.Fluid.Utilities.regFun3:der;

  */
DYMOLA_STATIC struct Modelica_Fluid_Utilities_regFun3__der_struct 
  Modelica_Fluid_Utilities_regFun3__der(double  x0_0, double  x00_0, double  
  x10_0, double  y00_0, double  y10_0, double  y0d0_0, double  y1d0_0, double  
  xx_0der, double  x0x_0der, double  x1x_0der, double  y0x_0der, double  
  y1x_0der, double  y0dx_0der, double  y1dx_0der) {
  char*retSMark_=GetStringMark();
  PushContext("Modelica.Fluid.Utilities.regFun3:der")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    double   c0_0;
    double   h00_0;
    double   Delta00_0;
    double   xstar0_0;
    double   mu0_0;
    double   eta0_0;
    double   omega0_0;
    double   rho0_0;
    double   theta00_0;
    double   mux_0tilde;
    double   etax_0tilde;
    double   xi10_0;
    double   xi20_0;
    double   a10_0;
    double   a20_0;
    double   const120_0;
    double   const30_0;
    double   aux010_0;
    double   aux020_0;
    int   useSingleCubicPolynomial0_0;
    double   yx_0der;
    double   cx_0der;
    double   h0x_0der;
    double   Delta0x_0der;
    double   xstarx_0der;
    double   mux_0der;
    double   etax_0der;
    double   omegax_0der;
    double   rhox_0der;
    double   theta0x_0der;
    double   mux_0tildex_0der;
    double   etax_0tildex_0der;
    double   xi1x_0der;
    double   xi2x_0der;
    double   a1x_0der;
    double   a2x_0der;
    double   const12x_0der;
    double   const3x_0der;
    double   aux01x_0der;
    double   aux02x_0der;
    y0_0=0;
    c0_0=0;
    h00_0=0;
    Delta00_0=0;
    xstar0_0=0;
    mu0_0=0;
    eta0_0=0;
    omega0_0=0;
    rho0_0=0;
    theta00_0=0;
    mux_0tilde=0;
    etax_0tilde=0;
    xi10_0=0;
    xi20_0=0;
    a10_0=0;
    a20_0=0;
    const120_0=0;
    const30_0=0;
    aux010_0=0;
    aux020_0=0;
    useSingleCubicPolynomial0_0 = false;
    yx_0der=0;
    cx_0der=0;
    h0x_0der=0;
    Delta0x_0der=0;
    xstarx_0der=0;
    mux_0der=0;
    etax_0der=0;
    omegax_0der=0;
    rhox_0der=0;
    theta0x_0der=0;
    mux_0tildex_0der=0;
    etax_0tildex_0der=0;
    xi1x_0der=0;
    xi2x_0der=0;
    a1x_0der=0;
    a2x_0der=0;
    const12x_0der=0;
    const3x_0der=0;
    aux01x_0der=0;
    aux02x_0der=0;
    /* Start of real code */
      AssertModelica(x00_0 < x10_0,"x0 < x1", StringAdd(StringAdd(StringAdd(
        StringAdd("regFun3(): Data points not sorted appropriately (x0 = ",
        Real2String2(x00_0, true, 0))," > x1 = "),Real2String2(x10_0, true, 0)),
        "). Please flip arguments."));
      if (y0d0_0*y1d0_0 >= 0) {
        /* No equations */
      }
      else{
        AssertModelica(fabs(y0d0_0) < 1E-015 OR fabs(y1d0_0) < 1E-015,
          "abs(y0d) < 1E-015 or abs(y1d) < 1E-015", StringAdd(StringAdd(
          StringAdd(StringAdd("regFun3(): Derivatives at data points do not allow co-monotone interpolation, as both are non-zero, of opposite sign and have an absolute value larger than machine eps (y0d = ",
          Real2String2(y0d0_0, true, 0)),", y1d = "),Real2String2(y1d0_0, true, 0)),
          "). Please correct arguments."));
      }
      h0x_0der = x1x_0der-x0x_0der;
      h00_0 = x10_0-x00_0;
      Delta0x_0der = divmacro(y1x_0der-y0x_0der,"y1_der-y0_der",h00_0,"h0")-
        divmacro((y10_0-y00_0)*h0x_0der,"(y1-y0)*h0_der",sqr(h00_0),"h0^2");
      Delta00_0 = divmacro(y10_0-y00_0,"y1-y0",h00_0,"h0");
      if (fabs(Delta00_0) <= 0) {
        yx_0der = y0x_0der+Delta0x_0der*(x0_0-x00_0)+Delta00_0*(xx_0der-x0x_0der);
        y0_0 = y00_0+Delta00_0*(x0_0-x00_0);
        cx_0der = 0;
      }
      else if (fabs(y1d0_0+y0d0_0-2*Delta00_0) < 1E-013) {
        /* Introducing 14 common subexpressions used in 18 expressions */
        /* Of the common subexpressions 14 are reals, 0 are integers, and 0
           are booleans. */

        { double helpvarF[14];
        DYNX(helpvarF,0) = xx_0der-x0x_0der;
        DYNX(helpvarF,1) = x0_0-x00_0;
        DYNX(helpvarF,2) = y0d0_0+y1d0_0-2*Delta00_0;
        DYNX(helpvarF,3) = DYNX(helpvarF,1)*DYNX(helpvarF,2);
        DYNX(helpvarF,4) = divmacro(1.0,"1.0",h00_0,"h0");
        DYNX(helpvarF,5) = (-2)*y0d0_0-y1d0_0+3*Delta00_0+DYNX(helpvarF,4)*
          DYNX(helpvarF,3);
        DYNX(helpvarF,6) = DYNX(helpvarF,1)*DYNX(helpvarF,5);
        DYNX(helpvarF,7) = (-2)*y0dx_0der;
        DYNX(helpvarF,8) = DYNX(helpvarF,0)*DYNX(helpvarF,2)+DYNX(helpvarF,1)*(
          y0dx_0der+y1dx_0der-2*Delta0x_0der);
        DYNX(helpvarF,9) = DYNX(helpvarF,3)*h0x_0der;
        DYNX(helpvarF,10) = sqr(h00_0);
        DYNX(helpvarF,11) = divmacro(1.0,"1.0",DYNX(helpvarF,10),"h0^2");
        DYNX(helpvarF,12) = DYNX(helpvarF,4)*(DYNX(helpvarF,0)*DYNX(helpvarF,5)+
          DYNX(helpvarF,1)*(DYNX(helpvarF,7)-y1dx_0der+3*Delta0x_0der+
          DYNX(helpvarF,4)*DYNX(helpvarF,8)-DYNX(helpvarF,11)*DYNX(helpvarF,9)));
        DYNX(helpvarF,13) = DYNX(helpvarF,11)*DYNX(helpvarF,6)*h0x_0der;
        yx_0der = y0x_0der+DYNX(helpvarF,0)*(y0d0_0+DYNX(helpvarF,4)*
          DYNX(helpvarF,6))+DYNX(helpvarF,1)*(y0dx_0der+DYNX(helpvarF,12)-
          DYNX(helpvarF,13));
        }
        y0_0 = y00_0+(x0_0-x00_0)*(y0d0_0+divmacro((x0_0-x00_0)*((-2)*y0d0_0-
          y1d0_0+3*Delta00_0+divmacro((x0_0-x00_0)*(y0d0_0+y1d0_0-2*Delta00_0),
          "(x-x0)*(y0d+y1d-2*Delta0)",h00_0,"h0")),"(x-x0)*((-2)*y0d-y1d+3*Delta0+(x-x0)*(y0d+y1d-2*Delta0)/h0)",
          h00_0,"h0"));
        aux01x_0der = 0.5*(x0x_0der+x1x_0der);
        aux010_0 = 0.5*(x00_0+x10_0);
        /* Introducing 14 common subexpressions used in 15 expressions */
        /* Of the common subexpressions 14 are reals, 0 are integers, and 0
           are booleans. */

        { double helpvarF[14];
        DYNX(helpvarF,0) = aux010_0-x00_0;
        DYNX(helpvarF,1) = sqr(DYNX(helpvarF,0));
        DYNX(helpvarF,2) = y0d0_0+y1d0_0-2*Delta00_0;
        DYNX(helpvarF,3) = aux01x_0der-x0x_0der;
        DYNX(helpvarF,4) = (y0dx_0der+y1dx_0der-2*Delta0x_0der)*DYNX(helpvarF,1)
          +2.0*DYNX(helpvarF,2)*DYNX(helpvarF,0)*DYNX(helpvarF,3);
        DYNX(helpvarF,5) = sqr(h00_0);
        DYNX(helpvarF,6) = divmacro(1.0,"1.0",DYNX(helpvarF,5),"h0^2");
        DYNX(helpvarF,7) = DYNX(helpvarF,2)*DYNX(helpvarF,1)*h00_0*h0x_0der;
        DYNX(helpvarF,8) = sqr(DYNX(helpvarF,5));
        DYNX(helpvarF,9) = divmacro(1.0,"1.0",DYNX(helpvarF,8),"(h0^2)^2");
        DYNX(helpvarF,10) = (-2)*y0d0_0-y1d0_0+3*Delta00_0;
        DYNX(helpvarF,11) = ((-2)*y0dx_0der-y1dx_0der+3*Delta0x_0der)*
          DYNX(helpvarF,0)+DYNX(helpvarF,10)*DYNX(helpvarF,3);
        DYNX(helpvarF,12) = divmacro(1.0,"1.0",h00_0,"h0");
        DYNX(helpvarF,13) = DYNX(helpvarF,10)*DYNX(helpvarF,0)*h0x_0der;
        cx_0der = DYNX(helpvarF,6)*3.0*DYNX(helpvarF,4)-DYNX(helpvarF,9)*6.0*
          DYNX(helpvarF,7)+DYNX(helpvarF,12)*2.0*DYNX(helpvarF,11)-
          DYNX(helpvarF,6)*2.0*DYNX(helpvarF,13)+y0dx_0der;
        }
      }
      else{
        /* Introducing 11 common subexpressions used in 5 expressions */
        /* Of the common subexpressions 11 are reals, 0 are integers, and 0
           are booleans. */

        { double helpvarF[11];
        DYNX(helpvarF,0) = 6.0*(x0x_0der*Delta00_0+x00_0*Delta0x_0der)-3.0*(
          x0x_0der*y0d0_0+x00_0*y0dx_0der+x0x_0der*y1d0_0+x00_0*y1dx_0der)-2.0*(
          h0x_0der*y0d0_0+h00_0*y0dx_0der);
        DYNX(helpvarF,1) = h0x_0der*y1d0_0+h00_0*y1dx_0der;
        DYNX(helpvarF,2) = h0x_0der*Delta00_0+h00_0*Delta0x_0der;
        DYNX(helpvarF,3) = 2*Delta00_0-(y0d0_0+y1d0_0);
        DYNX(helpvarF,4) = divmacro(1.0,"1.0",DYNX(helpvarF,3),"2*Delta0-(y0d+y1d)");
        DYNX(helpvarF,5) = 6.0*x00_0*Delta00_0-3.0*(x00_0*y0d0_0+x00_0*y1d0_0)-
          2.0*h00_0*y0d0_0-h00_0*y1d0_0;
        DYNX(helpvarF,6) = 3.0*h00_0*Delta00_0;
        DYNX(helpvarF,7) = 2*Delta0x_0der;
        DYNX(helpvarF,8) = y0dx_0der+y1dx_0der;
        DYNX(helpvarF,9) = sqr(DYNX(helpvarF,3));
        DYNX(helpvarF,10) = divmacro(1.0,"1.0",DYNX(helpvarF,9),"(2*Delta0-(y0d+y1d))^2");
        xstarx_0der = DYNX(helpvarF,4)*0.3333333333333333*(DYNX(helpvarF,0)-
          DYNX(helpvarF,1)+3.0*DYNX(helpvarF,2))-DYNX(helpvarF,10)*
          0.3333333333333333*(DYNX(helpvarF,5)+DYNX(helpvarF,6))*(
          DYNX(helpvarF,7)-DYNX(helpvarF,8));
        }
        xstar0_0 = divmacro(0.3333333333333333*(6.0*x00_0*Delta00_0-3.0*(x00_0*
          y0d0_0+x00_0*y1d0_0)-2.0*h00_0*y0d0_0-h00_0*y1d0_0+3.0*h00_0*Delta00_0),
          "0.3333333333333333*(6.0*(x0*Delta0)-3.0*(x0*y0d+x0*y1d)-2.0*(h0*y0d)-h0*y1d+3.0*(h0*Delta0))",2
          *Delta00_0-(y0d0_0+y1d0_0),"2*Delta0-(y0d+y1d)");
        mux_0der = xstarx_0der-x0x_0der;
        mu0_0 = xstar0_0-x00_0;
        etax_0der = x1x_0der-xstarx_0der;
        eta0_0 = x10_0-xstar0_0;
        /* Introducing 14 common subexpressions used in 15 expressions */
        /* Of the common subexpressions 14 are reals, 0 are integers, and 0
           are booleans. */

        { double helpvarF[14];
        DYNX(helpvarF,0) = xstar0_0-x00_0;
        DYNX(helpvarF,1) = sqr(DYNX(helpvarF,0));
        DYNX(helpvarF,2) = y0d0_0+y1d0_0-2*Delta00_0;
        DYNX(helpvarF,3) = xstarx_0der-x0x_0der;
        DYNX(helpvarF,4) = (y0dx_0der+y1dx_0der-2*Delta0x_0der)*DYNX(helpvarF,1)
          +2.0*DYNX(helpvarF,2)*DYNX(helpvarF,0)*DYNX(helpvarF,3);
        DYNX(helpvarF,5) = sqr(h00_0);
        DYNX(helpvarF,6) = divmacro(1.0,"1.0",DYNX(helpvarF,5),"h0^2");
        DYNX(helpvarF,7) = DYNX(helpvarF,2)*DYNX(helpvarF,1)*h00_0*h0x_0der;
        DYNX(helpvarF,8) = sqr(DYNX(helpvarF,5));
        DYNX(helpvarF,9) = divmacro(1.0,"1.0",DYNX(helpvarF,8),"(h0^2)^2");
        DYNX(helpvarF,10) = (-2)*y0d0_0-y1d0_0+3*Delta00_0;
        DYNX(helpvarF,11) = ((-2)*y0dx_0der-y1dx_0der+3*Delta0x_0der)*
          DYNX(helpvarF,0)+DYNX(helpvarF,10)*DYNX(helpvarF,3);
        DYNX(helpvarF,12) = divmacro(1.0,"1.0",h00_0,"h0");
        DYNX(helpvarF,13) = DYNX(helpvarF,10)*DYNX(helpvarF,0)*h0x_0der;
        omegax_0der = DYNX(helpvarF,6)*3.0*DYNX(helpvarF,4)-DYNX(helpvarF,9)*6.0
          *DYNX(helpvarF,7)+DYNX(helpvarF,12)*2.0*DYNX(helpvarF,11)-
          DYNX(helpvarF,6)*2.0*DYNX(helpvarF,13)+y0dx_0der;
        }
        omega0_0 = divmacro(3.0*(y0d0_0+y1d0_0-2*Delta00_0)*sqr(xstar0_0-x00_0),
          "3.0*((y0d+y1d-2*Delta0)*(xstar-x0)^2)",sqr(h00_0),"h0^2")+divmacro(
          2.0*((-2)*y0d0_0-y1d0_0+3*Delta00_0)*(xstar0_0-x00_0),"2.0*(((-2)*y0d-y1d+3*Delta0)*(xstar-x0))",
          h00_0,"h0")+y0d0_0;
        aux01x_0der = 0.25*(IF Delta00_0 > 0 THEN 1 ELSE IF Delta00_0 < 0 THEN -1
           ELSE 0)*(IF fabs(omega0_0) < fabs(Delta00_0) THEN omegax_0der*(IF 
          omega0_0 > 0 THEN 1 ELSE -1) ELSE Delta0x_0der*(IF Delta00_0 > 0 THEN 1
           ELSE -1));
        aux010_0 = 0.25*(IF Delta00_0 > 0 THEN 1 ELSE IF Delta00_0 < 0 THEN -1
           ELSE 0)*RealBmin(fabs(omega0_0), fabs(Delta00_0));
        if (fabs(y0d0_0-y1d0_0) <= 1E-013) {
          aux02x_0der = y0dx_0der;
          aux020_0 = y0d0_0;
          if (y10_0 > y00_0+y0d0_0*(x10_0-x00_0)) {
            useSingleCubicPolynomial0_0 = true;
          }
        }
        else if (fabs(y1d0_0+y0d0_0-2*Delta00_0) < 1E-013) {
          aux02x_0der = 1E+060*(6.0*(Delta0x_0der*(y1d0_0+y0d0_0-1.5*Delta00_0)+
            Delta00_0*(y1dx_0der+y0dx_0der-1.5*Delta0x_0der))-(y1dx_0der*y0d0_0+
            y1d0_0*y0dx_0der)-2.0*y1d0_0*y1dx_0der-2.0*y0d0_0*y0dx_0der)*(IF 
            y1d0_0+y0d0_0-2*Delta00_0 >= 0 THEN 1 ELSE -1);
          aux020_0 = 1E+060*(6.0*Delta00_0*(y1d0_0+y0d0_0-1.5*Delta00_0)-y1d0_0*
            y0d0_0-sqr(y1d0_0)-sqr(y0d0_0))*(IF y1d0_0+y0d0_0-2*Delta00_0 >= 0
             THEN 1 ELSE -1);
        }
        else{
          /* Introducing 13 common subexpressions used in 8 expressions */
          /* Of the common subexpressions 13 are reals, 0 are integers, and 0
             are booleans. */

          { double helpvarF[13];
          DYNX(helpvarF,0) = y1d0_0+y0d0_0;
          DYNX(helpvarF,1) = DYNX(helpvarF,0)-1.5*Delta00_0;
          DYNX(helpvarF,2) = y1dx_0der+y0dx_0der;
          DYNX(helpvarF,3) = 6.0*(Delta0x_0der*DYNX(helpvarF,1)+Delta00_0*(
            DYNX(helpvarF,2)-1.5*Delta0x_0der));
          DYNX(helpvarF,4) = y1dx_0der*y0d0_0+y1d0_0*y0dx_0der;
          DYNX(helpvarF,5) = y1d0_0*y1dx_0der;
          DYNX(helpvarF,6) = 3*(DYNX(helpvarF,0)-2*Delta00_0);
          DYNX(helpvarF,7) = divmacro(1.0,"1.0",DYNX(helpvarF,6),
            "3*(y1d+y0d-2*Delta0)");
          DYNX(helpvarF,8) = 6.0*Delta00_0*DYNX(helpvarF,1)-y1d0_0*y0d0_0-sqr(
            y1d0_0);
          DYNX(helpvarF,9) = sqr(y0d0_0);
          DYNX(helpvarF,10) = 2*Delta0x_0der;
          DYNX(helpvarF,11) = sqr(DYNX(helpvarF,6));
          DYNX(helpvarF,12) = divmacro(1.0,"1.0",DYNX(helpvarF,11),
            "(3*(y1d+y0d-2*Delta0))^2");
          aux02x_0der = DYNX(helpvarF,7)*(DYNX(helpvarF,3)-DYNX(helpvarF,4)-2.0*
            DYNX(helpvarF,5)-2.0*y0d0_0*y0dx_0der)-DYNX(helpvarF,12)*3.0*(
            DYNX(helpvarF,8)-DYNX(helpvarF,9))*(DYNX(helpvarF,2)-
            DYNX(helpvarF,10));
          }
          aux020_0 = divmacro(6.0*Delta00_0*(y1d0_0+y0d0_0-1.5*Delta00_0)-y1d0_0
            *y0d0_0-sqr(y1d0_0)-sqr(y0d0_0),"6.0*(Delta0*(y1d+y0d-1.5*Delta0))-y1d*y0d-y1d^2-y0d^2",3
            *(y1d0_0+y0d0_0-2*Delta00_0),"3*(y1d+y0d-2*Delta0)");
        }
        if ((mu0_0 > 0 AND eta0_0 < h00_0 AND Delta00_0*omega0_0 <= 0 OR fabs(
          aux010_0) < fabs(aux020_0) AND aux020_0*Delta00_0 >= 0 OR fabs(
          aux010_0) < fabs(0.1*Delta00_0)) AND  NOT useSingleCubicPolynomial0_0)
           {
          cx_0der = aux01x_0der;
          c0_0 = aux010_0;
          if (fabs(c0_0) < fabs(aux020_0) AND aux020_0*Delta00_0 >= 0) {
            cx_0der = aux02x_0der;
            c0_0 = aux020_0;
          }
          if (fabs(c0_0) < fabs(0.1*Delta00_0)) {
            cx_0der = 0.1*Delta0x_0der;
            c0_0 = 0.1*Delta00_0;
          }
          theta0x_0der = divmacro(y0dx_0der*mu0_0+y0d0_0*mux_0der+y1dx_0der*
            eta0_0+y1d0_0*etax_0der,"y0d_der*mu+y0d*mu_der+y1d_der*eta+y1d*eta_der",
            h00_0,"h0")-divmacro((y0d0_0*mu0_0+y1d0_0*eta0_0)*h0x_0der,
            "(y0d*mu+y1d*eta)*h0_der",sqr(h00_0),"h0^2");
          theta00_0 = divmacro(y0d0_0*mu0_0+y1d0_0*eta0_0,"y0d*mu+y1d*eta",h00_0,
            "h0");
          if (fabs(theta00_0-c0_0) < 1E-006) {
            cx_0der = 0.999999*theta0x_0der;
            c0_0 = 0.999999*theta00_0;
          }
          rhox_0der = divmacro(3*(Delta0x_0der-cx_0der),"3*(Delta0_der-c_der)",
            theta00_0-c0_0,"theta0-c")-divmacro(3.0*(Delta00_0-c0_0)*(
            theta0x_0der-cx_0der),"3.0*((Delta0-c)*(theta0_der-c_der))",sqr(
            theta00_0-c0_0),"(theta0-c)^2");
          rho0_0 = divmacro(3*(Delta00_0-c0_0),"3*(Delta0-c)",theta00_0-c0_0,
            "theta0-c");
          mux_0tildex_0der = rhox_0der*mu0_0+rho0_0*mux_0der;
          mux_0tilde = rho0_0*mu0_0;
          etax_0tildex_0der = rhox_0der*eta0_0+rho0_0*etax_0der;
          etax_0tilde = rho0_0*eta0_0;
          xi1x_0der = x0x_0der+mux_0tildex_0der;
          xi10_0 = x00_0+mux_0tilde;
          xi2x_0der = x1x_0der-etax_0tildex_0der;
          xi20_0 = x10_0-etax_0tilde;
          a1x_0der = divmacro(y0dx_0der-cx_0der,"y0d_der-c_der",RealBmax(sqr(
            mux_0tilde), 1E-013),"max(mu_tilde^2, 1E-013)")-divmacro((y0d0_0-
            c0_0)*(IF sqr(mux_0tilde) > 1E-013 THEN 2.0*mux_0tilde*
            mux_0tildex_0der ELSE 0.0),"(y0d-c)*(if noEvent(mu_tilde^2 > 1E-013) then 2.0*(mu_tilde*mu_tilde_der) else 0.0)",
            sqr(RealBmax(sqr(mux_0tilde), 1E-013)),"max(mu_tilde^2, 1E-013)^2");
          a10_0 = divmacro(y0d0_0-c0_0,"y0d-c",RealBmax(sqr(mux_0tilde), 1E-013),
            "max(mu_tilde^2, 1E-013)");
          a2x_0der = divmacro(y1dx_0der-cx_0der,"y1d_der-c_der",RealBmax(sqr(
            etax_0tilde), 1E-013),"max(eta_tilde^2, 1E-013)")-divmacro((y1d0_0-
            c0_0)*(IF sqr(etax_0tilde) > 1E-013 THEN 2.0*etax_0tilde*
            etax_0tildex_0der ELSE 0.0),"(y1d-c)*(if noEvent(eta_tilde^2 > 1E-013) then 2.0*(eta_tilde*eta_tilde_der) else 0.0)",
            sqr(RealBmax(sqr(etax_0tilde), 1E-013)),"max(eta_tilde^2, 1E-013)^2");
          a20_0 = divmacro(y1d0_0-c0_0,"y1d-c",RealBmax(sqr(etax_0tilde), 1E-013),
            "max(eta_tilde^2, 1E-013)");
          const12x_0der = y0x_0der-0.3333333333333333*(a1x_0der*powmacro2(x00_0-
            xi10_0,"x0-xi1",3,"3")+3.0*a10_0*sqr(x00_0-xi10_0)*(x0x_0der-
            xi1x_0der))-(cx_0der*x00_0+c0_0*x0x_0der);
          const120_0 = y00_0-0.3333333333333333*a10_0*powmacro2(x00_0-xi10_0,
            "x0-xi1",3,"3")-c0_0*x00_0;
          const3x_0der = y1x_0der-0.3333333333333333*(a2x_0der*powmacro2(x10_0-
            xi20_0,"x1-xi2",3,"3")+3.0*a20_0*sqr(x10_0-xi20_0)*(x1x_0der-
            xi2x_0der))-(cx_0der*x10_0+c0_0*x1x_0der);
          const30_0 = y10_0-0.3333333333333333*a20_0*powmacro2(x10_0-xi20_0,
            "x1-xi2",3,"3")-c0_0*x10_0;
          if (x0_0 < xi10_0) {
            yx_0der = 0.3333333333333333*(a1x_0der*powmacro2(x0_0-xi10_0,"x-xi1",3,
              "3")+3.0*a10_0*sqr(x0_0-xi10_0)*(xx_0der-xi1x_0der))+cx_0der*x0_0+
              c0_0*xx_0der+const12x_0der;
          }
          else if (x0_0 < xi20_0) {
            yx_0der = cx_0der*x0_0+c0_0*xx_0der+const12x_0der;
          }
          else{
            yx_0der = 0.3333333333333333*(a2x_0der*powmacro2(x0_0-xi20_0,"x-xi2",3,
              "3")+3.0*a20_0*sqr(x0_0-xi20_0)*(xx_0der-xi2x_0der))+cx_0der*x0_0+
              c0_0*xx_0der+const3x_0der;
          }
        }
        else{
          /* Introducing 14 common subexpressions used in 18 expressions */
          /* Of the common subexpressions 14 are reals, 0 are integers, and 0
             are booleans. */

          { double helpvarF[14];
          DYNX(helpvarF,0) = xx_0der-x0x_0der;
          DYNX(helpvarF,1) = x0_0-x00_0;
          DYNX(helpvarF,2) = y0d0_0+y1d0_0-2*Delta00_0;
          DYNX(helpvarF,3) = DYNX(helpvarF,1)*DYNX(helpvarF,2);
          DYNX(helpvarF,4) = divmacro(1.0,"1.0",h00_0,"h0");
          DYNX(helpvarF,5) = (-2)*y0d0_0-y1d0_0+3*Delta00_0+DYNX(helpvarF,4)*
            DYNX(helpvarF,3);
          DYNX(helpvarF,6) = DYNX(helpvarF,1)*DYNX(helpvarF,5);
          DYNX(helpvarF,7) = (-2)*y0dx_0der;
          DYNX(helpvarF,8) = DYNX(helpvarF,0)*DYNX(helpvarF,2)+DYNX(helpvarF,1)*
            (y0dx_0der+y1dx_0der-2*Delta0x_0der);
          DYNX(helpvarF,9) = DYNX(helpvarF,3)*h0x_0der;
          DYNX(helpvarF,10) = sqr(h00_0);
          DYNX(helpvarF,11) = divmacro(1.0,"1.0",DYNX(helpvarF,10),"h0^2");
          DYNX(helpvarF,12) = DYNX(helpvarF,4)*(DYNX(helpvarF,0)*
            DYNX(helpvarF,5)+DYNX(helpvarF,1)*(DYNX(helpvarF,7)-y1dx_0der+3*
            Delta0x_0der+DYNX(helpvarF,4)*DYNX(helpvarF,8)-DYNX(helpvarF,11)*
            DYNX(helpvarF,9)));
          DYNX(helpvarF,13) = DYNX(helpvarF,11)*DYNX(helpvarF,6)*h0x_0der;
          yx_0der = y0x_0der+DYNX(helpvarF,0)*(y0d0_0+DYNX(helpvarF,4)*
            DYNX(helpvarF,6))+DYNX(helpvarF,1)*(y0dx_0der+DYNX(helpvarF,12)-
            DYNX(helpvarF,13));
          }
          y0_0 = y00_0+(x0_0-x00_0)*(y0d0_0+divmacro((x0_0-x00_0)*((-2)*y0d0_0-
            y1d0_0+3*Delta00_0+divmacro((x0_0-x00_0)*(y0d0_0+y1d0_0-2*Delta00_0),
            "(x-x0)*(y0d+y1d-2*Delta0)",h00_0,"h0")),"(x-x0)*((-2)*y0d-y1d+3*Delta0+(x-x0)*(y0d+y1d-2*Delta0)/h0)",
            h00_0,"h0"));
          aux01x_0der = 0.5*(x0x_0der+x1x_0der);
          aux010_0 = 0.5*(x00_0+x10_0);
          /* Introducing 14 common subexpressions used in 15 expressions */
          /* Of the common subexpressions 14 are reals, 0 are integers, and 0
             are booleans. */

          { double helpvarF[14];
          DYNX(helpvarF,0) = aux010_0-x00_0;
          DYNX(helpvarF,1) = sqr(DYNX(helpvarF,0));
          DYNX(helpvarF,2) = y0d0_0+y1d0_0-2*Delta00_0;
          DYNX(helpvarF,3) = aux01x_0der-x0x_0der;
          DYNX(helpvarF,4) = (y0dx_0der+y1dx_0der-2*Delta0x_0der)*
            DYNX(helpvarF,1)+2.0*DYNX(helpvarF,2)*DYNX(helpvarF,0)*
            DYNX(helpvarF,3);
          DYNX(helpvarF,5) = sqr(h00_0);
          DYNX(helpvarF,6) = divmacro(1.0,"1.0",DYNX(helpvarF,5),"h0^2");
          DYNX(helpvarF,7) = DYNX(helpvarF,2)*DYNX(helpvarF,1)*h00_0*h0x_0der;
          DYNX(helpvarF,8) = sqr(DYNX(helpvarF,5));
          DYNX(helpvarF,9) = divmacro(1.0,"1.0",DYNX(helpvarF,8),"(h0^2)^2");
          DYNX(helpvarF,10) = (-2)*y0d0_0-y1d0_0+3*Delta00_0;
          DYNX(helpvarF,11) = ((-2)*y0dx_0der-y1dx_0der+3*Delta0x_0der)*
            DYNX(helpvarF,0)+DYNX(helpvarF,10)*DYNX(helpvarF,3);
          DYNX(helpvarF,12) = divmacro(1.0,"1.0",h00_0,"h0");
          DYNX(helpvarF,13) = DYNX(helpvarF,10)*DYNX(helpvarF,0)*h0x_0der;
          cx_0der = DYNX(helpvarF,6)*3.0*DYNX(helpvarF,4)-DYNX(helpvarF,9)*6.0*
            DYNX(helpvarF,7)+DYNX(helpvarF,12)*2.0*DYNX(helpvarF,11)-
            DYNX(helpvarF,6)*2.0*DYNX(helpvarF,13)+y0dx_0der;
          }
        }
      }
    /* Output section */
    SetStringMark(retSMark_);
    PopContext()
    {
      struct Modelica_Fluid_Utilities_regFun3__der_struct out_;
      out_.yx_0der_0member = yx_0der;
      out_.cx_0der_0member = cx_0der;
      return out_;
    }
  }}

/* Flattened Modelica model:

function interpolateInRegion2_Unique10
discrete input Real Re(unit = "1");
discrete input Real Re1(unit = "1");
discrete input Real Re2(unit = "1");
discrete input Real Delta;
discrete output Real lambda2;
protected 
discrete Real x1(start = log10(Re1));
discrete Real y1(start = log10(64*Re1));
discrete Real yd1(start = 1);
discrete Real aux1(start = 1.1217826467560994);
discrete Real aux2(start = Delta/3.7+5.74/Re2^0.9);
discrete Real aux3(start = log10(aux2));
discrete Real L2(start = 0.25*(Re2/aux3)^2);
discrete Real aux4(start = 2.51/sqrt(L2)+0.27*Delta);
discrete Real aux5(start = (-2.0)*(sqrt(L2)*log10(aux4)));
discrete Real x2(start = log10(Re2));
discrete Real y2(start = log10(L2));
discrete Real yd2(start = 2+4*aux1/(aux2*aux3*Re2^0.9));
discrete Real diff_x(start = x2-x1);
discrete Real m(start = (y2-y1)/diff_x);
discrete Real c2(start = (3*m-2*yd1-yd2)/diff_x);
discrete Real c3(start = (yd1+yd2-2*m)/(diff_x*diff_x));
discrete Real dx;
public 
algorithm 
dx := log10(Re/Re1);
lambda2 := 64*Re1*(Re/Re1)^(1+dx*(c2+dx*c3));
annotation(smoothOrder=1);
end interpolateInRegion2_Unique10;

  */
DYMOLA_STATIC double   interpolateInRegion2x_0Unique10(double  Re0_0, double  
  Re10_0, double  Re20_0, double  Delta0_0) {
  PushContext("interpolateInRegion2_Unique10")
  {
    /* Declare outputs and temporaries */
    double   lambda20_0;
    double   x10_0;
    double   y10_0;
    double   yd10_0;
    double   aux10_0;
    double   aux20_0;
    double   aux30_0;
    double   L20_0;
    double   aux40_0;
    double   aux50_0;
    double   x20_0;
    double   y20_0;
    double   yd20_0;
    double   diffx_0x;
    double   m0_0;
    double   c20_0;
    double   c30_0;
    double   dx0_0;
    lambda20_0=0;
    x10_0 = log10Guarded(Re10_0,"Re1");
    y10_0 = log10Guarded(64*Re10_0,"64*Re1");
    yd10_0 = 1;
    aux10_0 = 1.1217826467560994;
    aux20_0 = Delta0_0/(double)(3.7)+divmacro(5.74,"5.74",powmacro(Re20_0,"Re2",
      0.9,"0.9"),"Re2^0.9");
    aux30_0 = log10Guarded(aux20_0,"aux2");
    L20_0 = 0.25*sqr(divmacro(Re20_0,"Re2",aux30_0,"aux3"));
    aux40_0 = divmacro(2.51,"2.51",sqrtGuarded(L20_0,"L2"),"sqrt(L2)")+0.27*
      Delta0_0;
    aux50_0 = (-2.0)*sqrtGuarded(L20_0,"L2")*log10Guarded(aux40_0,"aux4");
    x20_0 = log10Guarded(Re20_0,"Re2");
    y20_0 = log10Guarded(L20_0,"L2");
    yd20_0 = 2+divmacro(4*aux10_0,"4*aux1",aux20_0*aux30_0*powmacro(Re20_0,"Re2",
      0.9,"0.9"),"aux2*aux3*Re2^0.9");
    diffx_0x = x20_0-x10_0;
    m0_0 = divmacro(y20_0-y10_0,"y2-y1",diffx_0x,"diff_x");
    c20_0 = divmacro(3*m0_0-2*yd10_0-yd20_0,"3*m-2*yd1-yd2",diffx_0x,"diff_x");
    c30_0 = divmacro(yd10_0+yd20_0-2*m0_0,"yd1+yd2-2*m",diffx_0x*diffx_0x,
      "diff_x*diff_x");
    dx0_0=0;
    /* Start of real code */
      dx0_0 = log10Guarded(divmacro(Re0_0,"Re",Re10_0,"Re1"),"Re/Re1");
      lambda20_0 = 64*Re10_0*powmacro(divmacro(Re0_0,"Re",Re10_0,"Re1"),"Re/Re1",1
        +dx0_0*(c20_0+dx0_0*c30_0),"1+dx*(c2+dx*c3)");
    /* Output section */
    PopContext()
    return lambda20_0;
  }}

/* Flattened Modelica model:

function Modelica.Fluid.Pipes.BaseClasses.WallFriction.Detailed.Internal.m_flow_of_dp_fric.interpolateInRegion2_withDerivative:der
discrete input Real lambda2;
discrete input Real Re1;
discrete input Real Re2;
discrete input Real Delta;
discrete input Real dp_fric;
protected 
discrete Real Re;
discrete Real dRe_ddp;
discrete Real x1(start = log10(64*Re1));
discrete Real y1(start = log10(Re1));
discrete Real y1d(start = 1);
discrete Real aux2(start = 0.27027027027027023*Delta+5.74/Re2^0.9);
discrete Real aux3(start = log10(aux2));
discrete Real L2(start = 0.25*(Re2/aux3)^2);
discrete Real aux4(start = 2.51/sqrt(L2)+0.27*Delta);
discrete Real aux5(start = (-2.0)*(sqrt(L2)*log10(aux4)));
discrete Real x2(start = log10(L2));
discrete Real y2(start = log10(aux5));
discrete Real y2d(start = 0.5+1.0900791495771618/(aux5*aux4));
discrete Real x(start = log10(lambda2));
discrete Real y;
discrete Real dy_dx;
public 
discrete input Real lambda2_der;
discrete input Real Re1_der;
discrete input Real Re2_der;
discrete input Real Delta_der;
discrete input Real dp_fric_der;
discrete output Real Re_der;
discrete output Real dRe_ddp_der;
protected 
discrete Real x1_der(start = 64*Re1_der/(147.36544595161894*Re1));
discrete Real y1_der(start = Re1_der/(2.302585092994046*Re1));
discrete Real y1d_der(start = 0);
discrete Real aux2_der(start = 0.27027027027027023*Delta_der-5.166*(Re2^(-0.09999999999999998)*Re2_der)/(Re2^0.9)^2);
discrete Real aux3_der(start = aux2_der/(2.302585092994046*aux2));
discrete Real L2_der(start = 0.5*(Re2*(Re2_der/aux3-Re2*aux3_der/aux3^2))/aux3);
discrete Real aux4_der(start = 0.27*Delta_der-1.255*L2_der/sqrt(L2)/sqrt(L2)^2);
discrete Real aux5_der(start = (-2.0)*(0.5*(L2_der*log10(aux4))/sqrt(L2)+sqrt(L2)*aux4_der/(2.302585092994046*aux4)));
discrete Real x2_der(start = L2_der/(2.302585092994046*L2));
discrete Real y2_der(start = aux5_der/(2.302585092994046*aux5));
discrete Real y2d_der(start =  -1.0900791495771618*(aux5_der*aux4+aux5*aux4_der)/(aux5*aux4)^2);
discrete Real x_der(start = lambda2_der/(2.302585092994046*lambda2));
discrete Real y_der;
discrete Real dy_dx_der;
public 
algorithm 
(y_der, dy_dx_der)  := Modelica.Fluid.Utilities.cubicHermite_withDerivative:der(x, x1, x2, y1, y2, y1d, y2d, x_der, x1_der, x2_der, y1_der, y2_der, 0.0, y2d_der);
(y, dy_dx)  := Modelica.Fluid.Utilities.cubicHermite_withDerivative(x, x1, x2, y1, y2, y1d, y2d);
Re_der := 2.302585092994046*(10^y*y_der);
Re := 10^y;
dRe_ddp_der := (Re_der*dy_dx+Re*dy_dx_der)/abs(dp_fric)-Re*dy_dx*(dp_fric_der*noEvent((if dp_fric > 0 then 1 else -1)))/abs(dp_fric)^2;
annotation(smoothOrder=0);
end Modelica.Fluid.Pipes.BaseClasses.WallFriction.Detailed.Internal.m_flow_of_dp_fric.interpolateInRegion2_withDerivative:der;

  */
DYMOLA_STATIC struct Modelica_Fluid_Pipes_BaseClasses_WallFriction_Detailed_Internal_mx_0flowx_0ofx_0dpx_0fric_interpolateInRegion2x_0withDerivative__der_struct
   Modelica_Fluid_Pipes_BaseClasses_WallFriction_Detailed_Internal_mx_0flowx_0ofx_0dpx_0fric_interpolateInRegion2x_0withDerivative__der
  (double  lambda20_0, double  Re10_0, double  Re20_0, double  Delta0_0, double 
   dpx_0fric, double  lambda2x_0der, double  Re1x_0der, double  Re2x_0der, 
  double  Deltax_0der, double  dpx_0fricx_0der) {
  PushContext("Modelica.Fluid.Pipes.BaseClasses.WallFriction.Detailed.Internal.m_flow_of_dp_fric.interpolateInRegion2_withDerivative:der")
  {
    /* Declare outputs and temporaries */
    double   Re0_0;
    double   dRex_0ddp;
    double   x10_0;
    double   y10_0;
    double   y1d0_0;
    double   aux20_0;
    double   aux30_0;
    double   L20_0;
    double   aux40_0;
    double   aux50_0;
    double   x20_0;
    double   y20_0;
    double   y2d0_0;
    double   x0_0;
    double   y0_0;
    double   dyx_0dx;
    double   Rex_0der;
    double   dRex_0ddpx_0der;
    double   x1x_0der;
    double   y1x_0der;
    double   y1dx_0der;
    double   aux2x_0der;
    double   aux3x_0der;
    double   L2x_0der;
    double   aux4x_0der;
    double   aux5x_0der;
    double   x2x_0der;
    double   y2x_0der;
    double   y2dx_0der;
    double   xx_0der;
    double   yx_0der;
    double   dyx_0dxx_0der;
    Re0_0=0;
    dRex_0ddp=0;
    x10_0 = log10Guarded(64*Re10_0,"64*Re1");
    y10_0 = log10Guarded(Re10_0,"Re1");
    y1d0_0 = 1;
    aux20_0 = 0.27027027027027023*Delta0_0+divmacro(5.74,"5.74",powmacro(Re20_0,
      "Re2",0.9,"0.9"),"Re2^0.9");
    aux30_0 = log10Guarded(aux20_0,"aux2");
    L20_0 = 0.25*sqr(divmacro(Re20_0,"Re2",aux30_0,"aux3"));
    aux40_0 = divmacro(2.51,"2.51",sqrtGuarded(L20_0,"L2"),"sqrt(L2)")+0.27*
      Delta0_0;
    aux50_0 = (-2.0)*sqrtGuarded(L20_0,"L2")*log10Guarded(aux40_0,"aux4");
    x20_0 = log10Guarded(L20_0,"L2");
    y20_0 = log10Guarded(aux50_0,"aux5");
    y2d0_0 = 0.5+divmacro(1.0900791495771618,"1.0900791495771618",aux50_0*
      aux40_0,"aux5*aux4");
    x0_0 = log10Guarded(lambda20_0,"lambda2");
    y0_0=0;
    dyx_0dx=0;
    Rex_0der=0;
    dRex_0ddpx_0der=0;
    x1x_0der = divmacro(64*Re1x_0der,"64*Re1_der",147.36544595161894*Re10_0,
      "147.36544595161894*Re1");
    y1x_0der = divmacro(Re1x_0der,"Re1_der",2.302585092994046*Re10_0,
      "2.302585092994046*Re1");
    y1dx_0der = 0;
    aux2x_0der = 0.27027027027027023*Deltax_0der-divmacro(5.166*powmacro(Re20_0,
      "Re2",-0.09999999999999998,"-0.09999999999999998")*Re2x_0der,
      "5.166*(Re2^(-0.09999999999999998)*Re2_der)",sqr(powmacro(Re20_0,"Re2",0.9,
      "0.9")),"(Re2^0.9)^2");
    aux3x_0der = divmacro(aux2x_0der,"aux2_der",2.302585092994046*aux20_0,
      "2.302585092994046*aux2");
    L2x_0der = divmacro(0.5*Re20_0*(divmacro(Re2x_0der,"Re2_der",aux30_0,"aux3")
      -divmacro(Re20_0*aux3x_0der,"Re2*aux3_der",sqr(aux30_0),"aux3^2")),
      "0.5*(Re2*(Re2_der/aux3-Re2*aux3_der/aux3^2))",aux30_0,"aux3");
    aux4x_0der = 0.27*Deltax_0der-divmacro(divmacro(1.255*L2x_0der,
      "1.255*L2_der",sqrtGuarded(L20_0,"L2"),"sqrt(L2)"),"1.255*L2_der/sqrt(L2)",
      sqr(sqrtGuarded(L20_0,"L2")),"sqrt(L2)^2");
    aux5x_0der = (-2.0)*(divmacro(0.5*L2x_0der*log10Guarded(aux40_0,"aux4"),
      "0.5*(L2_der*log10(aux4))",sqrtGuarded(L20_0,"L2"),"sqrt(L2)")+divmacro(
      sqrtGuarded(L20_0,"L2")*aux4x_0der,"sqrt(L2)*aux4_der",2.302585092994046*
      aux40_0,"2.302585092994046*aux4"));
    x2x_0der = divmacro(L2x_0der,"L2_der",2.302585092994046*L20_0,
      "2.302585092994046*L2");
    y2x_0der = divmacro(aux5x_0der,"aux5_der",2.302585092994046*aux50_0,
      "2.302585092994046*aux5");
    y2dx_0der =  -divmacro(1.0900791495771618*(aux5x_0der*aux40_0+aux50_0*
      aux4x_0der),"1.0900791495771618*(aux5_der*aux4+aux5*aux4_der)",sqr(aux50_0
      *aux40_0),"(aux5*aux4)^2");
    xx_0der = divmacro(lambda2x_0der,"lambda2_der",2.302585092994046*lambda20_0,
      "2.302585092994046*lambda2");
    yx_0der=0;
    dyx_0dxx_0der=0;
    /* Start of real code */
      {
        struct Modelica_Fluid_Utilities_cubicHermitex_0withDerivative__der_struct
           dummy_mult_=Modelica_Fluid_Utilities_cubicHermitex_0withDerivative__der
          (x0_0, x10_0, x20_0, y10_0, y20_0, y1d0_0, y2d0_0, xx_0der, x1x_0der, 
          x2x_0der, y1x_0der, y2x_0der, 0.0, y2dx_0der);
        yx_0der = dummy_mult_.yx_0der_0member;
        dyx_0dxx_0der = dummy_mult_.dyx_0dxx_0der_0member;
      }
      {
        struct Modelica_Fluid_Utilities_cubicHermitex_0withDerivative_struct
           dummy_mult_=Modelica_Fluid_Utilities_cubicHermitex_0withDerivative(
          x0_0, x10_0, x20_0, y10_0, y20_0, y1d0_0, y2d0_0);
        y0_0 = dummy_mult_.y0_0_0member;
        dyx_0dx = dummy_mult_.dyx_0dx_0member;
      }
      Rex_0der = 2.302585092994046*powmacro(10,"10",y0_0,"y")*yx_0der;
      Re0_0 = powmacro(10,"10",y0_0,"y");
      dRex_0ddpx_0der = divmacro(Rex_0der*dyx_0dx+Re0_0*dyx_0dxx_0der,
        "Re_der*dy_dx+Re*dy_dx_der",fabs(dpx_0fric),"abs(dp_fric)")-divmacro(
        Re0_0*dyx_0dx*dpx_0fricx_0der*(IF dpx_0fric > 0 THEN 1 ELSE -1),
        "Re*dy_dx*(dp_fric_der*noEvent((if dp_fric > 0 then 1 else -1)))",sqr(
        fabs(dpx_0fric)),"abs(dp_fric)^2");
    /* Output section */
    PopContext()
    {
      struct Modelica_Fluid_Pipes_BaseClasses_WallFriction_Detailed_Internal_mx_0flowx_0ofx_0dpx_0fric_interpolateInRegion2x_0withDerivative__der_struct out_;
      out_.Rex_0der_0member = Rex_0der;
      out_.dRex_0ddpx_0der_0member = dRex_0ddpx_0der;
      return out_;
    }
  }}

/* Flattened Modelica model:

function Modelica.Fluid.Utilities.cubicHermite_withDerivative:der
discrete input Real x;
discrete input Real x1;
discrete input Real x2;
discrete input Real y1;
discrete input Real y2;
discrete input Real y1d;
discrete input Real y2d;
protected 
discrete Real y;
discrete Real dy_dx;
discrete Real h;
discrete Real t;
discrete Real h00;
discrete Real h10;
discrete Real h01;
discrete Real h11;
discrete Real h00d;
discrete Real h10d;
discrete Real h01d;
discrete Real h11d;
discrete Real aux3;
discrete Real aux2;
public 
discrete input Real x_der;
discrete input Real x1_der;
discrete input Real x2_der;
discrete input Real y1_der;
discrete input Real y2_der;
discrete input Real y1d_der;
discrete input Real y2d_der;
discrete output Real y_der;
discrete output Real dy_dx_der;
protected 
discrete Real h_der;
discrete Real t_der;
discrete Real h00_der;
discrete Real h10_der;
discrete Real h01_der;
discrete Real h11_der;
discrete Real h00d_der;
discrete Real h10d_der;
discrete Real h01d_der;
discrete Real h11d_der;
discrete Real aux3_der;
discrete Real aux2_der;
public 
algorithm 
h_der := x2_der-x1_der;
h := x2-x1;
if (abs(h) > 0) then 
t_der := (x_der-x1_der)/h-(x-x1)*h_der/h^2;
t := (x-x1)/h;
aux3_der := 3.0*(t^2*t_der);
aux3 := t^3;
aux2_der := 2.0*(t*t_der);
aux2 := t^2;
h00_der := 2*aux3_der-3*aux2_der;
h00 := 1+2*aux3-3*aux2;
h10_der := aux3_der-2*aux2_der+t_der;
h10 := aux3-2*aux2+t;
h01_der := 3*aux2_der-2*aux3_der;
h01 := 3*aux2-2*aux3;
h11_der := aux3_der-aux2_der;
h11 := aux3-aux2;
h00d_der := 6*(aux2_der-t_der);
h00d := 6*(aux2-t);
h10d_der := 3*aux2_der-4*t_der;
h10d := 1+3*aux2-4*t;
h01d_der := 6*(t_der-aux2_der);
h01d := 6*(t-aux2);
h11d_der := 3*aux2_der-2*t_der;
h11d := 3*aux2-2*t;
y_der := y1_der*h00+y1*h00_der+(h_der*y1d+h*y1d_der)*h10+h*y1d*h10_der+y2_der*h01+y2*h01_der+(h_der*y2d+h*y2d_der)*h11+h*y2d*h11_der;
y := y1*h00+h*y1d*h10+y2*h01+h*y2d*h11;
dy_dx_der := (y1_der*h00d+y1*h00d_der)/h-y1*h00d*h_der/h^2+y1d_der*h10d+y1d*h10d_der+(y2_der*h01d+y2*h01d_der)/h-y2*h01d*h_der/h^2+y2d_der*h11d+y2d*h11d_der;
else
y_der := 0.5*(y1_der+y2_der);
y := 0.5*(y1+y2);
dy_dx_der := 0.0;
end if;
annotation(smoothOrder=2);
end Modelica.Fluid.Utilities.cubicHermite_withDerivative:der;

  */
DYMOLA_STATIC struct Modelica_Fluid_Utilities_cubicHermitex_0withDerivative__der_struct
   Modelica_Fluid_Utilities_cubicHermitex_0withDerivative__der(double  x0_0, 
  double  x10_0, double  x20_0, double  y10_0, double  y20_0, double  y1d0_0, 
  double  y2d0_0, double  xx_0der, double  x1x_0der, double  x2x_0der, double  
  y1x_0der, double  y2x_0der, double  y1dx_0der, double  y2dx_0der) {
  PushContext("Modelica.Fluid.Utilities.cubicHermite_withDerivative:der")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    double   dyx_0dx;
    double   h0_0;
    double   t0_0;
    double   h000_0;
    double   h100_0;
    double   h010_0;
    double   h110_0;
    double   h00d0_0;
    double   h10d0_0;
    double   h01d0_0;
    double   h11d0_0;
    double   aux30_0;
    double   aux20_0;
    double   yx_0der;
    double   dyx_0dxx_0der;
    double   hx_0der;
    double   tx_0der;
    double   h00x_0der;
    double   h10x_0der;
    double   h01x_0der;
    double   h11x_0der;
    double   h00dx_0der;
    double   h10dx_0der;
    double   h01dx_0der;
    double   h11dx_0der;
    double   aux3x_0der;
    double   aux2x_0der;
    y0_0=0;
    dyx_0dx=0;
    h0_0=0;
    t0_0=0;
    h000_0=0;
    h100_0=0;
    h010_0=0;
    h110_0=0;
    h00d0_0=0;
    h10d0_0=0;
    h01d0_0=0;
    h11d0_0=0;
    aux30_0=0;
    aux20_0=0;
    yx_0der=0;
    dyx_0dxx_0der=0;
    hx_0der=0;
    tx_0der=0;
    h00x_0der=0;
    h10x_0der=0;
    h01x_0der=0;
    h11x_0der=0;
    h00dx_0der=0;
    h10dx_0der=0;
    h01dx_0der=0;
    h11dx_0der=0;
    aux3x_0der=0;
    aux2x_0der=0;
    /* Start of real code */
      hx_0der = x2x_0der-x1x_0der;
      h0_0 = x20_0-x10_0;
      if (fabs(h0_0) > 0) {
        tx_0der = divmacro(xx_0der-x1x_0der,"x_der-x1_der",h0_0,"h")-divmacro((
          x0_0-x10_0)*hx_0der,"(x-x1)*h_der",sqr(h0_0),"h^2");
        t0_0 = divmacro(x0_0-x10_0,"x-x1",h0_0,"h");
        aux3x_0der = 3.0*sqr(t0_0)*tx_0der;
        aux30_0 = powmacro2(t0_0,"t",3,"3");
        aux2x_0der = 2.0*t0_0*tx_0der;
        aux20_0 = sqr(t0_0);
        h00x_0der = 2*aux3x_0der-3*aux2x_0der;
        h000_0 = 1+2*aux30_0-3*aux20_0;
        h10x_0der = aux3x_0der-2*aux2x_0der+tx_0der;
        h100_0 = aux30_0-2*aux20_0+t0_0;
        h01x_0der = 3*aux2x_0der-2*aux3x_0der;
        h010_0 = 3*aux20_0-2*aux30_0;
        h11x_0der = aux3x_0der-aux2x_0der;
        h110_0 = aux30_0-aux20_0;
        h00dx_0der = 6*(aux2x_0der-tx_0der);
        h00d0_0 = 6*(aux20_0-t0_0);
        h10dx_0der = 3*aux2x_0der-4*tx_0der;
        h10d0_0 = 1+3*aux20_0-4*t0_0;
        h01dx_0der = 6*(tx_0der-aux2x_0der);
        h01d0_0 = 6*(t0_0-aux20_0);
        h11dx_0der = 3*aux2x_0der-2*tx_0der;
        h11d0_0 = 3*aux20_0-2*t0_0;
        yx_0der = y1x_0der*h000_0+y10_0*h00x_0der+(hx_0der*y1d0_0+h0_0*y1dx_0der)
          *h100_0+h0_0*y1d0_0*h10x_0der+y2x_0der*h010_0+y20_0*h01x_0der+(hx_0der
          *y2d0_0+h0_0*y2dx_0der)*h110_0+h0_0*y2d0_0*h11x_0der;
        y0_0 = y10_0*h000_0+h0_0*y1d0_0*h100_0+y20_0*h010_0+h0_0*y2d0_0*h110_0;
        dyx_0dxx_0der = divmacro(y1x_0der*h00d0_0+y10_0*h00dx_0der,
          "y1_der*h00d+y1*h00d_der",h0_0,"h")-divmacro(y10_0*h00d0_0*hx_0der,
          "y1*h00d*h_der",sqr(h0_0),"h^2")+y1dx_0der*h10d0_0+y1d0_0*h10dx_0der+
          divmacro(y2x_0der*h01d0_0+y20_0*h01dx_0der,"y2_der*h01d+y2*h01d_der",
          h0_0,"h")-divmacro(y20_0*h01d0_0*hx_0der,"y2*h01d*h_der",sqr(h0_0),
          "h^2")+y2dx_0der*h11d0_0+y2d0_0*h11dx_0der;
      }
      else{
        yx_0der = 0.5*(y1x_0der+y2x_0der);
        y0_0 = 0.5*(y10_0+y20_0);
        dyx_0dxx_0der = 0.0;
      }
    /* Output section */
    PopContext()
    {
      struct Modelica_Fluid_Utilities_cubicHermitex_0withDerivative__der_struct out_;
      out_.yx_0der_0member = yx_0der;
      out_.dyx_0dxx_0der_0member = dyx_0dxx_0der;
      return out_;
    }
  }}
/* DSblock C-code: */

BreakSectionFunctionDef(1)
BreakSectionFunctionDef(0)
  BreakSectionDef(2);
BreakSectionFunctionDef(3)
  BreakSectionDef(4);
#define NX_    6
#define NX2_   5
#define NU_    0
#define NY_    0
#define NW_    439
#define NP_    112
#define NPS_   0
#define ND_   0
#define NXP_   0
#define NInitial_   2
#define MAXAuxStr_   2
#define MAXAuxStrLen_   500
#define NHash1_ 1061035035
#define NHash2_ -86362039
#define NHash3_ 0
#define NI_    0
#define NRelF_ 4
#define NRel_  4
#define NTim_  0
#define NSamp_ 0
#define NCons_ 0
#define NA_    172
#define SizePre_ 0
#define SizeEq_ 13
#define SizeDelay_ 0
#define QNLmax_ 3
#define MAXAux 14
#define NrDymolaTimers_ 0
#define NWhen_ 0
#define NCheckIf_ 0
#define NGlobalHelp_ 286
#define NGlobalHelpI_ 87
#ifndef NExternalObject_
#define NExternalObject_ 1
#endif
#include <moutil.c>
DYMOLA_STATIC unsigned int FMIClockValueReferences_[1]={0
};
DYMOLA_STATIC unsigned int FMIClockFirstValueReferences_[1]={0
};
PreNonAliasDef(0)
PreNonAliasDef(1)
PreNonAliasDef(2)
PreNonAliasDef(3)
PreNonAliasDef(4)
PreNonAliasDef(5)
#if !defined(DYM2CCUR)
 DYMOLA_STATIC const char*modelName="AixLib.Building.Benchmark.Test.TestTBA";
#endif
DYMOLA_STATIC const char*usedLibraries[]={0};
DYMOLA_STATIC const char*dllLibraryPath[]={0};
DYMOLA_STATIC const char*default_dymosim_license_filename=
 "c:/programdata/dassaultsystemes/dymola/dymola.lic";
#define QJacobianCGDef_ 1
DYMOLA_STATIC int QJacobianCG_[13]={5 , 2 , 1 , 2 , 1 , 3 , 1 , 4 , 1 , 5 , 1 , 6
   , 0};
DYMOLA_STATIC int QJacobianGC_[31]={
1 , 2 , 2 , 0 , 1 , 0 , 0 , 3 , 3 , 3 , 0 , 3 , 0 , 0 , 4 , 4 , 4 , 4 , 5 , 0 , 0
   , 5 , 5 , 0 , 0 , 0 , 6 , 6 , 0 , 6 , 0};
DYMOLA_STATIC double QJacobianCD_[7]={0  , 44 , 55 , 60 , 63 , 64 , 63};
#include <dsblock1.c>

/* Define variable names. */

#define Sections_

TranslatedEquations

InitialSection
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,12) = true;
DYNX(W_,17) = 4;
DYNX(W_,23) = false;
DYNX(W_,24) = 4;
DYNX(W_,27) = 1;
DYNX(W_,28) = false;
DYNX(W_,29) = false;
DYNX(W_,30) = false;
DYNX(W_,32) = true;
DYNX(W_,36) = 4;
DYNX(W_,55) = true;
DYNX(W_,86) = true;
DYNX(W_,96) = 2;
DYNX(W_,136) = 4;
DYNX(W_,138) = 2;
DYNX(W_,139) = 1;
DYNX(W_,140) = false;
DYNX(W_,141) = 1;
DYNX(W_,142) = 1;
DYNX(W_,149) = 2;
DYNX(W_,153) = true;
DYNX(W_,154) = 4;
DYNX(W_,175) = false;
DYNX(W_,195) = true;
DYNX(W_,196) = 2;
DYNX(W_,216) = true;
DYNX(W_,219) = true;
DYNX(W_,220) = true;
DYNX(W_,226) = 1.0;
DYNX(W_,269) = 1;
DYNX(W_,280) = false;
DYNX(W_,286) = 3;
DYNX(W_,287) = false;
DYNX(W_,288) = true;
DYNX(W_,289) = false;
DYNX(W_,290) = false;
DYNX(W_,299) = 1;
DYNX(W_,307) = false;
DYNX(W_,313) = 3;
DYNX(W_,314) = false;
DYNX(W_,315) = true;
DYNX(W_,316) = false;
DYNX(W_,317) = false;
DYNX(W_,324) = true;
DYNX(W_,336) = 2;
DYNX(W_,346) = true;
DYNX(W_,347) = 4;
DYNX(W_,367) = false;
DYNX(W_,381) = 1.0;
DYNX(W_,423) = true;
DYNX(W_,435) = true;
DYNX(W_,6) = 0;
DYNX(W_,11) = 293.15;
DYNX(W_,18) = 0;
DYNX(W_,25) = 10;
DYNX(W_,26) = 3;
DYNX(W_,95) = 0;
DYNX(W_,0) = true;
DYNX(W_,1) = 1;
DYNX(W_,2) = 1;
DYNX(W_,3) = 1;
DYNX(W_,4) = 1;
DYNX(W_,5) = 4;
DYNX(W_,9) = false;
DYNX(W_,13) = 1;
DYNX(W_,14) = 1;
DYNX(W_,15) = 1;
DYNX(W_,16) = 1;
DYNX(W_,20) = 293.15;
DYNX(W_,21) = false;
DYNX(W_,31) = 0;
DYNX(W_,33) = 3.0;
DYNX(W_,34) = 10.0;
DYNX(W_,35) = 0.0;
DYNX(W_,71) = 30.0;
DYNX(W_,62) = 30.0;
DYNX(W_,68) = 30.0;
DYNX(W_,87) = true;
DYNX(W_,88) = true;
DYNX(W_,89) = 174.0;
DYNX(W_,90) = true;
DYNX(W_,99) = 1;
DYNX(W_,100) = 1;
DYNX(W_,101) = 1;
DYNX(W_,102) = 1;
DYNX(W_,107) = true;
DYNX(W_,126) = 87.0;
DYNX(W_,127) = 87.0;
DYNX(W_,205) = 0.5;
DYNX(W_,134) = 0.0;
DYNX(W_,206) = 0.5;
DYNX(W_,135) = 0.0;
DYNX(W_,137) = 0.0;
DYNX(W_,143) = 1;
DYNX(W_,144) = 2;
DYNX(W_,145) = false;
DYNX(W_,148) = true;
DYNX(W_,155) = 0.0;
DYNX(W_,158) = 1;
DYNX(W_,164) = true;
DYNX(W_,165) = false;
DYNX(W_,174) = 4000;
DYNX(W_,176) = false;
DYNX(W_,177) = false;
DYNX(W_,184) = false;
DYNX(W_,185) = false;
DYNX(W_,199) = true;
DYNX(W_,200) = 0;
DYNX(W_,201) = 293.15;
DYNX(W_,230) = 2;
#endif
DYNSetAuxString(did_, "NoName", 0);
DYNSetAuxString(did_, "NoName", 1);
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,281) = true;
DYNX(W_,291) = 10000;
DYNX(W_,292) = 293.15;
DYNX(W_,293) = 1.0;
DYNX(W_,308) = true;
DYNX(W_,318) = 10000;
DYNX(W_,319) = 573.15;
DYNX(W_,320) = 1.0;
DYNX(W_,328) = true;
DYNX(W_,334) = 0.0;
DYNX(W_,335) = true;
DYNX(W_,348) = 0.0;
DYNX(W_,351) = 1;
DYNX(W_,356) = true;
DYNX(W_,357) = false;
DYNX(W_,366) = 4000;
DYNX(W_,368) = false;
DYNX(W_,369) = false;
DYNX(W_,375) = false;
DYNX(W_,376) = false;
DYNX(W_,424) = true;
DYNX(W_,436) = true;
DYNX(W_,54) = 1;
DYNX(W_,56) = 2;
DYNX(W_,60) = 1;
DYNX(W_,227) = 1;
DYNX(W_,234) = false;
DYNX(W_,265) = 1;
DYNX(W_,116) = 0.0;
DYNX(W_,117) = 0.0;
DYNX(W_,311) = 10000;
DYNX(W_,193) = 174.0;
DYNX(W_,194) = 0.0;
DYNX(W_,179) = 4000;
DYNX(W_,383) = 0;
DYNX(W_,217) = 10000;
DYNX(W_,370) = 4000;
DYNX(W_,379) = 0;
DYNX(W_,296) = 350;
DYNX(W_,218) = 321540.4000000001;
#endif
DYNX(Aux_,2) = 321540.4000000001;
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,75) = 250;
#endif
DYNX(Aux_,1) = 321540.4000000001;
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,146) = 350.0;
DYNX(W_,168) = 995.586;
DYNX(W_,171) = 0.001;
DYNX(W_,275) = 321540.4000000001;
DYNX(W_,276) = 0;
DYNX(W_,282) = 76.85000000000002;
DYNX(W_,283) = 0.1;
DYNX(W_,304) = 0;
DYNX(W_,310) = 0.1;
DYNX(W_,360) = 995.586;
DYNX(W_,363) = 0.001;
DYNX(W_,421) = 0;
DYNX(W_,433) = 0;
DYNX(W_,117) = 0.0;
DYNX(W_,116) = 0.0;
DYNX(W_,116) = 0.0;
DYNX(W_,117) = 0.0;
DYNX(W_,297) = 1.0;
DYNX(W_,323) = 1.0;
DYNX(W_,399) = 250.0;
DYNX(W_,63) = 2.5;
DYNX(W_,65) = 0.0;
DYNX(W_,70) = 250.0;
DYNX(W_,67) = 0.0;
DYNX(W_,66) = 0.0;
DYNX(W_,78) = 0.0;
DYNX(W_,77) = 0.0;
DYNX(W_,161) = 0.0;
DYNX(W_,151) = 0.0;
DYNX(W_,169) = 0.001;
DYNX(W_,170) = 0.001;
DYNX(W_,159) = 174.0;
DYNX(W_,178) = 174.0;
DYNX(W_,166) = 995.586;
DYNX(W_,167) = 995.586;
DYNX(W_,203) = 87.0;
DYNX(W_,204) = 87.0;
DYNX(W_,118) = 0.0;
DYNX(W_,119) = 0.0;
DYNX(W_,422) = 0.018015268;
DYNX(W_,418) = 1.0;
DYNX(W_,417) = 995.586;
DYNX(W_,434) = 0.018015268;
DYNX(W_,430) = 1.0;
DYNX(W_,429) = 995.586;
DYNX(W_,81) = 0.0;
DYNX(W_,382) = true;
DYNX(W_,294) = 350.0;
DYNX(W_,277) = 0.018015268;
DYNX(W_,273) = 350.0;
DYNX(W_,274) = 1.0;
DYNX(W_,272) = 995.586;
DYNX(W_,271) = 321540.4000000001;
DYNX(W_,270) = 10000.0;
DYNX(W_,279) = 350.0;
DYNX(W_,278) = 10000.0;
DYNX(W_,295) = 10000.0;
DYNX(W_,285) = 321540.4000000001;
DYNX(W_,284) = 10000.0;
DYNX(W_,305) = 0.018015268;
DYNX(W_,302) = 1.0;
DYNX(W_,301) = 995.586;
DYNX(W_,300) = 10000.0;
DYNX(W_,306) = 10000.0;
DYNX(W_,321) = 10000.0;
DYNX(W_,353) = 0.0;
DYNX(W_,361) = 0.001;
DYNX(W_,362) = 0.001;
DYNX(W_,358) = 995.586;
DYNX(W_,359) = 995.586;
DYNX(W_,338) = 10000.0;
DYNX(W_,326) = 10000.0;
DYNX(W_,268) = true;
DYNX(W_,215) = 250.0;
DYNX(W_,298) = 350.0;
DYNX(W_,214) = 250.0;
DYNX(W_,213) = 250.0;
DYNX(W_,380) = 83680.0;
DYNX(W_,384) = 83680.0;
DYNX(W_,211) = 0.0;
DYNX(W_,210) = 0.0;
#endif
if (!DymolaUserHomotopy) UpdateInitVars(time, X_, XD_, U_, DP_, IP_, LP_, F_, Y_, W_, QZ_, duser_, iuser_, cuser_, did_, 1);
BoundParameterSection
AssertModelica(DYNX(DP_,106) >= DYNX(DP_,109),"pipe.length >= pipe.height_ab", 
  "Parameter length must be greater or equal height_ab.");
DYNX(W_,7) = DYNX(DP_,0);
DYNX(W_,8) = DYNX(DP_,1);
DYNX(W_,10) = IF DYNX(W_,9) THEN 1 ELSE 100.0*DYNX(DP_,5);
DYNX(W_,19) = DYNX(DP_,6);
DYNX(W_,22) = IF DYNX(W_,21) THEN 1 ELSE 100.0*DYNX(DP_,10);
DYNX(W_,37) = DYNX(DP_,11);
DYNX(W_,38) = DYNX(DP_,12);
DYNX(W_,39) = DYNX(DP_,13);
DYNX(W_,40) = DYNX(DP_,14);
DYNX(W_,41) = DYNX(DP_,15);
DYNX(W_,42) = DYNX(DP_,16);
DYNX(W_,43) = DYNX(DP_,17);
DYNX(W_,44) = DYNX(DP_,18);
BreakSectionFunctionCallNew(0);
BreakSectionFunctionEnd()
BreakSectionFunctionStart(1);
DYNX(W_,45) = DYNX(DP_,19);
DYNX(W_,46) = DYNX(DP_,20);
DYNX(W_,47) = DYNX(DP_,21);
DYNX(W_,48) = DYNX(DP_,22);
DYNX(W_,49) = DYNX(DP_,23);
DYNX(W_,50) = DYNX(DP_,24);
DYNX(W_,51) = DYNX(DP_,25);
DYNX(W_,52) = DYNX(DP_,26);
DYNX(W_,53) = DYNX(DP_,27);
DYNX(W_,57) = DYNX(DP_,49);
DYNX(W_,61) = DYNX(W_,54);
DYNX(W_,69) = DYNX(W_,53);
DYNX(W_,91) = DYNX(DP_,47);
DYNX(W_,92) = 0.7853981633974483*DYNX(W_,91)*DYNX(W_,91);
DYNX(W_,93) = 3.141592653589793*DYNX(W_,91);
DYNX(W_,94) = DYNX(W_,92)*DYNX(W_,89)*DYNX(DP_,55);
DYNX(W_,103) = DYNX(W_,19);
DYNX(W_,104) = DYNX(W_,103);
DYNX(W_,105) = DYNX(W_,103);
DYNX(W_,106) = DYNX(W_,104);

 /* Linear system of equations to solve. */
/* Tag: initialization.linear[1] */
/* Introducing 1 common subexpressions used in 1 expressions */
/* Of the common subexpressions 1 are reals, 0 are integers, and 0
   are booleans. */
DYNX(DYNhelp,0) = IF DYNX(W_,107) THEN 0.0 ELSE 0.0002390057361376673;
DYNX(W_,108) = 288.15;
SolveScalarLinearParametric(1.0-DYNX(DYNhelp,0)*(IF DYNX(W_,107) THEN 4184.0
   ELSE 0.0),"1.0-(if activeWall.pipe.use_T_start then 0.0 else 0.0002390057361376673)*(if activeWall.pipe.use_T_start then 4184.0 else 0.0)",
   (IF DYNX(W_,107) THEN DYNX(W_,20) ELSE 273.15)+DYNX(DYNhelp,0)*(IF 
  DYNX(W_,107) THEN -1142859.5999999999 ELSE 83680.0),"(if activeWall.pipe.use_T_start then activeWall.system.T_start else 273.15)+(if activeWall.pipe.use_T_start then 0.0 else 0.0002390057361376673)*(if activeWall.pipe.use_T_start then -1142859.5999999999 else 83680.0)",
   DYNX(W_,108),"activeWall.pipe.T_start");
DYNX(W_,109) = IF DYNX(W_,107) THEN 4184*(DYNX(W_,108)-273.15) ELSE 83680.0;
 /* End of Equation Block */ 

DYNX(W_,128) = DYNX(W_,92);
DYNX(W_,129) = DYNX(W_,92);
DYNX(W_,130) = divmacro(4*DYNX(W_,92),"4*activeWall.pipe.crossArea",DYNX(W_,93),
  "activeWall.pipe.perimeter");
DYNX(W_,131) = divmacro(4*DYNX(W_,92),"4*activeWall.pipe.crossArea",DYNX(W_,93),
  "activeWall.pipe.perimeter");
DYNX(W_,132) = DYNX(DP_,56);
DYNX(W_,133) = DYNX(DP_,56);
DYNX(W_,150) = DYNX(DP_,55);
DYNX(W_,152) = DYNX(DP_,7);
DYNX(W_,156) = DYNX(W_,103);
DYNX(W_,157) = DYNX(W_,104);

 /* Linear system of equations to solve. */
/* Tag: initialization.linear[2] */
/* Introducing 1 common subexpressions used in 1 expressions */
/* Of the common subexpressions 1 are reals, 0 are integers, and 0
   are booleans. */
DYNX(DYNhelp,1) = IF DYNX(W_,21) THEN 0.0 ELSE 100.0;
DYNX(W_,181) = 0.0;
SolveScalarLinearParametric(1.0-DYNX(DYNhelp,1)*(IF DYNX(W_,21) THEN DYNX(DP_,8)
   ELSE 0.0),"1.0-(if activeWall.system.use_eps_Re then 0.0 else 100.0)*(if activeWall.system.use_eps_Re then activeWall.system.eps_m_flow else 0.0)",
   (IF DYNX(W_,21) THEN DYNX(W_,22) ELSE 0.0)+DYNX(DYNhelp,1)*(IF DYNX(W_,21)
   THEN 0.0 ELSE DYNX(DP_,10)),"(if activeWall.system.use_eps_Re then activeWall.system.m_flow_nominal else 0.0)+(if activeWall.system.use_eps_Re then 0.0 else 100.0)*(if activeWall.system.use_eps_Re then 0.0 else activeWall.system.m_flow_small)",
   DYNX(W_,181),"activeWall.pipe.flowModel.m_flow_nominal");
DYNX(W_,182) = IF DYNX(W_,21) THEN DYNX(DP_,8)*DYNX(W_,181) ELSE DYNX(DP_,10);
 /* End of Equation Block */ 

DYNX(W_,202) = DYNX(DP_,55);
DYNX(W_,209) = DYNX(DP_,48);
DYNX(W_,212) = DYNX(DP_,61)*DYNX(DP_,63);
DYNX(W_,235) = DYNX(DP_,67);
DYNX(W_,236) = DYNX(DP_,68);
DYNX(W_,237) = DYNX(DP_,69);
DYNX(W_,238) = DYNX(DP_,70);
DYNX(W_,239) = DYNX(DP_,71);
DYNX(W_,240) = DYNX(DP_,72);
DYNX(W_,241) = DYNX(DP_,73);
DYNX(W_,242) = DYNX(DP_,74);
DYNX(W_,243) = DYNX(DP_,75);
DYNX(W_,244) = DYNX(DP_,76);
DYNX(W_,245) = DYNX(DP_,77);
DYNX(W_,246) = DYNX(DP_,78);
DYNX(W_,247) = DYNX(DP_,79);
DYNX(W_,248) = DYNX(DP_,80);
DYNX(W_,249) = DYNX(DP_,81);
DYNX(W_,250) = DYNX(DP_,82);
DYNX(W_,251) = DYNX(DP_,83);
DYNX(W_,252) = DYNX(DP_,84);
DYNX(W_,253) = DYNX(DP_,85);
DYNX(W_,254) = DYNX(DP_,86);
DYNX(W_,255) = DYNX(DP_,87);
DYNX(W_,256) = DYNX(DP_,88);
DYNX(W_,257) = DYNX(DP_,89);
DYNX(W_,258) = DYNX(DP_,90);
DYNX(W_,259) = DYNX(DP_,91);
DYNX(W_,260) = DYNX(DP_,92);
DYNX(W_,261) = DYNX(DP_,93);
DYNX(W_,262) = DYNX(DP_,94);
DYNX(W_,263) = DYNX(DP_,95);
DYNX(W_,264) = DYNX(DP_,96);
DYNX(W_,329) = 0.7853981633974483*DYNX(DP_,107)*DYNX(DP_,107);
DYNX(W_,330) = 3.141592653589793*DYNX(DP_,107);
DYNX(W_,331) = DYNX(W_,329)*DYNX(DP_,106)*DYNX(DP_,105);
DYNX(W_,332) = DYNX(W_,7);
DYNX(W_,333) = DYNX(W_,332);
DYNX(W_,342) = DYNX(DP_,105);
DYNX(W_,345) = DYNX(DP_,2);
DYNX(W_,349) = DYNX(W_,332);
DYNX(W_,350) = DYNX(W_,333);

 /* Linear system of equations to solve. */
/* Tag: initialization.linear[3] */
/* Introducing 1 common subexpressions used in 1 expressions */
/* Of the common subexpressions 1 are reals, 0 are integers, and 0
   are booleans. */
DYNX(DYNhelp,2) = IF DYNX(W_,9) THEN 0.0 ELSE 100.0;
DYNX(W_,372) = 0.0;
SolveScalarLinearParametric(1.0-DYNX(DYNhelp,2)*(IF DYNX(W_,9) THEN DYNX(DP_,3)
   ELSE 0.0),"1.0-(if system.use_eps_Re then 0.0 else 100.0)*(if system.use_eps_Re then system.eps_m_flow else 0.0)",
   (IF DYNX(W_,9) THEN DYNX(W_,10) ELSE 0.0)+DYNX(DYNhelp,2)*(IF DYNX(W_,9)
   THEN 0.0 ELSE DYNX(DP_,5)),"(if system.use_eps_Re then system.m_flow_nominal else 0.0)+(if system.use_eps_Re then 0.0 else 100.0)*(if system.use_eps_Re then 0.0 else system.m_flow_small)",
   DYNX(W_,372),"pipe.flowModel.m_flow_nominal");
DYNX(W_,373) = IF DYNX(W_,9) THEN DYNX(DP_,3)*DYNX(W_,372) ELSE DYNX(DP_,5);
 /* End of Equation Block */ 

DYNX(W_,389) = divmacro(DYNX(W_,71)*DYNX(W_,45),"activeWall.Wall.A*activeWall.Wall.wallType.lambda[1]",
  0.5*DYNX(W_,37),"0.5*activeWall.Wall.wallType.d[1]");
DYNX(W_,391) = divmacro(DYNX(W_,71)*DYNX(W_,46),"activeWall.Wall.A*activeWall.Wall.wallType.lambda[2]",
  0.5*DYNX(W_,38),"0.5*activeWall.Wall.wallType.d[2]");
DYNX(W_,395) = divmacro(DYNX(W_,71)*DYNX(W_,47),"activeWall.Wall.A*activeWall.Wall.wallType.lambda[3]",
  0.5*DYNX(W_,39),"0.5*activeWall.Wall.wallType.d[3]");
DYNX(W_,397) = divmacro(DYNX(W_,71)*DYNX(W_,48),"activeWall.Wall.A*activeWall.Wall.wallType.lambda[4]",
  0.5*DYNX(W_,40),"0.5*activeWall.Wall.wallType.d[4]");
DYNX(W_,400) = divmacro(DYNX(W_,71)*DYNX(W_,45),"activeWall.Wall.A*activeWall.Wall.wallType.lambda[1]",
  0.5*DYNX(W_,37),"0.5*activeWall.Wall.wallType.d[1]");
DYNX(W_,402) = divmacro(DYNX(W_,71)*DYNX(W_,46),"activeWall.Wall.A*activeWall.Wall.wallType.lambda[2]",
  0.5*DYNX(W_,38),"0.5*activeWall.Wall.wallType.d[2]");
DYNX(W_,404) = divmacro(DYNX(W_,71)*DYNX(W_,47),"activeWall.Wall.A*activeWall.Wall.wallType.lambda[3]",
  0.5*DYNX(W_,39),"0.5*activeWall.Wall.wallType.d[3]");
DYNX(W_,406) = divmacro(DYNX(W_,71)*DYNX(W_,48),"activeWall.Wall.A*activeWall.Wall.wallType.lambda[4]",
  0.5*DYNX(W_,40),"0.5*activeWall.Wall.wallType.d[4]");
DYNX(W_,407) = DYNX(W_,49)*DYNX(W_,41)*DYNX(W_,71)*DYNX(W_,37);
DYNX(W_,409) = DYNX(W_,50)*DYNX(W_,42)*DYNX(W_,71)*DYNX(W_,38);
DYNX(W_,411) = DYNX(W_,51)*DYNX(W_,43)*DYNX(W_,71)*DYNX(W_,39);
DYNX(W_,413) = DYNX(W_,52)*DYNX(W_,44)*DYNX(W_,71)*DYNX(W_,40);
DYNX(W_,343) = divmacro(4*DYNX(W_,329),"4*pipe.crossArea",DYNX(W_,330),
  "pipe.perimeter");
DYNX(W_,344) = divmacro(4*DYNX(W_,329),"4*pipe.crossArea",DYNX(W_,330),
  "pipe.perimeter");
DYNX(W_,377) = 0.5*(DYNX(W_,343)+DYNX(W_,344));
DYNX(W_,186) = 0.5*(DYNX(W_,130)+DYNX(W_,131));
DYNX(W_,97) = 87.0*DYNX(DP_,55)*DYNX(W_,128);
DYNX(W_,114) = 995.586*DYNX(W_,97);
DYNX(W_,98) = 87.0*DYNX(DP_,55)*DYNX(W_,129);
DYNX(W_,115) = 995.586*DYNX(W_,98);
DYNX(W_,197) = 87.0*DYNX(W_,93);
DYNX(W_,198) = 87.0*DYNX(W_,93);
InitialBoundSection
{
  struct DymStruc0 dummy_DymStruc0;
  dummy_DymStruc0 = (PushModelContext(1,"Modelica.Blocks.Types.ExternalCombiTable1D(\"NoName\", \"NoName\", pump.table_minMaxCharacteristics.table, pump.table_minMaxCharacteristics.columns, Modelica.Blocks.Types.Smoothness.LinearSegments, 0, 1)")
    Modelica_Blocks_Types_ExternalCombiTable1D_M("NoName", "NoName", 
    RealTemporaryDense( &DYNX(W_,235), 2, 10, 3), IntegerTemporaryDense( 
    &DYNX(DP_,100), 1, 2), 1, 0, 1));
  DYNX(W_,266) = dummy_DymStruc0.id_0member;
PopAllMarks();
}
BoundParameterSection
DYNX(DYNhelp,3) = divmacro(1.0,"1.0",DYNX(W_,150),"activeWall.pipe.flowModel.nParallel");
DYNX(W_,187) = (PushModelContext(1,"pressureLoss_m_flow_Unique9(activeWall.pipe.flowModel.m_flow_nominal/activeWall.pipe.flowModel.nParallel, activeWall.pipe.flowModel.rho_nominal, activeWall.pipe.flowModel.rho_nominal, activeWall.pipe.flowModel.mu_nominal, activeWall.pipe.flowModel.mu_nominal, 174.0, activeWall.pipe.flowModel.diameters[1], 0.5*(activeWall.pipe.crossAreas[1]+activeWall.pipe.crossAreas[2]), 0.5*(activeWall.pipe.ro...")
  pressureLossx_0mx_0flowx_0Unique9(DYNX(DYNhelp,3)*DYNX(W_,181), DYNX(DP_,59), 
  DYNX(DP_,59), DYNX(DP_,60), DYNX(DP_,60), 174.0, DYNX(W_,186), 0.5*(
  DYNX(W_,128)+DYNX(W_,129)), 0.5*(DYNX(W_,132)+DYNX(W_,133)), DYNX(DYNhelp,3)*
  DYNX(W_,182), 4000));
PopModelContext();
DYNX(DYNhelp,4) = divmacro(1.0,"1.0",DYNX(W_,342),"pipe.flowModel.nParallel");
DYNX(W_,378) = (PushModelContext(1,"pressureLoss_m_flow_Unique9(pipe.flowModel.m_flow_nominal/pipe.flowModel.nParallel, pipe.flowModel.rho_nominal, pipe.flowModel.rho_nominal, pipe.flowModel.mu_nominal, pipe.flowModel.mu_nominal, pipe.length, pipe.flowModel.diameters[1], pipe.crossArea, pipe.roughness, pipe.flowModel.m_flow_small/pipe.flowModel.nParallel, 4000)")
  pressureLossx_0mx_0flowx_0Unique9(DYNX(DYNhelp,4)*DYNX(W_,372), DYNX(DP_,110),
   DYNX(DP_,110), DYNX(DP_,111), DYNX(DP_,111), DYNX(DP_,106), DYNX(W_,377), 
  DYNX(W_,329), DYNX(DP_,108), DYNX(DYNhelp,4)*DYNX(W_,373), 4000));
PopModelContext();
InitialSection
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,85) = 83680.0;
DYNX(W_,147) = 288.15;
DYNX(W_,224) = 288.15;
DYNX(W_,225) = 288.15;
DYNX(W_,322) = 288.15;
DYNX(W_,337) = 288.15;
DYNX(W_,339) = 288.15;
#endif
DYNX(Aux_,4) = 83680.0;
DYNX(Aux_,4) = 83680.0;
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(F_,1) = 0;
DYNX(F_,2) = 0;
DYNX(F_,3) = 0;
DYNX(F_,4) = 0;
#endif
InitialSection
InitialStartSection
InitialStartSection2
DYNX(W_,59) = DYNX(W_,57);
DYNX(W_,72) = DYNX(W_,57);
DYNX(W_,80) = DYNX(W_,57);
DYNX(W_,84) = DYNX(W_,109);
DYNX(W_,388) = DYNX(W_,57);
DYNX(W_,394) = DYNX(W_,57);
DYNX(X_,1) = DYNX(W_,57);
DYNX(X_,2) = DYNX(W_,57);
DYNX(X_,3) = DYNX(W_,57);
DYNX(X_,4) = DYNX(W_,57);
DYNX(X_,5) = DYNX(W_,108);
InitialSection
DefaultSection
InitializeData(0)
InitialSection
InitialSection2
DYNX(W_,7) = DYNX(DP_,0);
DYNX(W_,8) = DYNX(DP_,1);
DYNX(W_,10) = IF DYNX(W_,9) THEN 1 ELSE 100.0*DYNX(DP_,5);
DYNX(W_,19) = DYNX(DP_,6);
DYNX(W_,22) = IF DYNX(W_,21) THEN 1 ELSE 100.0*DYNX(DP_,10);
DYNX(W_,37) = DYNX(DP_,11);
DYNX(W_,38) = DYNX(DP_,12);
DYNX(W_,39) = DYNX(DP_,13);
DYNX(W_,40) = DYNX(DP_,14);
DYNX(W_,41) = DYNX(DP_,15);
DYNX(W_,42) = DYNX(DP_,16);
DYNX(W_,43) = DYNX(DP_,17);
DYNX(W_,44) = DYNX(DP_,18);
DYNX(W_,45) = DYNX(DP_,19);
DYNX(W_,46) = DYNX(DP_,20);
DYNX(W_,47) = DYNX(DP_,21);
DYNX(W_,48) = DYNX(DP_,22);
DYNX(W_,49) = DYNX(DP_,23);
DYNX(W_,50) = DYNX(DP_,24);
DYNX(W_,51) = DYNX(DP_,25);
DYNX(W_,52) = DYNX(DP_,26);
DYNX(W_,53) = DYNX(DP_,27);
DYNX(W_,57) = DYNX(DP_,49);
DYNX(W_,69) = DYNX(W_,53);
DYNX(W_,91) = DYNX(DP_,47);
DYNX(W_,92) = 0.7853981633974483*DYNX(W_,91)*DYNX(W_,91);
DYNX(W_,93) = 3.141592653589793*DYNX(W_,91);
DYNX(W_,94) = DYNX(W_,92)*DYNX(W_,89)*DYNX(DP_,55);
DYNX(W_,103) = DYNX(W_,19);
DYNX(W_,104) = DYNX(W_,103);
DYNX(W_,105) = DYNX(W_,103);
DYNX(W_,106) = DYNX(W_,104);

 /* Linear system of equations to solve. */
/* Tag: initialization.linear[4] */
/* Introducing 1 common subexpressions used in 1 expressions */
/* Of the common subexpressions 1 are reals, 0 are integers, and 0
   are booleans. */
DYNX(DYNhelp,5) = IF DYNX(W_,107) THEN 0.0 ELSE 0.0002390057361376673;
DYNX(W_,108) = 288.15;
SolveScalarLinearParametric(1.0-DYNX(DYNhelp,5)*(IF DYNX(W_,107) THEN 4184.0
   ELSE 0.0),"1.0-(if activeWall.pipe.use_T_start then 0.0 else 0.0002390057361376673)*(if activeWall.pipe.use_T_start then 4184.0 else 0.0)",
   (IF DYNX(W_,107) THEN DYNX(W_,20) ELSE 273.15)+DYNX(DYNhelp,5)*(IF 
  DYNX(W_,107) THEN -1142859.5999999999 ELSE 83680.0),"(if activeWall.pipe.use_T_start then activeWall.system.T_start else 273.15)+(if activeWall.pipe.use_T_start then 0.0 else 0.0002390057361376673)*(if activeWall.pipe.use_T_start then -1142859.5999999999 else 83680.0)",
   DYNX(W_,108),"activeWall.pipe.T_start");
DYNX(W_,109) = IF DYNX(W_,107) THEN 4184*(DYNX(W_,108)-273.15) ELSE 83680.0;
 /* End of Equation Block */ 

DYNX(W_,128) = DYNX(W_,92);
DYNX(W_,129) = DYNX(W_,92);
DYNX(W_,130) = divmacro(4*DYNX(W_,92),"4*activeWall.pipe.crossArea",DYNX(W_,93),
  "activeWall.pipe.perimeter");
DYNX(W_,131) = divmacro(4*DYNX(W_,92),"4*activeWall.pipe.crossArea",DYNX(W_,93),
  "activeWall.pipe.perimeter");
DYNX(W_,132) = DYNX(DP_,56);
DYNX(W_,133) = DYNX(DP_,56);
DYNX(W_,150) = DYNX(DP_,55);
DYNX(W_,152) = DYNX(DP_,7);
DYNX(W_,156) = DYNX(W_,103);
DYNX(W_,157) = DYNX(W_,104);

 /* Linear system of equations to solve. */
/* Tag: initialization.linear[5] */
/* Introducing 1 common subexpressions used in 1 expressions */
/* Of the common subexpressions 1 are reals, 0 are integers, and 0
   are booleans. */
DYNX(DYNhelp,6) = IF DYNX(W_,21) THEN 0.0 ELSE 100.0;
DYNX(W_,181) = 0.0;
SolveScalarLinearParametric(1.0-DYNX(DYNhelp,6)*(IF DYNX(W_,21) THEN DYNX(DP_,8)
   ELSE 0.0),"1.0-(if activeWall.system.use_eps_Re then 0.0 else 100.0)*(if activeWall.system.use_eps_Re then activeWall.system.eps_m_flow else 0.0)",
   (IF DYNX(W_,21) THEN DYNX(W_,22) ELSE 0.0)+DYNX(DYNhelp,6)*(IF DYNX(W_,21)
   THEN 0.0 ELSE DYNX(DP_,10)),"(if activeWall.system.use_eps_Re then activeWall.system.m_flow_nominal else 0.0)+(if activeWall.system.use_eps_Re then 0.0 else 100.0)*(if activeWall.system.use_eps_Re then 0.0 else activeWall.system.m_flow_small)",
   DYNX(W_,181),"activeWall.pipe.flowModel.m_flow_nominal");
DYNX(W_,182) = IF DYNX(W_,21) THEN DYNX(DP_,8)*DYNX(W_,181) ELSE DYNX(DP_,10);
 /* End of Equation Block */ 

DYNX(W_,202) = DYNX(DP_,55);
DYNX(W_,209) = DYNX(DP_,48);
DYNX(W_,212) = DYNX(DP_,61)*DYNX(DP_,63);
DYNX(W_,235) = DYNX(DP_,67);
DYNX(W_,236) = DYNX(DP_,68);
DYNX(W_,237) = DYNX(DP_,69);
DYNX(W_,238) = DYNX(DP_,70);
DYNX(W_,239) = DYNX(DP_,71);
DYNX(W_,240) = DYNX(DP_,72);
DYNX(W_,241) = DYNX(DP_,73);
DYNX(W_,242) = DYNX(DP_,74);
DYNX(W_,243) = DYNX(DP_,75);
DYNX(W_,244) = DYNX(DP_,76);
DYNX(W_,245) = DYNX(DP_,77);
DYNX(W_,246) = DYNX(DP_,78);
DYNX(W_,247) = DYNX(DP_,79);
DYNX(W_,248) = DYNX(DP_,80);
DYNX(W_,249) = DYNX(DP_,81);
DYNX(W_,250) = DYNX(DP_,82);
DYNX(W_,251) = DYNX(DP_,83);
DYNX(W_,252) = DYNX(DP_,84);
DYNX(W_,253) = DYNX(DP_,85);
DYNX(W_,254) = DYNX(DP_,86);
DYNX(W_,255) = DYNX(DP_,87);
DYNX(W_,256) = DYNX(DP_,88);
DYNX(W_,257) = DYNX(DP_,89);
DYNX(W_,258) = DYNX(DP_,90);
DYNX(W_,259) = DYNX(DP_,91);
DYNX(W_,260) = DYNX(DP_,92);
DYNX(W_,261) = DYNX(DP_,93);
DYNX(W_,262) = DYNX(DP_,94);
DYNX(W_,263) = DYNX(DP_,95);
DYNX(W_,264) = DYNX(DP_,96);
DYNX(W_,329) = 0.7853981633974483*DYNX(DP_,107)*DYNX(DP_,107);
DYNX(W_,330) = 3.141592653589793*DYNX(DP_,107);
DYNX(W_,331) = DYNX(W_,329)*DYNX(DP_,106)*DYNX(DP_,105);
DYNX(W_,332) = DYNX(W_,7);
DYNX(W_,333) = DYNX(W_,332);
DYNX(W_,342) = DYNX(DP_,105);
DYNX(W_,345) = DYNX(DP_,2);
DYNX(W_,349) = DYNX(W_,332);
DYNX(W_,350) = DYNX(W_,333);

 /* Linear system of equations to solve. */
/* Tag: initialization.linear[6] */
/* Introducing 1 common subexpressions used in 1 expressions */
/* Of the common subexpressions 1 are reals, 0 are integers, and 0
   are booleans. */
DYNX(DYNhelp,7) = IF DYNX(W_,9) THEN 0.0 ELSE 100.0;
DYNX(W_,372) = 0.0;
SolveScalarLinearParametric(1.0-DYNX(DYNhelp,7)*(IF DYNX(W_,9) THEN DYNX(DP_,3)
   ELSE 0.0),"1.0-(if system.use_eps_Re then 0.0 else 100.0)*(if system.use_eps_Re then system.eps_m_flow else 0.0)",
   (IF DYNX(W_,9) THEN DYNX(W_,10) ELSE 0.0)+DYNX(DYNhelp,7)*(IF DYNX(W_,9)
   THEN 0.0 ELSE DYNX(DP_,5)),"(if system.use_eps_Re then system.m_flow_nominal else 0.0)+(if system.use_eps_Re then 0.0 else 100.0)*(if system.use_eps_Re then 0.0 else system.m_flow_small)",
   DYNX(W_,372),"pipe.flowModel.m_flow_nominal");
DYNX(W_,373) = IF DYNX(W_,9) THEN DYNX(DP_,3)*DYNX(W_,372) ELSE DYNX(DP_,5);
 /* End of Equation Block */ 

DYNX(W_,389) = divmacro(DYNX(W_,71)*DYNX(W_,45),"activeWall.Wall.A*activeWall.Wall.wallType.lambda[1]",
  0.5*DYNX(W_,37),"0.5*activeWall.Wall.wallType.d[1]");
DYNX(W_,391) = divmacro(DYNX(W_,71)*DYNX(W_,46),"activeWall.Wall.A*activeWall.Wall.wallType.lambda[2]",
  0.5*DYNX(W_,38),"0.5*activeWall.Wall.wallType.d[2]");
DYNX(W_,395) = divmacro(DYNX(W_,71)*DYNX(W_,47),"activeWall.Wall.A*activeWall.Wall.wallType.lambda[3]",
  0.5*DYNX(W_,39),"0.5*activeWall.Wall.wallType.d[3]");
DYNX(W_,397) = divmacro(DYNX(W_,71)*DYNX(W_,48),"activeWall.Wall.A*activeWall.Wall.wallType.lambda[4]",
  0.5*DYNX(W_,40),"0.5*activeWall.Wall.wallType.d[4]");
DYNX(W_,400) = divmacro(DYNX(W_,71)*DYNX(W_,45),"activeWall.Wall.A*activeWall.Wall.wallType.lambda[1]",
  0.5*DYNX(W_,37),"0.5*activeWall.Wall.wallType.d[1]");
DYNX(W_,402) = divmacro(DYNX(W_,71)*DYNX(W_,46),"activeWall.Wall.A*activeWall.Wall.wallType.lambda[2]",
  0.5*DYNX(W_,38),"0.5*activeWall.Wall.wallType.d[2]");
DYNX(W_,404) = divmacro(DYNX(W_,71)*DYNX(W_,47),"activeWall.Wall.A*activeWall.Wall.wallType.lambda[3]",
  0.5*DYNX(W_,39),"0.5*activeWall.Wall.wallType.d[3]");
DYNX(W_,406) = divmacro(DYNX(W_,71)*DYNX(W_,48),"activeWall.Wall.A*activeWall.Wall.wallType.lambda[4]",
  0.5*DYNX(W_,40),"0.5*activeWall.Wall.wallType.d[4]");
DYNX(W_,407) = DYNX(W_,49)*DYNX(W_,41)*DYNX(W_,71)*DYNX(W_,37);
DYNX(W_,409) = DYNX(W_,50)*DYNX(W_,42)*DYNX(W_,71)*DYNX(W_,38);
DYNX(W_,411) = DYNX(W_,51)*DYNX(W_,43)*DYNX(W_,71)*DYNX(W_,39);
DYNX(W_,413) = DYNX(W_,52)*DYNX(W_,44)*DYNX(W_,71)*DYNX(W_,40);
DYNX(W_,61) = DYNX(W_,54);
DYNX(W_,183) = DYNX(DP_,9);
DYNX(W_,180) = 1000.0*DYNX(W_,183);
DYNX(W_,267) = 0.0;
  {
    DYNX(W_,267) = 1.0;
  }
DYNX(W_,374) = DYNX(DP_,4);
DYNX(W_,371) = 1000.0*DYNX(W_,374);
DYNX(W_,343) = divmacro(4*DYNX(W_,329),"4*pipe.crossArea",DYNX(W_,330),
  "pipe.perimeter");
DYNX(W_,344) = divmacro(4*DYNX(W_,329),"4*pipe.crossArea",DYNX(W_,330),
  "pipe.perimeter");
DYNX(W_,377) = 0.5*(DYNX(W_,343)+DYNX(W_,344));
DYNX(W_,186) = 0.5*(DYNX(W_,130)+DYNX(W_,131));
DYNX(W_,97) = 87.0*DYNX(DP_,55)*DYNX(W_,128);
DYNX(W_,114) = 995.586*DYNX(W_,97);
DYNX(W_,98) = 87.0*DYNX(DP_,55)*DYNX(W_,129);
DYNX(W_,115) = 995.586*DYNX(W_,98);
DYNX(W_,197) = 87.0*DYNX(W_,93);
DYNX(W_,198) = 87.0*DYNX(W_,93);
InitialBoundSection
{
  struct DymStruc0 dummy_DymStruc0;
  dummy_DymStruc0 = (PushModelContext(1,"Modelica.Blocks.Types.ExternalCombiTable1D(\"NoName\", \"NoName\", pump.table_minMaxCharacteristics.table, pump.table_minMaxCharacteristics.columns, Modelica.Blocks.Types.Smoothness.LinearSegments, 0, 1)")
    Modelica_Blocks_Types_ExternalCombiTable1D_M("NoName", "NoName", 
    RealTemporaryDense( &DYNX(W_,235), 2, 10, 3), IntegerTemporaryDense( 
    &DYNX(DP_,100), 1, 2), 1, 0, 1));
  DYNX(W_,266) = dummy_DymStruc0.id_0member;
PopAllMarks();
}
InitialSection2
if (DymolaHomotopyLambda==0){
  BreakSectionCallNew(2);
}
else {

  { /* Non-linear system of equations to solve. */
  /* Tag: initialization.nonlinear[1] */
  /* Introducing 20 common subexpressions used in 29 expressions */
  /* Of the common subexpressions 20 are reals, 0 are integers, and 0
     are booleans. */
  const char*const varnames_[]={"pump.dp", "activeWall.pipe.mediums[2].p"};
  const double nominal_[]={1e5, 100000.0};
  NonLinearSystemOfEquations(Jacobian__, residue__, x__, 2, 0, 2, 7, 
    DYNX(DYNhelp,75), 53, DYNX(did_->helpvari_vec,24), 24);
  SetInitVector(x__, 1, DYNX(W_,221), DYNX(DP_,64));
  SetInitVector(x__, 2, DYNX(W_,427), DYNX(W_,106));
  Residues;
    DYNX(W_,415) = 10000.0-DYNX(W_,221);
    DYNX(DYNhelp,128) = DYNX(W_,128)+DYNX(W_,129);
    DYNX(W_,162) = 0.5*DYNX(W_,150)*DYNX(DYNhelp,128)*(DYNX(W_,427)-DYNX(W_,415));
    DYNX(DYNhelp,129) = divmacro(1.0,"1.0",DYNX(W_,150),"activeWall.pipe.flowModel.nParallel");
    DYNX(DYNhelp,130) = divmacro(1.0,"1.0",DYNX(DYNhelp,128),"activeWall.pipe.crossAreas[1]+activeWall.pipe.crossAreas[2]");
    DYNX(W_,172) = DYNX(DYNhelp,130)*DYNX(DYNhelp,129)*(-2)*DYNX(W_,162);
    DYNX(DYNhelp,131) = 0.5*DYNX(DYNhelp,128);
    DYNX(DYNhelp,132) = 0.5*(DYNX(W_,132)+DYNX(W_,133));
    DYNX(DYNhelp,133) = divmacro(1.0,"1.0",DYNX(W_,180),"activeWall.pipe.flowModel.dp_nominal");
    DYNX(W_,82) =  -homotopy(DYNX(W_,150)*(PushModelContext(1,"massFlowRate_dp_staticHead_Unique13(activeWall.pipe.flowModel.dps_fg[1], 995.586, 995.586, 0.001, 0.001, 174.0, activeWall.pipe.flowModel.diameters[1], 0.0, 0.5*(activeWall.pipe.crossAreas[1]+activeWall.pipe.crossAreas[2]), 0.5*(activeWall.pipe.roughnesses[1]+activeWall.pipe.roughnesses[2]), activeWall.pipe.flowModel.dp_small, 4000.0)")
      massFlowRatex_0dpx_0staticHeadx_0Unique13(DYNX(W_,172), 995.586, 995.586, 
      0.001, 0.001, 174.0, DYNX(W_,186), 0.0, DYNX(DYNhelp,131), 
      DYNX(DYNhelp,132), DYNX(W_,183), 4000.0)), DYNX(DYNhelp,133)*DYNX(W_,181)*
      DYNX(W_,172));
    PopModelContext();
    DYNX(W_,222) = (-0.0010044335697769957)*DYNX(W_,82);
    DYNX(W_,231) = DYNX(W_,222)*3600;
    DYNX(W_,228) = (PushModelContext(1,"Modelica.Blocks.Tables.CombiTable1Ds.getTableValue(\npump.table_minMaxCharacteristics.tableID, \n1, \npump.table_minMaxCharacteristics.u, \npump.table_minMaxCharacteristics.tableOnFileRead)")
      Modelica_Blocks_Tables_CombiTable1Ds_getTableValue_M(DymStruc0_construct(
      (Integer)(DYNX(W_,266))), 1, DYNX(W_,231), DYNX(W_,267)));
    PopModelContext();
    DYNX(W_,354) = DYNX(W_,342)*DYNX(W_,329)*(10000.0-DYNX(W_,427));
    DYNX(DYNhelp,134) = divmacro(1.0,"1.0",DYNX(W_,342),"pipe.flowModel.nParallel");
    DYNX(DYNhelp,135) = 2.0*DYNX(W_,329);
    DYNX(DYNhelp,136) = divmacro(1.0,"1.0",DYNX(DYNhelp,135),"2.0*pipe.crossArea");
    DYNX(W_,364) = DYNX(DYNhelp,136)*DYNX(DYNhelp,134)*(-2)*DYNX(W_,354);
  DYNX(DYNhelp,137) = DYNX(W_,345)*DYNX(DP_,109);
  DYNX(DYNhelp,138) = DYNX(DP_,110)*DYNX(W_,345);
  DYNX(DYNhelp,139) = divmacro(1.0,"1.0",DYNX(W_,371),"pipe.flowModel.dp_nominal");
  SetVector(residue__, 1, DYNX(W_,228)+0.00010242371959608998*DYNX(W_,221));
  SetVector(residue__, 2, DYNX(W_,82)+homotopy(DYNX(W_,342)*(PushModelContext(1,
    "massFlowRate_dp_staticHead_Unique13(pipe.flowModel.dps_fg[1], 995.586, 995.586, 0.001, 0.001, pipe.length, pipe.flowModel.diameters[1], pipe.flowModel.g*pipe.height_ab, pipe.crossArea, pipe.roughness, pipe.flowModel.dp_small, 4000.0)")
    massFlowRatex_0dpx_0staticHeadx_0Unique13(DYNX(W_,364), 995.586, 995.586, 
    0.001, 0.001, DYNX(DP_,106), DYNX(W_,377), DYNX(DYNhelp,137), DYNX(W_,329), 
    DYNX(DP_,108), DYNX(W_,374), 4000.0)), DYNX(DYNhelp,139)*DYNX(W_,372)*(
    DYNX(W_,364)-DYNX(DYNhelp,138)*DYNX(DP_,109))));
  PopModelContext();

  Jacobian(Jacobian__)
  MatrixZeros(Jacobian__);
  DYNX(DYNhelp,140) = DYNX(W_,150)*DYNX(DYNhelp,128);
  DYNX(DYNhelp,141) = homotopy(DYNX(W_,150)*(PushModelContext(1,"massFlowRate_dp_staticHead_Unique13:der(activeWall.pipe.flowModel.dps_fg[1], 995.586, 995.586, 0.001, 0.001, 174.0, activeWall.pipe.flowModel.diameters[1], 0.0, 0.5*(activeWall.pipe.crossAreas[1]+activeWall.pipe.crossAreas[2]), 0.5*(activeWall.pipe.roughnesses[1]+activeWall.pipe.roughnesses[2]), activeWall.pipe.flowModel.dp_small, 4000.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)")
    massFlowRatex_0dpx_0staticHeadx_0Unique13__der(DYNX(W_,172), 995.586, 
    995.586, 0.001, 0.001, 174.0, DYNX(W_,186), 0.0, DYNX(DYNhelp,131), 
    DYNX(DYNhelp,132), DYNX(W_,183), 4000.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 
    0.0, 0.0, 0.0, 0.0, 0.0)), DYNX(DYNhelp,133)*DYNX(W_,181));
  PopModelContext();
  DYNX(DYNhelp,142) = DYNX(DYNhelp,141)*(PushModelContext(1,"Modelica.Blocks.Tables.CombiTable1Ds.getDerTableValue(\npump.table_minMaxCharacteristics.tableID, \n1, \npump.table_minMaxCharacteristics.u, \npump.table_minMaxCharacteristics.tableOnFileRead, \n1.0)")
    Modelica_Blocks_Tables_CombiTable1Ds_getDerTableValue_M(DymStruc0_construct(
    (Integer)(DYNX(W_,266))), 1, DYNX(W_,231), DYNX(W_,267), 1.0));
  PopModelContext();
  DYNX(DYNhelp,143) = DYNX(DYNhelp,130)*DYNX(DYNhelp,129)*(-3.6159608511971846)*
    DYNX(DYNhelp,140)*DYNX(DYNhelp,142);
  DYNX(DYNhelp,144) = DYNX(DYNhelp,130)*DYNX(DYNhelp,129)*(-1.0)*
    DYNX(DYNhelp,140)*DYNX(DYNhelp,141);
  DYNX(DYNhelp,145) = DYNX(W_,342)*(PushModelContext(1,"massFlowRate_dp_staticHead_Unique13:der(pipe.flowModel.dps_fg[1], 995.586, 995.586, 0.001, 0.001, pipe.length, pipe.flowModel.diameters[1], pipe.flowModel.g*pipe.height_ab, pipe.crossArea, pipe.roughness, pipe.flowModel.dp_small, 4000.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)")
    massFlowRatex_0dpx_0staticHeadx_0Unique13__der(DYNX(W_,364), 995.586, 
    995.586, 0.001, 0.001, DYNX(DP_,106), DYNX(W_,377), DYNX(DYNhelp,137), 
    DYNX(W_,329), DYNX(DP_,108), DYNX(W_,374), 4000.0, 1.0, 0.0, 0.0, 0.0, 0.0, 
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));
  PopModelContext();
  DYNX(DYNhelp,146) = DYNX(DYNhelp,139)*DYNX(W_,372);
  DYNX(DYNhelp,147) = DYNX(W_,342)*DYNX(W_,329);
  SetMatrixLeading(Jacobian__, 1, 1, 2, 0.00010242371959608998+DYNX(DYNhelp,143));
  SetMatrixLeading(Jacobian__, 1, 2, 2, DYNX(DYNhelp,143));
  SetMatrixLeading(Jacobian__, 2, 1, 2,  -DYNX(DYNhelp,144));
  SetMatrixLeading(Jacobian__, 2, 2, 2, DYNX(DYNhelp,136)*DYNX(DYNhelp,134)*2.0*
    homotopy(DYNX(DYNhelp,145), DYNX(DYNhelp,146))*DYNX(DYNhelp,147)-
    DYNX(DYNhelp,144));

  SolveNonLinearSystemOfEquationsInit(Jacobian__, residue__, x__,"Tag: initialization.nonlinear[1]");
  DYNX(W_,221) = GetVector(x__, 1);
  DYNX(W_,427) = GetVector(x__, 2);
  EndNonLinearSystemOfEquationsInit(residue__, x__, 2);
   /* End of Non-Linear Equation Block */ }



}
DYNX(W_,191) = divmacro(divmacro((-0.0010044335697769957)*DYNX(W_,82),
  "(-0.0010044335697769957)*activeWall.port_b1.m_flow",DYNX(W_,128),
  "activeWall.pipe.crossAreas[1]"),"(-0.0010044335697769957)*activeWall.port_b1.m_flow/activeWall.pipe.crossAreas[1]",
  DYNX(DP_,55),"activeWall.pipe.nParallel");
BreakSectionFunctionEnd()
BreakSectionFunctionStart(3);
DYNX(W_,124) = 0.5*DYNX(W_,191)*DYNX(W_,128)*(DYNX(W_,427)-DYNX(W_,415)+
  DYNX(W_,172))*DYNX(DP_,55);
InitialSection
DYNX(Aux_,8) = RealBmax( -DYNX(W_,82), 0.0)+RealBmax(DYNX(W_,82), 0.0);
DYNX(Aux_,9) = IF DYNX(Aux_,8) > 1E-010 THEN 1.0 ELSE IF DYNX(Aux_,8) > 0.0
   THEN sqr(10000000000.0*DYNX(Aux_,8))*(3.0-20000000000.0*DYNX(Aux_,8)) ELSE 
  0.0;
InitialSection2
DYNX(W_,192) = divmacro(divmacro((-0.0010044335697769957)*DYNX(W_,82),
  "(-0.0010044335697769957)*activeWall.port_b1.m_flow",DYNX(W_,129),
  "activeWall.pipe.crossAreas[2]"),"(-0.0010044335697769957)*activeWall.port_b1.m_flow/activeWall.pipe.crossAreas[2]",
  DYNX(DP_,55),"activeWall.pipe.nParallel");
DYNX(W_,125) = 0.5*DYNX(W_,192)*DYNX(W_,129)*(DYNX(W_,427)-DYNX(W_,415)+
  DYNX(W_,172))*DYNX(DP_,55);
InitialSection
DYNX(Aux_,10) = RealBmax(DYNX(W_,82), 0.0)+RealBmax( -DYNX(W_,82), 0.0);
DYNX(Aux_,11) = IF DYNX(Aux_,10) > 1E-010 THEN 1.0 ELSE IF DYNX(Aux_,10) > 0.0
   THEN sqr(10000000000.0*DYNX(Aux_,10))*(3.0-20000000000.0*DYNX(Aux_,10)) ELSE 
  0.0;
InitialSection2
if (DymolaHomotopyLambda==0){
  BreakSectionCallNew(4);
}
else {

   /* Linear system of equations to solve. */
  /* Tag: initialization.linear[7] */
  /* Introducing 19 common subexpressions used in 34 expressions */
  /* Of the common subexpressions 19 are reals, 0 are integers, and 0
     are booleans. */
  DYNX(DYNhelp,184) = (PushModelContext(1,"Modelica.Blocks.Tables.CombiTable1Ds.getDerTableValue(\npump.table_minMaxCharacteristics.tableID, \n1, \npump.table_minMaxCharacteristics.u, \npump.table_minMaxCharacteristics.tableOnFileRead, \n1.0)")
    Modelica_Blocks_Tables_CombiTable1Ds_getDerTableValue_M(DymStruc0_construct(
    (Integer)(DYNX(W_,266))), 1, DYNX(W_,231), DYNX(W_,267), 1.0));
  PopModelContext();
  /* Automatic tearing of linear system of 10 simultaneous equations
  gave a linear system of 2 equations for numerical solution.*/
  {
    const char*const varnames_[]={"activeWall.pipe.mediums[1].der(p)", 
      "activeWall.pipe.mediums[2].der(p)"};
    const double nominal_[]={1, 1};
    DidLinearSystemOfEquations(J, b, y, 2, DYNX(DYNhelp,185), 24, 
      DYNX(did_->helpvari_vec,56), 8);
    /* Parameter dependent Jacobian */
    if (NewParametersJac) SetNeedFactor(J);
    if (NeedFactor(J)) {
      MatrixZeros(J);
      DYNX(DYNhelp,209) = DYNX(W_,128)+DYNX(W_,129);
      DYNX(DYNhelp,210) = 0.5*DYNX(DYNhelp,209);
      DYNX(DYNhelp,211) = 0.5*(DYNX(W_,132)+DYNX(W_,133));
      DYNX(DYNhelp,212) = divmacro(1.0,"1.0",DYNX(W_,180),"activeWall.pipe.flowModel.dp_nominal");
      DYNX(DYNhelp,213) = homotopy(DYNX(W_,150)*(PushModelContext(1,
        "massFlowRate_dp_staticHead_Unique13:der(activeWall.pipe.flowModel.dps_fg[1], 995.586, 995.586, 0.001, 0.001, 174.0, activeWall.pipe.flowModel.diameters[1], 0.0, 0.5*(activeWall.pipe.crossAreas[1]+activeWall.pipe.crossAreas[2]), 0.5*(activeWall.pipe.roughnesses[1]+activeWall.pipe.roughnesses[2]), activeWall.pipe.flowModel.dp_small, 4000.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)")
        massFlowRatex_0dpx_0staticHeadx_0Unique13__der(DYNX(W_,172), 995.586, 
        995.586, 0.001, 0.001, 174.0, DYNX(W_,186), 0.0, DYNX(DYNhelp,210), 
        DYNX(DYNhelp,211), DYNX(W_,183), 4000.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0)), DYNX(DYNhelp,212)*DYNX(W_,181));
      PopModelContext();
      DYNX(DYNhelp,214) = DYNX(DYNhelp,213)*DYNX(DYNhelp,184);
      DYNX(DYNhelp,215) = DYNX(W_,150)*DYNX(DYNhelp,209);
      DYNX(DYNhelp,216) = DYNX(DYNhelp,214)*DYNX(DYNhelp,215);
      DYNX(DYNhelp,217) = divmacro(1.0,"1.0",DYNX(W_,150),"activeWall.pipe.flowModel.nParallel");
      DYNX(DYNhelp,218) = divmacro(1.0,"1.0",DYNX(DYNhelp,209),"activeWall.pipe.crossAreas[1]+activeWall.pipe.crossAreas[2]");
      DYNX(DYNhelp,219) = DYNX(DYNhelp,213)*DYNX(DYNhelp,215);
      DYNX(DYNhelp,220) = DYNX(W_,342)*(PushModelContext(1,"massFlowRate_dp_staticHead_Unique13:der(pipe.flowModel.dps_fg[1], 995.586, 995.586, 0.001, 0.001, pipe.length, pipe.flowModel.diameters[1], pipe.flowModel.g*pipe.height_ab, pipe.crossArea, pipe.roughness, pipe.flowModel.dp_small, 4000.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)")
        massFlowRatex_0dpx_0staticHeadx_0Unique13__der(DYNX(W_,364), 995.586, 
        995.586, 0.001, 0.001, DYNX(DP_,106), DYNX(W_,377), DYNX(W_,345)*
        DYNX(DP_,109), DYNX(W_,329), DYNX(DP_,108), DYNX(W_,374), 4000.0, 1.0, 
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));
      PopModelContext();
      DYNX(DYNhelp,221) = divmacro(DYNX(W_,372),"pipe.flowModel.m_flow_nominal",
        DYNX(W_,371),"pipe.flowModel.dp_nominal");
      DYNX(DYNhelp,222) = divmacro(1.0,"1.0",DYNX(W_,371),"pipe.flowModel.dp_nominal");
      DYNX(DYNhelp,223) = DYNX(W_,342)*DYNX(W_,329);
      DYNX(DYNhelp,224) = divmacro(1.0,"1.0",DYNX(W_,342),"pipe.flowModel.nParallel");
      DYNX(DYNhelp,225) = 2.0*DYNX(W_,329);
      DYNX(DYNhelp,226) = divmacro(1.0,"1.0",DYNX(DYNhelp,225),"2.0*pipe.crossArea");
      SetMatrixLeading(J, 1, 1, 2, DYNX(DYNhelp,218)*DYNX(DYNhelp,217)*
        3.6159608511971846*DYNX(DYNhelp,216)-0.00010242371959608998);
      SetMatrixLeading(J, 1, 2, 2, DYNX(DYNhelp,218)*DYNX(DYNhelp,217)*(
        -3.6159608511971846)*DYNX(DYNhelp,216));
      SetMatrixLeading(J, 2, 1, 2,  -DYNX(DYNhelp,218)*DYNX(DYNhelp,217)*
        DYNX(DYNhelp,219));
      SetMatrixLeading(J, 2, 2, 2,  -(DYNX(DYNhelp,218)*DYNX(DYNhelp,217)*(-1.0)
        *DYNX(DYNhelp,219)+DYNX(DYNhelp,226)*DYNX(DYNhelp,224)*(-2.0)*homotopy(
        DYNX(DYNhelp,220), DYNX(DYNhelp,221))*DYNX(DYNhelp,223)));
    }
    SetVector(b, 1, (-3.6159608511971846)*DYNX(DYNhelp,184)*homotopy(0.0, 0.0));
    SetVector(y, 1, 0.0);
    SetVector(y, 2, 0.0);
    SolveLinearSystemOfEquations(J, b, y, 2);
    DYNX(W_,416) = GetVector(y, 1);
    DYNX(W_,428) = GetVector(y, 2);
    EndStaticLinearSystemOfEquations(J);
  }
  DYNX(W_,163) = 0.5*DYNX(W_,150)*DYNX(DYNhelp,209)*(DYNX(W_,428)-DYNX(W_,416));
  DYNX(W_,173) = DYNX(DYNhelp,218)*DYNX(DYNhelp,217)*(-2)*DYNX(W_,163);
  DYNX(W_,83) =  -homotopy(DYNX(W_,150)*(PushModelContext(1,"massFlowRate_dp_staticHead_Unique13:der(activeWall.pipe.flowModel.dps_fg[1], 995.586, 995.586, 0.001, 0.001, 174.0, activeWall.pipe.flowModel.diameters[1], 0.0, 0.5*(activeWall.pipe.crossAreas[1]+activeWall.pipe.crossAreas[2]), 0.5*(activeWall.pipe.roughnesses[1]+activeWall.pipe.roughnesses[2]), activeWall.pipe.flowModel.dp_small, 4000.0, der(activeWall.pipe.flowModel.dps_fg[1]), 0.0, 0.0, 0.0,...")
    massFlowRatex_0dpx_0staticHeadx_0Unique13__der(DYNX(W_,172), 995.586, 
    995.586, 0.001, 0.001, 174.0, DYNX(W_,186), 0.0, DYNX(DYNhelp,210), 
    DYNX(DYNhelp,211), DYNX(W_,183), 4000.0, DYNX(W_,173), 0.0, 0.0, 0.0, 0.0, 
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)), DYNX(DYNhelp,212)*DYNX(W_,181)*
    DYNX(W_,173));
  PopModelContext();
  DYNX(W_,223) = (-0.0010044335697769957)*DYNX(W_,83);
  DYNX(W_,232) = 3600*DYNX(W_,223);
  DYNX(W_,229) = (PushModelContext(1,"Modelica.Blocks.Tables.CombiTable1Ds.getDerTableValue(\npump.table_minMaxCharacteristics.tableID, \n1, \npump.table_minMaxCharacteristics.u, \npump.table_minMaxCharacteristics.tableOnFileRead, \nder(pump.table_minMaxCharacteristics.u))")
    Modelica_Blocks_Tables_CombiTable1Ds_getDerTableValue_M(DymStruc0_construct(
    (Integer)(DYNX(W_,266))), 1, DYNX(W_,231), DYNX(W_,267), DYNX(W_,232)));
  PopModelContext();
  DYNX(W_,355) =  -DYNX(W_,342)*DYNX(W_,329)*DYNX(W_,428);
  DYNX(W_,365) = DYNX(DYNhelp,226)*DYNX(DYNhelp,224)*(-2)*DYNX(W_,355);
   /* End of Equation Block */ 

}
DYNX(W_,160) = (-174.0)*DYNX(W_,82);
DYNX(W_,187) = (PushModelContext(1,"pressureLoss_m_flow_Unique9(activeWall.pipe.flowModel.m_flow_nominal/activeWall.pipe.flowModel.nParallel, activeWall.pipe.flowModel.rho_nominal, activeWall.pipe.flowModel.rho_nominal, activeWall.pipe.flowModel.mu_nominal, activeWall.pipe.flowModel.mu_nominal, 174.0, activeWall.pipe.flowModel.diameters[1], 0.5*(activeWall.pipe.crossAreas[1]+activeWall.pipe.crossAreas[2]), 0.5*(activeWall.pipe.ro...")
  pressureLossx_0mx_0flowx_0Unique9(divmacro(DYNX(W_,181),"activeWall.pipe.flowModel.m_flow_nominal",
  DYNX(W_,150),"activeWall.pipe.flowModel.nParallel"), DYNX(DP_,59), 
  DYNX(DP_,59), DYNX(DP_,60), DYNX(DP_,60), 174.0, DYNX(W_,186), 0.5*(
  DYNX(W_,128)+DYNX(W_,129)), 0.5*(DYNX(W_,132)+DYNX(W_,133)), divmacro(
  DYNX(W_,182),"activeWall.pipe.flowModel.m_flow_small",DYNX(W_,150),
  "activeWall.pipe.flowModel.nParallel"), 4000));
PopModelContext();
DYNX(W_,233) = (PushModelContext(1,"Modelica.Blocks.Tables.CombiTable1Ds.getTableValue(\npump.table_minMaxCharacteristics.tableID, \n2, \npump.table_minMaxCharacteristics.u, \npump.table_minMaxCharacteristics.tableOnFileRead)")
  Modelica_Blocks_Tables_CombiTable1Ds_getTableValue_M(DymStruc0_construct(
  (Integer)(DYNX(W_,266))), 2, DYNX(W_,231), DYNX(W_,267)));
PopModelContext();
DYNX(W_,340) = divmacro(divmacro((-0.0010044335697769957)*DYNX(W_,82),
  "(-0.0010044335697769957)*activeWall.port_b1.m_flow",DYNX(W_,329),
  "pipe.crossArea"),"(-0.0010044335697769957)*activeWall.port_b1.m_flow/pipe.crossArea",
  DYNX(DP_,105),"pipe.nParallel");
DYNX(W_,341) =  -divmacro(divmacro(0.0010044335697769957*DYNX(W_,82),
  "0.0010044335697769957*activeWall.port_b1.m_flow",DYNX(W_,329),
  "pipe.crossArea"),"0.0010044335697769957*activeWall.port_b1.m_flow/pipe.crossArea",
  DYNX(DP_,105),"pipe.nParallel");
DYNX(W_,352) =  -DYNX(W_,82)*DYNX(DP_,106);
DYNX(W_,378) = (PushModelContext(1,"pressureLoss_m_flow_Unique9(pipe.flowModel.m_flow_nominal/pipe.flowModel.nParallel, pipe.flowModel.rho_nominal, pipe.flowModel.rho_nominal, pipe.flowModel.mu_nominal, pipe.flowModel.mu_nominal, pipe.length, pipe.flowModel.diameters[1], pipe.crossArea, pipe.roughness, pipe.flowModel.m_flow_small/pipe.flowModel.nParallel, 4000)")
  pressureLossx_0mx_0flowx_0Unique9(divmacro(DYNX(W_,372),"pipe.flowModel.m_flow_nominal",
  DYNX(W_,342),"pipe.flowModel.nParallel"), DYNX(DP_,110), DYNX(DP_,110), 
  DYNX(DP_,111), DYNX(DP_,111), DYNX(DP_,106), DYNX(W_,377), DYNX(W_,329), 
  DYNX(DP_,108), divmacro(DYNX(W_,373),"pipe.flowModel.m_flow_small",
  DYNX(W_,342),"pipe.flowModel.nParallel"), 4000));
PopModelContext();
DYNX(W_,426) = 1E-005*DYNX(W_,415);
DYNX(W_,438) = 1E-005*DYNX(W_,427);
DYNX(X_,5) = DYNX(W_,108);
AssertModelica(DYNX(W_,415) >= 0.0,"activeWall.pipe.mediums[1].p >= 0.0", 
  StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd("Pressure (= ",
  Real2String2(DYNX(W_,415), true, 0))," Pa) of medium \""),"SimpleLiquidWater"),
  "\" is negative\n(Temperature = "),Real2String2(DYNX(X_,5), true, 0))," K)"));
PopAllMarks();
AssertModelica(GreaterEqual(DYNX(X_,5),"activeWall.pipe.mediums[1].T", 272.15,
  "272.15", 0) AND LessEqual(DYNX(X_,5),"activeWall.pipe.mediums[1].T", 403.15,
  "403.15", 1),"activeWall.pipe.mediums[1].T >= 272.15 and activeWall.pipe.mediums[1].T <= 403.15",
   StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(
  StringAdd("\nTemperature T (= ",Real2String2(DYNX(X_,5), true, 0)),
  " K) is not\nin the allowed range ("),"272.15")," K <= T <= "),"403.15"),
  " K)\nrequired from medium model \""),"SimpleLiquidWater"),"\".\n"));
PopAllMarks();
AssertModelica(DYNX(W_,427) >= 0.0,"activeWall.pipe.mediums[2].p >= 0.0", 
  StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd("Pressure (= ",
  Real2String2(DYNX(W_,427), true, 0))," Pa) of medium \""),"SimpleLiquidWater"),
  "\" is negative\n(Temperature = "),Real2String2(DYNX(X_,5), true, 0))," K)"));
PopAllMarks();
AssertModelica(GreaterEqual(DYNX(X_,5),"activeWall.pipe.mediums[1].T", 272.15,
  "272.15", 0) AND LessEqual(DYNX(X_,5),"activeWall.pipe.mediums[1].T", 403.15,
  "403.15", 1),"activeWall.pipe.mediums[1].T >= 272.15 and activeWall.pipe.mediums[1].T <= 403.15",
   StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(
  StringAdd("\nTemperature T (= ",Real2String2(DYNX(X_,5), true, 0)),
  " K) is not\nin the allowed range ("),"272.15")," K <= T <= "),"403.15"),
  " K)\nrequired from medium model \""),"SimpleLiquidWater"),"\".\n"));
PopAllMarks();
DYNX(X_,4) = DYNX(W_,57);
DYNX(X_,3) = DYNX(W_,57);
DYNX(X_,2) = DYNX(W_,57);
DYNX(X_,1) = DYNX(W_,57);
InitialSectionB
Init_=false;InitializeData(2);Init_=true;
EndInitialSection
AssertModelica(DYNX(W_,415) >= 0.0,"activeWall.pipe.mediums[1].p >= 0.0", 
  StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd("Pressure (= ",
  Real2String2(DYNX(W_,415), true, 0))," Pa) of medium \""),"SimpleLiquidWater"),
  "\" is negative\n(Temperature = "),Real2String2(DYNX(X_,5), true, 0))," K)"));
PopAllMarks();
AssertModelica(DYNX(W_,427) >= 0.0,"activeWall.pipe.mediums[2].p >= 0.0", 
  StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd("Pressure (= ",
  Real2String2(DYNX(W_,427), true, 0))," Pa) of medium \""),"SimpleLiquidWater"),
  "\" is negative\n(Temperature = "),Real2String2(DYNX(X_,5), true, 0))," K)"));
PopAllMarks();

OutputSection
AssertModelica(GreaterEqual(DYNX(X_,5),"activeWall.pipe.mediums[1].T", 272.15,
  "272.15", 0) AND LessEqual(DYNX(X_,5),"activeWall.pipe.mediums[1].T", 403.15,
  "403.15", 1),"activeWall.pipe.mediums[1].T >= 272.15 and activeWall.pipe.mediums[1].T <= 403.15",
   StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(
  StringAdd("\nTemperature T (= ",Real2String2(DYNX(X_,5), true, 0)),
  " K) is not\nin the allowed range ("),"272.15")," K <= T <= "),"403.15"),
  " K)\nrequired from medium model \""),"SimpleLiquidWater"),"\".\n"));
PopAllMarks();
AssertModelica(GreaterEqual(DYNX(X_,5),"activeWall.pipe.mediums[1].T", 272.15,
  "272.15", 0) AND LessEqual(DYNX(X_,5),"activeWall.pipe.mediums[1].T", 403.15,
  "403.15", 1),"activeWall.pipe.mediums[1].T >= 272.15 and activeWall.pipe.mediums[1].T <= 403.15",
   StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(
  StringAdd("\nTemperature T (= ",Real2String2(DYNX(X_,5), true, 0)),
  " K) is not\nin the allowed range ("),"272.15")," K <= T <= "),"403.15"),
  " K)\nrequired from medium model \""),"SimpleLiquidWater"),"\".\n"));
PopAllMarks();
(PushModelContext(1,"Modelica.Fluid.Utilities.checkBoundary(\"SimpleLiquidWater\", {\"SimpleLiquidWater\"}, true, true, boundary.X_in_internal, \"Boundary_pT\")")
  Modelica_Fluid_Utilities_checkBoundary("SimpleLiquidWater", StringTemporaryDense( 
  DymArrays0, 1, 1), true, true, RealTemporaryDense( &DYNX(W_,297), 1, 1), 
  "Boundary_pT"));
PopAllMarks();
(PushModelContext(1,"Modelica.Fluid.Utilities.checkBoundary(\"SimpleLiquidWater\", {\"SimpleLiquidWater\"}, true, true, boundary1.X_in_internal, \"Boundary_pT\")")
  Modelica_Fluid_Utilities_checkBoundary("SimpleLiquidWater", StringTemporaryDense( 
  DymArrays0, 1, 1), true, true, RealTemporaryDense( &DYNX(W_,323), 1, 1), 
  "Boundary_pT"));
PopAllMarks();

DynamicsSection
DYNX(W_,85) = 4184*(DYNX(X_,5)-273.15);
if (NewParameters_) {
DYNX(DYNhelp,227) =  -DYNX(W_,82) >= 0;
}
DYNX(W_,188) = IF DYNX(DYNhelp,227) THEN (-321540.4000000001)*DYNX(W_,82) ELSE 
   -DYNX(W_,85)*DYNX(W_,82);
DYNX(W_,84) = 4184*(DYNX(X_,5)-273.15);
DYNX(W_,189) = IF DYNX(DYNhelp,227) THEN  -DYNX(W_,85)*DYNX(W_,82) ELSE  -
  DYNX(W_,84)*DYNX(W_,82);
DYNX(W_,120) = DYNX(W_,188)-DYNX(W_,189);

 /* Linear system of equations to solve. */
/* Tag: simulation.linear[1] */
/* Introducing 11 common subexpressions used in 14 expressions */
/* Of the common subexpressions 11 are reals, 0 are integers, and 0
   are booleans. */
if (NewParameters_) {
DYNX(DYNhelp,228) = RealBmax(DYNX(W_,82), 0.0);
}
DYNX(DYNhelp,229) = 1.0-DYNX(Aux_,9);
DYNX(DYNhelp,230) = 1E-010*DYNX(DYNhelp,229);
DYNX(DYNhelp,231) = DYNX(Aux_,9)*DYNX(DYNhelp,228)+DYNX(DYNhelp,230);
if (NewParameters_) {
DYNX(DYNhelp,232) = RealBmax( -DYNX(W_,82), 0.0);
}
DYNX(DYNhelp,233) = DYNX(Aux_,9)*DYNX(DYNhelp,232)+DYNX(DYNhelp,230);
DYNX(DYNhelp,234) = DYNX(DYNhelp,233)+DYNX(DYNhelp,231);
DYNX(DYNhelp,235) = divmacro(1.0,"1.0",DYNX(DYNhelp,234),"stream_alpha1*max( -activeWall.port_b1.m_flow, 0.0)+1E-010*(1.0-stream_alpha1)+stream_alpha1*max(activeWall.port_b1.m_flow, 0.0)+1E-010*(1.0-stream_alpha1)");
DYNX(DYNhelp,236) = DYNX(DP_,2)*DYNX(DP_,109);
DYNX(DYNhelp,237) = DYNX(DYNhelp,231)*DYNX(DYNhelp,236);
DYNX(DYNhelp,238) = DYNX(DYNhelp,233)*DYNX(W_,84);
DYNX(W_,322) = RememberSimple_(DYNX(W_,322), 0);
SolveScalarLinearParametric(1.0+DYNX(DYNhelp,235)*(-1.0)*DYNX(DYNhelp,231),
  "1.0+(-1.0)*(stream_alpha1*max(activeWall.port_b1.m_flow, 0.0)+1E-010*(1.0-stream_alpha1))/(stream_alpha1*max( -activeWall.port_b1.m_flow, 0.0)+1E-010*(1.0-stream_alpha1)+stream_alpha1*max(activeWall.port_b1.m_flow, 0.0)+1E-010*(1.0-stream_alpha1))",
   273.15-DYNX(DYNhelp,235)*(273.15*DYNX(DYNhelp,231)-0.0002390057361376673*
  DYNX(DYNhelp,237)-0.0002390057361376673*DYNX(DYNhelp,238)),"273.15-(273.15*(stream_alpha1*max(activeWall.port_b1.m_flow, 0.0)+1E-010*(1.0-stream_alpha1))-0.0002390057361376673*((stream_alpha1*max(activeWall.port_b1.m_flow, 0.0)+1E-010*(1.0-stream_alpha1))*(system.g*pipe.height_ab))-0.0002390057361376673*((stream_alpha1*max( -activeWall.port_b1.m_flow, 0.0)+1E-010*(1.0-stream_alpha1))*activeWall.port_b1.h_outflow))/(stream_alpha1*max( -activeWall.port_b1...",
   DYNX(W_,322),"boundary1.T_in_internal");
DYNX(W_,312) = 4184*(DYNX(W_,322)-273.15);
DYNX(W_,325) = DYNX(W_,312)+DYNX(DYNhelp,236);
DYNX(Aux_,6) = DYNX(DYNhelp,235)*(DYNX(DYNhelp,238)+DYNX(DYNhelp,231)*
  DYNX(W_,325));
 /* End of Equation Block */ 

AssertModelica(GreaterEqual(DYNX(W_,322),"boundary1.T_in_internal", 272.15,
  "272.15", 2) AND LessEqual(DYNX(W_,322),"boundary1.T_in_internal", 403.15,
  "403.15", 3),"boundary1.T_in_internal >= 272.15 and boundary1.T_in_internal <= 403.15",
   StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(
  StringAdd("\nTemperature T (= ",Real2String2(DYNX(W_,322), true, 0)),
  " K) is not\nin the allowed range ("),"272.15")," K <= T <= "),"403.15"),
  " K)\nrequired from medium model \""),"SimpleLiquidWater"),"\".\n"));
PopAllMarks();
DYNX(W_,190) = IF DYNX(DYNhelp,227) THEN  -DYNX(W_,84)*DYNX(W_,82) ELSE  -
  DYNX(W_,325)*DYNX(W_,82);
DYNX(W_,121) = DYNX(W_,189)-DYNX(W_,190);

 /* Linear system of equations to solve. */
/* Tag: simulation.linear[2] */
/* Introducing 2 common subexpressions used in 2 expressions */
/* Of the common subexpressions 2 are reals, 0 are integers, and 0
   are booleans. */
DYNX(DYNhelp,239) = DYNX(W_,404)*DYNX(W_,209);
DYNX(DYNhelp,240) = DYNX(W_,391)*DYNX(W_,209);
DYNX(W_,72) = RememberSimple_(DYNX(W_,72), 1);
SolveScalarLinearParametric((-1.0)*DYNX(DYNhelp,239)-DYNX(DYNhelp,240)-1.0,
  "(-1.0)*(activeWall.Wall.HeatConda[3].G*activeWall.thermalResistor.R)-activeWall.Wall.HeatCondb[2].G*activeWall.thermalResistor.R-1.0",
    -(DYNX(X_,5)+DYNX(DYNhelp,239)*DYNX(X_,3)+DYNX(DYNhelp,240)*DYNX(X_,2)),
  " -(activeWall.pipe.mediums[1].T+activeWall.Wall.HeatConda[3].G*activeWall.thermalResistor.R*activeWall.Wall.Load[3].T+activeWall.Wall.HeatCondb[2].G*activeWall.thermalResistor.R*activeWall.Wall.Load[2].T)",
   DYNX(W_,72),"activeWall.Wall.portActiveLayer_a.T");
DYNX(W_,403) = DYNX(W_,72)-DYNX(X_,3);
DYNX(W_,74) = DYNX(W_,404)*DYNX(W_,403);
DYNX(W_,390) = DYNX(X_,2)-DYNX(W_,72);
DYNX(W_,73) =  -DYNX(W_,391)*DYNX(W_,390);
DYNX(W_,207) =  -(DYNX(W_,73)+DYNX(W_,74));
DYNX(W_,208) = DYNX(W_,209)*DYNX(W_,207);
 /* End of Equation Block */ 


 /* Linear system of equations to solve. */
/* Tag: simulation.linear[3] */
/* Introducing 0 common subexpressions and reusing 1 variables totally used in 1
   expressions */
/* Of the common subexpressions 1 are reals, 0 are integers, and 0
   are booleans. */
DYNX(F_,5) = RememberSimple_(DYNX(F_,5), 2);
SolveScalarLinearParametric(4184.0*(DYNX(W_,115)+DYNX(W_,114)),"4184.0*(activeWall.pipe.ms[2]+activeWall.pipe.ms[1])",
   DYNX(W_,120)+DYNX(W_,124)+DYNX(W_,121)+DYNX(W_,125)+DYNX(W_,207),
  "activeWall.pipe.Hb_flows[1]+activeWall.pipe.Wb_flows[1]+activeWall.pipe.Hb_flows[2]+activeWall.pipe.Wb_flows[2]+activeWall.thermalResistor.Q_flow",
   DYNX(F_,5),"der(activeWall.pipe.mediums[1].T)");
DYNX(W_,432) = 4184*DYNX(F_,5);
DYNX(W_,113) = DYNX(W_,115)*DYNX(W_,432);
DYNX(W_,420) = DYNX(W_,432);
DYNX(W_,112) = DYNX(W_,114)*DYNX(W_,420);
 /* End of Equation Block */ 


 /* Linear system of equations to solve. */
/* Tag: simulation.linear[4] */
DYNX(W_,59) = RememberSimple_(DYNX(W_,59), 3);
SolveScalarLinearParametric((-75.0)-DYNX(W_,397),"(-75.0)-activeWall.Wall.HeatCondb[4].G",
    -(DYNX(W_,397)*DYNX(X_,4)+75.0*DYNX(X_,0))," -(activeWall.Wall.HeatCondb[4].G*activeWall.Wall.Load[4].T+75.0*airload.T)",
   DYNX(W_,59),"activeWall.Wall.HeatConv1.port_b.T");
DYNX(W_,396) = DYNX(X_,4)-DYNX(W_,59);
DYNX(W_,79) = 75.0*(DYNX(X_,0)-DYNX(W_,59));
 /* End of Equation Block */ 

 /* Linear system of equations to solve. */
DYNX(F_,0) = RememberSimple_(DYNX(F_,0), 4);
SolveScalarLinearParametric(DYNX(W_,212)*DYNX(DP_,62),"airload.m*airload.c",  -
  DYNX(W_,79)," -activeWall.thermStarComb_inside.Therm.Q_flow", DYNX(F_,0),
  "der(airload.T)");
 /* End of Equation Block */ 


 /* Linear system of equations to solve. */
/* Tag: simulation.linear[5] */
DYNX(W_,394) = RememberSimple_(DYNX(W_,394), 5);
SolveScalarLinearParametric((-1.0)*DYNX(W_,395)-DYNX(W_,406),"(-1.0)*activeWall.Wall.HeatCondb[3].G-activeWall.Wall.HeatConda[4].G",
    -(DYNX(W_,406)*DYNX(X_,4)+DYNX(W_,395)*DYNX(X_,3))," -(activeWall.Wall.HeatConda[4].G*activeWall.Wall.Load[4].T+activeWall.Wall.HeatCondb[3].G*activeWall.Wall.Load[3].T)",
   DYNX(W_,394),"activeWall.Wall.HeatCondb[3].port_b.T");
DYNX(W_,405) = DYNX(W_,394)-DYNX(X_,4);
DYNX(W_,393) = DYNX(X_,3)-DYNX(W_,394);
DYNX(W_,392) = DYNX(W_,395)*DYNX(W_,393);
 /* End of Equation Block */ 

DYNX(W_,414) = DYNX(W_,79)+DYNX(W_,392);
 /* Linear system of equations to solve. */
DYNX(F_,4) = RememberSimple_(DYNX(F_,4), 6);
SolveScalarLinearParametric(DYNX(W_,413),"activeWall.Wall.Load[4].C", 
  DYNX(W_,414),"activeWall.Wall.Load[4].port.Q_flow", DYNX(F_,4),
  "der(activeWall.Wall.Load[4].T)");
 /* End of Equation Block */ 

DYNX(W_,412) = DYNX(W_,74)-DYNX(W_,392);
 /* Linear system of equations to solve. */
DYNX(F_,3) = RememberSimple_(DYNX(F_,3), 7);
SolveScalarLinearParametric(DYNX(W_,411),"activeWall.Wall.Load[3].C", 
  DYNX(W_,412),"activeWall.Wall.Load[3].port.Q_flow", DYNX(F_,3),
  "der(activeWall.Wall.Load[3].T)");
 /* End of Equation Block */ 


 /* Linear system of equations to solve. */
/* Tag: simulation.linear[6] */
DYNX(W_,388) = RememberSimple_(DYNX(W_,388), 8);
SolveScalarLinearParametric((-1.0)*DYNX(W_,389)-DYNX(W_,402),"(-1.0)*activeWall.Wall.HeatCondb[1].G-activeWall.Wall.HeatConda[2].G",
    -(DYNX(W_,389)*DYNX(X_,1)+DYNX(W_,402)*DYNX(X_,2))," -(activeWall.Wall.HeatCondb[1].G*activeWall.Wall.Load[1].T+activeWall.Wall.HeatConda[2].G*activeWall.Wall.Load[2].T)",
   DYNX(W_,388),"activeWall.Wall.HeatCondb[1].port_b.T");
DYNX(W_,387) = DYNX(X_,1)-DYNX(W_,388);
DYNX(W_,401) = DYNX(W_,388)-DYNX(X_,2);
DYNX(W_,386) = DYNX(W_,389)*DYNX(W_,387);
 /* End of Equation Block */ 

DYNX(W_,410) = DYNX(W_,386)+DYNX(W_,73);
 /* Linear system of equations to solve. */
DYNX(F_,2) = RememberSimple_(DYNX(F_,2), 9);
SolveScalarLinearParametric(DYNX(W_,409),"activeWall.Wall.Load[2].C", 
  DYNX(W_,410),"activeWall.Wall.Load[2].port.Q_flow", DYNX(F_,2),
  "der(activeWall.Wall.Load[2].T)");
 /* End of Equation Block */ 

DYNX(W_,398) = 250.0-DYNX(X_,1);
DYNX(W_,76) = DYNX(W_,400)*DYNX(W_,398);
DYNX(W_,408) = DYNX(W_,76)-DYNX(W_,386);
 /* Linear system of equations to solve. */
DYNX(F_,1) = RememberSimple_(DYNX(F_,1), 10);
SolveScalarLinearParametric(DYNX(W_,407),"activeWall.Wall.Load[1].C", 
  DYNX(W_,408),"activeWall.Wall.Load[1].port.Q_flow", DYNX(F_,1),
  "der(activeWall.Wall.Load[1].T)");
 /* End of Equation Block */ 


AcceptedSection1

AcceptedSection2
DYNX(Aux_,3) = DYNX(W_,325);
DYNX(Aux_,0) = DYNX(W_,325);
DYNX(Aux_,4) = DYNX(W_,85);
DYNX(Aux_,5) = DYNX(W_,84);
DYNX(DYNhelp,241) = 1.0-DYNX(Aux_,11);
DYNX(DYNhelp,242) = 1E-010*DYNX(DYNhelp,241);
DYNX(DYNhelp,243) = DYNX(Aux_,11)*DYNX(DYNhelp,228)+DYNX(DYNhelp,242);
DYNX(DYNhelp,244) = DYNX(Aux_,11)*DYNX(DYNhelp,232)+DYNX(DYNhelp,242);
DYNX(DYNhelp,245) = DYNX(DYNhelp,243)+DYNX(DYNhelp,244);
DYNX(DYNhelp,246) = divmacro(1.0,"1.0",DYNX(DYNhelp,245),"stream_alpha3*max(activeWall.port_b1.m_flow, 0.0)+1E-010*(1.0-stream_alpha3)+stream_alpha3*max( -activeWall.port_b1.m_flow, 0.0)+1E-010*(1.0-stream_alpha3)");
DYNX(Aux_,7) = DYNX(DYNhelp,246)*(DYNX(DYNhelp,243)*DYNX(W_,85)+321540.4000000001
  *DYNX(DYNhelp,244));
DYNX(W_,419) = 4184*(DYNX(X_,5)-273.15);
DYNX(W_,431) = 4184*(DYNX(X_,5)-273.15);
DYNX(W_,110) = DYNX(W_,114)*DYNX(W_,419);
DYNX(W_,111) = DYNX(W_,115)*DYNX(W_,431);
DYNX(W_,123) = DYNX(W_,113)-(DYNX(W_,121)+DYNX(W_,125));
DYNX(W_,122) = DYNX(W_,112)-(DYNX(W_,120)+DYNX(W_,124));
DYNX(W_,58) = DYNX(X_,0)-DYNX(W_,59);
DYNX(W_,64) = fabs(DYNX(W_,59)-DYNX(X_,0));

DYNX(Aux_,12) = (-1.7011101E-006)*DYNX(W_,69);


 /* Linear system of equations to solve. */
DYNX(Aux_,13) = RememberSimple_(DYNX(Aux_,13), 11);
SolveScalarLinearParametric(DYNX(Aux_,12),"Nonlin_5.", 0.0,"0.0", DYNX(Aux_,13),
  "Nonlin_4.");
 /* End of Equation Block */ 

{ /* Non-linear system of equations to solve. */
/* Tag: simulation.nonlinear[2] */
const char*const varnames_[]={"activeWall.thermStarComb_inside.Star.T"};
const double nominal_[]={300.0};
NonLinearSystemOfEquationsNH(Jacobian__, residue__, x__, 1, 0, 3, 9, 2, 
  DYNX(DYNhelp,247), 39, DYNX(did_->helpvari_vec,64), 23);
NonLinearSystemSave(DYNX(Aux_,13), 0);
NonLinearSystemSave(DYNX(W_,59), 1);
SetInitVectorNH(x__, 1, DYNX(W_,80), Remember_(DYNX(W_,80), 12));
Residues;
SetVector(residue__, 1, DYNX(W_,59)*DYNX(W_,59)*DYNX(W_,59)*DYNX(W_,59)-
  DYNX(W_,80)*DYNX(W_,80)*DYNX(W_,80)*DYNX(W_,80)-DYNX(Aux_,13));

Jacobian(Jacobian__)
MatrixZeros(Jacobian__);
SetMatrixLeading(Jacobian__, 1, 1, 1, (-4.0)*DYNX(W_,80)*DYNX(W_,80)*DYNX(W_,80));

SolveNonLinearSystemOfEquationsNH(Jacobian__, residue__, x__, 3, 
  "Tag: simulation.nonlinear[2]");
DYNX(W_,80) = GetVector(x__, 1);
EndNonLinearSystemOfEquationsNH(residue__, x__, 3);
 /* End of Non-Linear Equation Block */ }




DYNX(W_,147) = 273.15+0.0002390057361376673*DYNX(W_,325);
DYNX(W_,224) = IF  -DYNX(W_,82) > DYNX(DP_,66) THEN 350.0 ELSE IF  -DYNX(W_,82)
   <  -DYNX(DP_,66) THEN 273.15+0.0002390057361376673*DYNX(W_,85) ELSE IF 
  DYNX(DP_,66) > 0 THEN 311.575+divmacro((-5.9751434034416824E-005)*DYNX(W_,82)*
  (sqr(divmacro(DYNX(W_,82),"activeWall.port_b1.m_flow",DYNX(DP_,66),
  "pump.m_flow_small"))-3)*(DYNX(W_,85)-321540.4000000001),"(-5.9751434034416824E-005)*(activeWall.port_b1.m_flow*((activeWall.port_b1.m_flow/pump.m_flow_small)^2-3)*(activeWall.port_a1.h_outflow-321540.4000000001))",
  DYNX(DP_,66),"pump.m_flow_small")+0.00011950286806883365*DYNX(W_,85) ELSE 
  311.575+0.00011950286806883365*DYNX(W_,85);
DYNX(W_,225) = IF DYNX(W_,82) > DYNX(DP_,66) THEN 273.15+0.0002390057361376673*
  DYNX(W_,85) ELSE IF DYNX(W_,82) <  -DYNX(DP_,66) THEN 350.0 ELSE IF 
  DYNX(DP_,66) > 0 THEN 311.575+divmacro(5.9751434034416824E-005*DYNX(W_,82)*(
  sqr(divmacro(DYNX(W_,82),"activeWall.port_b1.m_flow",DYNX(DP_,66),
  "pump.m_flow_small"))-3)*(321540.4000000001-DYNX(W_,85)),"5.9751434034416824E-005*(activeWall.port_b1.m_flow*((activeWall.port_b1.m_flow/pump.m_flow_small)^2-3)*(321540.4000000001-activeWall.port_a1.h_outflow))",
  DYNX(DP_,66),"pump.m_flow_small")+0.00011950286806883365*DYNX(W_,85) ELSE 
  311.575+0.00011950286806883365*DYNX(W_,85);
DYNX(W_,303) = 4184*(DYNX(W_,322)-273.15);
DYNX(W_,309) = DYNX(W_,322)-273.15;
DYNX(W_,327) = DYNX(W_,84)-DYNX(DP_,2)*DYNX(DP_,109);
DYNX(W_,337) = 273.15+0.0002390057361376673*DYNX(W_,84);
DYNX(W_,339) = 273.15+0.0002390057361376673*DYNX(W_,312);
DYNX(W_,385) = 273.15+0.0002390057361376673*DYNX(Aux_,7);
DYNX(W_,425) = DYNX(X_,5)-273.15;
DYNX(W_,437) = DYNX(X_,5)-273.15;

DefaultSection
InitializeData(1)
EndTranslatedEquations

#include <dsblock6.c>

PreNonAliasNew(0)
StartNonAlias(0)
DeclareParameter("system.p_ambient", "Default ambient pressure [Pa|bar]", 0, 101325,\
 0.0,1E+100,100000.0,0,560)
DeclareParameter("system.T_ambient", "Default ambient temperature [K|degC]", 1, \
293.15, 0.0,1E+100,300.0,0,560)
DeclareParameter("system.g", "Constant gravity acceleration [m/s2]", 2, 9.80665,\
 0.0,0.0,0.0,0,560)
DeclareVariable("system.allowFlowReversal", "= false to restrict to design flow direction (port_a -> port_b) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("system.energyDynamics", "Default formulation of energy balances [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("system.massDynamics", "Default formulation of mass balances [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("system.substanceDynamics", "Default formulation of substance balances [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("system.traceDynamics", "Default formulation of trace substance balances [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("system.momentumDynamics", "Default formulation of momentum balances, if options available [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("system.m_flow_start", "Default start value for mass flow rates [kg/s]",\
 0, 0.0,0.0,0.0,0,513)
DeclareVariable("system.p_start", "Default start value for pressures [Pa|bar]", \
0.0, 0.0,1E+100,100000.0,0,513)
DeclareVariable("system.T_start", "Default start value for temperatures [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("system.use_eps_Re", "= true to determine turbulent region automatically using Reynolds number [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("system.m_flow_nominal", "Default nominal mass flow rate [kg/s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("system.eps_m_flow", "Regularization of zero flow for |m_flow| < eps_m_flow*m_flow_nominal [1]",\
 3, 0.0001, 0.0,1E+100,0.0,0,560)
DeclareParameter("system.dp_small", "Default small pressure drop for regularization of laminar and zero flow [Pa|bar]",\
 4, 1, 0.0,1E+100,100000.0,0,560)
DeclareParameter("system.m_flow_small", "Default small mass flow rate for regularization of laminar and zero flow [kg/s]",\
 5, 0.01, 0.0,1E+100,0.0,0,560)
DeclareParameter("activeWall.system.p_ambient", "Default ambient pressure [Pa|bar]",\
 6, 101325, 0.0,1E+100,100000.0,0,560)
DeclareVariable("activeWall.system.T_ambient", "Default ambient temperature [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareParameter("activeWall.system.g", "Constant gravity acceleration [m/s2]", 7,\
 9.80665, 0.0,0.0,0.0,0,560)
DeclareVariable("activeWall.system.allowFlowReversal", "= false to restrict to design flow direction (port_a -> port_b) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("activeWall.system.energyDynamics", "Default formulation of energy balances [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("activeWall.system.massDynamics", "Default formulation of mass balances [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("activeWall.system.substanceDynamics", "Default formulation of substance balances [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("activeWall.system.traceDynamics", "Default formulation of trace substance balances [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("activeWall.system.momentumDynamics", "Default formulation of momentum balances, if options available [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("activeWall.system.m_flow_start", "Default start value for mass flow rates [kg/s]",\
 0, 0.0,0.0,0.0,0,513)
DeclareVariable("activeWall.system.p_start", "Default start value for pressures [Pa|bar]",\
 0.0, 0.0,1E+100,100000.0,0,513)
DeclareVariable("activeWall.system.T_start", "Default start value for temperatures [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("activeWall.system.use_eps_Re", "= true to determine turbulent region automatically using Reynolds number [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("activeWall.system.m_flow_nominal", "Default nominal mass flow rate [kg/s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("activeWall.system.eps_m_flow", "Regularization of zero flow for |m_flow| < eps_m_flow*m_flow_nominal [1]",\
 8, 0.0001, 0.0,1E+100,0.0,0,560)
DeclareParameter("activeWall.system.dp_small", "Default small pressure drop for regularization of laminar and zero flow [Pa|bar]",\
 9, 1, 0.0,1E+100,100000.0,0,560)
DeclareParameter("activeWall.system.m_flow_small", "Default small mass flow rate for regularization of laminar and zero flow [kg/s]",\
 10, 0.01, 0.0,1E+100,0.0,0,560)
DeclareVariable("activeWall.outside", "Choose if the wall is an outside or an inside wall [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("activeWall.WallType.n", "Number of wall layers [:#(type=Integer)]",\
 4, 1.0,1E+100,0.0,0,517)
DeclareParameter("activeWall.WallType.d[1]", "Thickness of wall layers [m]", 11,\
 0.05, 0.0,0.0,0.0,0,560)
DeclareParameter("activeWall.WallType.d[2]", "Thickness of wall layers [m]", 12,\
 0.1, 0.0,0.0,0.0,0,560)
DeclareParameter("activeWall.WallType.d[3]", "Thickness of wall layers [m]", 13,\
 0.24, 0.0,0.0,0.0,0,560)
DeclareParameter("activeWall.WallType.d[4]", "Thickness of wall layers [m]", 14,\
 0.015, 0.0,0.0,0.0,0,560)
DeclareParameter("activeWall.WallType.rho[1]", "Density of wall layers [kg/m3|g/cm3]",\
 15, 1800.0, 0.0,1E+100,0.0,0,560)
DeclareParameter("activeWall.WallType.rho[2]", "Density of wall layers [kg/m3|g/cm3]",\
 16, 120.0, 0.0,1E+100,0.0,0,560)
DeclareParameter("activeWall.WallType.rho[3]", "Density of wall layers [kg/m3|g/cm3]",\
 17, 1000.0, 0.0,1E+100,0.0,0,560)
DeclareParameter("activeWall.WallType.rho[4]", "Density of wall layers [kg/m3|g/cm3]",\
 18, 1200.0, 0.0,1E+100,0.0,0,560)
DeclareParameter("activeWall.WallType.lambda[1]", "Thermal conductivity of wall layers [W/(m.K)]",\
 19, 1.0, 0.0,0.0,0.0,0,560)
DeclareParameter("activeWall.WallType.lambda[2]", "Thermal conductivity of wall layers [W/(m.K)]",\
 20, 0.035, 0.0,0.0,0.0,0,560)
DeclareParameter("activeWall.WallType.lambda[3]", "Thermal conductivity of wall layers [W/(m.K)]",\
 21, 0.5, 0.0,0.0,0.0,0,560)
DeclareParameter("activeWall.WallType.lambda[4]", "Thermal conductivity of wall layers [W/(m.K)]",\
 22, 0.51, 0.0,0.0,0.0,0,560)
DeclareParameter("activeWall.WallType.c[1]", "Specific heat capacity of wall layers [J/(kg.K)]",\
 23, 1000.0, 0.0,0.0,0.0,0,560)
DeclareParameter("activeWall.WallType.c[2]", "Specific heat capacity of wall layers [J/(kg.K)]",\
 24, 1030.0, 0.0,0.0,0.0,0,560)
DeclareParameter("activeWall.WallType.c[3]", "Specific heat capacity of wall layers [J/(kg.K)]",\
 25, 1000.0, 0.0,0.0,0.0,0,560)
DeclareParameter("activeWall.WallType.c[4]", "Specific heat capacity of wall layers [J/(kg.K)]",\
 26, 1000.0, 0.0,0.0,0.0,0,560)
DeclareParameter("activeWall.WallType.eps", "Emissivity of inner wall surface [1]",\
 27, 0.95, 0.0,0.0,0.0,0,560)
DeclareVariable("activeWall.wall_length", "Length of wall [m]", 10, 0.0,0.0,0.0,\
0,513)
DeclareVariable("activeWall.wall_height", "Height of wall [m]", 3, 0.0,1E+100,\
0.0,0,513)
DeclareParameter("activeWall.solar_absorptance", "Solar absorptance coefficient of outside wall surface",\
 28, 0.25, 0.0,0.0,0.0,0,560)
DeclareVariable("activeWall.Model", "Choose the model for calculation of heat convection at outside surface [:#(type=Integer)]",\
 1, 0.0,0.0,0.0,0,517)
DeclareParameter("activeWall.alpha_custom", "Custom alpha for convection (just for manual selection, not recommended) [W/(m2.K)]",\
 29, 25, 0.0,0.0,0.0,0,560)
DeclareParameter("activeWall.surfaceType.D", "", 30, 12.49, 0.0,0.0,0.0,0,560)
DeclareParameter("activeWall.surfaceType.E", "", 31, 4.065, 0.0,0.0,0.0,0,560)
DeclareParameter("activeWall.surfaceType.F", "", 32, 0.028, 0.0,0.0,0.0,0,560)
DeclareParameter("activeWall.ISOrientation", "Inside surface orientation [:#(type=Integer)]",\
 33, 1, 0.0,0.0,0.0,0,564)
DeclareVariable("activeWall.withWindow", "Choose if the wall has got a window (only outside walls) [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareParameter("activeWall.WindowType.Uw", "Thermal transmission coefficient of whole window: glass + frame [W/(m2.K)]",\
 34, 1.3, 0.0,0.0,0.0,0,560)
DeclareParameter("activeWall.WindowType.g", "coefficient of solar energy transmission",\
 35, 0.6, 0.0,0.0,0.0,0,560)
DeclareParameter("activeWall.WindowType.Emissivity", "Material emissivity [1]", 36,\
 0.9, 0.0,0.0,0.0,0,560)
DeclareParameter("activeWall.WindowType.frameFraction", "frame fraction from total fenestration area",\
 37, 0.2, 0.0,0.0,0.0,0,560)
DeclareParameter("activeWall.windowarea", "Area of window [m2]", 38, 2, 0.0,0.0,\
0.0,0,560)
DeclareVariable("activeWall.withSunblind", "enable support of sunblinding? [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareParameter("activeWall.Blinding", "blinding factor <=1", 39, 0, 0.0,0.0,\
0.0,0,560)
DeclareParameter("activeWall.Limit", "minimum specific total solar radiation in W/m2 for blinding becoming active",\
 40, 180, 0.0,0.0,0.0,0,560)
DeclareVariable("activeWall.withDoor", "Choose if the wall has got a door [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareParameter("activeWall.U_door", "Thermal transmission coefficient of door [W/(m2.K)]",\
 41, 1.8, 0.0,0.0,0.0,0,560)
DeclareParameter("activeWall.eps_door", "Solar emissivity of door material [1]",\
 42, 0.9, 0.0,0.0,0.0,0,560)
DeclareParameter("activeWall.door_height", "[m]", 43, 2, 0.0,0.0,0.0,0,560)
DeclareParameter("activeWall.door_width", "[m]", 44, 1, 0.0,0.0,0.0,0,560)
DeclareVariable("activeWall.clearance", "Wall clearance [m2]", 0, 0.0,0.0,0.0,0,513)
DeclareVariable("activeWall.withActiveLayer", "With an active layer [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareParameter("activeWall.connActiveLayer[1]", "Active layer to come between layers [:#(type=Integer)]",\
 45, 3, 0.0,0.0,0.0,0,564)
DeclareParameter("activeWall.connActiveLayer[2]", "Active layer to come between layers [:#(type=Integer)]",\
 46, 4, 0.0,0.0,0.0,0,564)
DeclareParameter("activeWall.pipe_diameter", "[m]", 47, 0.02, 0.0,0.0,0.0,0,560)
DeclareParameter("activeWall.pipe_thermal_resistance", "[K/W]", 48, 0, 0.0,0.0,\
0.0,0,560)
DeclareParameter("activeWall.T0", "Initial temperature [K|degC]", 49, 293.15, \
0.0,1E+100,300.0,0,560)
DeclareVariable("activeWall.Wall.h", "Height [m]", 3.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("activeWall.Wall.l", "Length [m]", 10.0, 0.0,0.0,0.0,0,513)
DeclareVariable("activeWall.Wall.clearance", "Area of clearance [m2]", 0.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("activeWall.Wall.wallType.n", "Number of wall layers [:#(type=Integer)]",\
 4, 1.0,1E+100,0.0,0,517)
DeclareVariable("activeWall.Wall.wallType.d[1]", "Thickness of wall layers [m]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("activeWall.Wall.wallType.d[2]", "Thickness of wall layers [m]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("activeWall.Wall.wallType.d[3]", "Thickness of wall layers [m]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("activeWall.Wall.wallType.d[4]", "Thickness of wall layers [m]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("activeWall.Wall.wallType.rho[1]", "Density of wall layers [kg/m3|g/cm3]",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("activeWall.Wall.wallType.rho[2]", "Density of wall layers [kg/m3|g/cm3]",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("activeWall.Wall.wallType.rho[3]", "Density of wall layers [kg/m3|g/cm3]",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("activeWall.Wall.wallType.rho[4]", "Density of wall layers [kg/m3|g/cm3]",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("activeWall.Wall.wallType.lambda[1]", "Thermal conductivity of wall layers [W/(m.K)]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("activeWall.Wall.wallType.lambda[2]", "Thermal conductivity of wall layers [W/(m.K)]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("activeWall.Wall.wallType.lambda[3]", "Thermal conductivity of wall layers [W/(m.K)]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("activeWall.Wall.wallType.lambda[4]", "Thermal conductivity of wall layers [W/(m.K)]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("activeWall.Wall.wallType.c[1]", "Specific heat capacity of wall layers [J/(kg.K)]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("activeWall.Wall.wallType.c[2]", "Specific heat capacity of wall layers [J/(kg.K)]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("activeWall.Wall.wallType.c[3]", "Specific heat capacity of wall layers [J/(kg.K)]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("activeWall.Wall.wallType.c[4]", "Specific heat capacity of wall layers [J/(kg.K)]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("activeWall.Wall.wallType.eps", "Emissivity of inner wall surface [1]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("activeWall.Wall.withConvection", "With convection model on side of port b [:#(type=Boolean)]",\
 50, true, 0.0,0.0,0.0,0,562)
DeclareVariable("activeWall.Wall.surfaceOrientation", "Surface orientation [:#(type=Integer)]",\
 1, 0.0,0.0,0.0,0,517)
DeclareParameter("activeWall.Wall.withRadExchange", "With radiation model on side of port b [:#(type=Boolean)]",\
 51, true, 0.0,0.0,0.0,0,562)
DeclareVariable("activeWall.Wall.withActiveLayer", "With an active layer [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("activeWall.Wall.connActiveLayer[1]", "Active layer to come between layers [:#(type=Integer)]",\
 2, 0.0,0.0,0.0,0,517)
DeclareParameter("activeWall.Wall.connActiveLayer[2]", "Active layer to come between layers [:#(type=Integer)]",\
 52, 3, 0.0,0.0,0.0,0,564)
DeclareVariable("activeWall.Wall.T0", "Initial temperature [K|degC]", 288.15, \
0.0,1E+100,300.0,0,513)
DeclareAlias2("activeWall.Wall.HeatConv1.Q_flow", "Heat flow rate from port_a -> port_b [W]",\
 "activeWall.thermStarComb_inside.Therm.Q_flow", 1, 5, 79, 0)
DeclareVariable("activeWall.Wall.HeatConv1.dT", "port_a.T - port_b.T [K,]", 0.0,\
 0.0,0.0,0.0,0,512)
DeclareAlias2("activeWall.Wall.HeatConv1.port_a.T", "Port temperature [K|degC]",\
 "airload.T", 1, 1, 0, 4)
DeclareAlias2("activeWall.Wall.HeatConv1.port_a.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "activeWall.thermStarComb_inside.Therm.Q_flow", 1, 5, 79, 132)
DeclareVariable("activeWall.Wall.HeatConv1.port_b.T", "Port temperature [K|degC]",\
 0.0, 0.0,1E+100,300.0,0,520)
DeclareAlias2("activeWall.Wall.HeatConv1.port_b.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "activeWall.thermStarComb_inside.Therm.Q_flow", -1, 5, 79, 132)
DeclareVariable("activeWall.Wall.HeatConv1.calcMethod", "Calculation Method [:#(type=Integer)]",\
 1, 0.0,0.0,0.0,0,517)
DeclareParameter("activeWall.Wall.HeatConv1.alpha_custom", "Constant heat transfer coefficient [W/(m2.K)]",\
 53, 2.5, 0.0,0.0,0.0,0,560)
DeclareVariable("activeWall.Wall.HeatConv1.surfaceOrientation", "Surface orientation [:#(type=Integer)]",\
 1, 0.0,0.0,0.0,0,517)
DeclareVariable("activeWall.Wall.HeatConv1.A", "Area of surface [m2]", 30.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("activeWall.Wall.HeatConv1.alpha", "variable heat transfer coefficient [W/(m2.K)]",\
 2.5, 0.0,0.0,0.0,0,513)
DeclareVariable("activeWall.Wall.HeatConv1.posDiff", "Positive temperature difference [degC]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareAlias2("activeWall.Wall.Star.T", "Port temperature [K|degC]", \
"activeWall.thermStarComb_inside.Star.T", 1, 5, 80, 4)
DeclareVariable("activeWall.Wall.Star.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareAlias2("activeWall.Wall.twoStar_RadEx.Therm.T", "Port temperature [K|degC]",\
 "activeWall.Wall.HeatConv1.port_b.T", 1, 5, 59, 4)
DeclareVariable("activeWall.Wall.twoStar_RadEx.Therm.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareAlias2("activeWall.Wall.twoStar_RadEx.Star.T", "Port temperature [K|degC]",\
 "activeWall.thermStarComb_inside.Star.T", 1, 5, 80, 4)
DeclareVariable("activeWall.Wall.twoStar_RadEx.Star.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("activeWall.Wall.twoStar_RadEx.A", "Area of radiation exchange [m2]",\
 30.0, 0.0,0.0,0.0,0,513)
DeclareVariable("activeWall.Wall.twoStar_RadEx.eps", "Emissivity [1]", 0.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("activeWall.Wall.port_a.T", "Port temperature [K|degC]", 250.0, \
0.0,1E+100,300.0,0,521)
DeclareAlias2("activeWall.Wall.port_a.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "activeWall.port_outside.Q_flow", 1, 5, 76, 132)
DeclareAlias2("activeWall.Wall.port_b.T", "Port temperature [K|degC]", \
"airload.T", 1, 1, 0, 4)
DeclareAlias2("activeWall.Wall.port_b.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "activeWall.thermStarComb_inside.Therm.Q_flow", 1, 5, 79, 132)
DeclareVariable("activeWall.Wall.A", "[m2]", 30.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("activeWall.Wall.portActiveLayer_a.T", "Port temperature [K|degC]",\
 0.0, 0.0,1E+100,300.0,0,520)
DeclareVariable("activeWall.Wall.portActiveLayer_a.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 0.0, 0.0,0.0,0.0,0,776)
DeclareAlias2("activeWall.Wall.portActiveLayer_b.T", "Port temperature [K|degC]",\
 "activeWall.Wall.portActiveLayer_a.T", 1, 5, 72, 4)
DeclareVariable("activeWall.Wall.portActiveLayer_b.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 0.0, 0.0,0.0,0.0,0,776)
DeclareVariable("activeWall.port_outside.T", "Port temperature [K|degC]", 250, \
0.0,1E+100,300.0,0,521)
DeclareVariable("activeWall.port_outside.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 0.0, 0.0,0.0,0.0,0,776)
DeclareAlias2("activeWall.heatStarToComb.thermStarComb.Therm.T", \
"Port temperature [K|degC]", "airload.T", 1, 1, 0, 4)
DeclareAlias2("activeWall.heatStarToComb.thermStarComb.Therm.Q_flow", \
"Heat flow rate (positive if flowing from outside into the component) [W]", \
"activeWall.thermStarComb_inside.Therm.Q_flow", 1, 5, 79, 132)
DeclareAlias2("activeWall.heatStarToComb.thermStarComb.Star.T", "Port temperature [K|degC]",\
 "activeWall.thermStarComb_inside.Star.T", 1, 5, 80, 4)
DeclareVariable("activeWall.heatStarToComb.thermStarComb.Star.Q_flow", \
"Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,777)
DeclareAlias2("activeWall.heatStarToComb.star.T", "Port temperature [K|degC]", \
"activeWall.thermStarComb_inside.Star.T", 1, 5, 80, 4)
DeclareVariable("activeWall.heatStarToComb.star.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareAlias2("activeWall.heatStarToComb.therm.T", "Port temperature [K|degC]", \
"airload.T", 1, 1, 0, 4)
DeclareAlias2("activeWall.heatStarToComb.therm.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "activeWall.thermStarComb_inside.Therm.Q_flow", -1, 5, 79, 132)
DeclareAlias2("activeWall.thermStarComb_inside.Therm.T", "Port temperature [K|degC]",\
 "airload.T", 1, 1, 0, 4)
DeclareVariable("activeWall.thermStarComb_inside.Therm.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 0.0, 0.0,0.0,0.0,0,776)
DeclareVariable("activeWall.thermStarComb_inside.Star.T", "Port temperature [K|degC]",\
 0.0, 0.0,1E+100,300.0,0,520)
DeclareVariable("activeWall.thermStarComb_inside.Star.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("activeWall.port_b1.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 0.0, -100000.0,100000.0,0.0,0,777)
DeclareVariable("activeWall.port_b1.der(m_flow)", "der(Mass flow rate from the connection point into the component) [kg/s2]",\
 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("activeWall.port_b1.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "activeWall.pipe.mediums[2].p", 1, 5, 427, 4)
DeclareVariable("activeWall.port_b1.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 0.0, -10000000000.0,10000000000.0,1000000.0,0,520)
DeclareAlias2("activeWall.port_a1.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "activeWall.port_b1.m_flow", -1, 5, 82, 132)
DeclareAlias2("activeWall.port_a1.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "activeWall.pipe.mediums[1].p", 1, 5, 415, 4)
DeclareVariable("activeWall.port_a1.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 83680.0, -10000000000.0,10000000000.0,1000000.0,0,520)
DeclareVariable("activeWall.pipe.allowFlowReversal", "= true to allow flow reversal, false restricts to design direction (port_a -> port_b) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareAlias2("activeWall.pipe.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "activeWall.port_b1.m_flow", -1, 5, 82, 132)
DeclareAlias2("activeWall.pipe.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "activeWall.pipe.mediums[1].p", 1, 5, 415, 4)
DeclareAlias2("activeWall.pipe.port_a.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "activeWall.port_a1.h_outflow", 1, 5, 85, 4)
DeclareAlias2("activeWall.pipe.port_b.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "activeWall.port_b1.m_flow", 1, 5, 82, 132)
DeclareAlias2("activeWall.pipe.port_b.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "activeWall.pipe.mediums[2].p", 1, 5, 427, 4)
DeclareAlias2("activeWall.pipe.port_b.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "activeWall.port_b1.h_outflow", 1, 5, 84, 4)
DeclareVariable("activeWall.pipe.port_a_exposesState", "= true if port_a exposes the state of a fluid volume [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareVariable("activeWall.pipe.port_b_exposesState", "= true if port_b.p exposes the state of a fluid volume [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareParameter("activeWall.pipe.showDesignFlowDirection", "= false to hide the arrow in the model icon [:#(type=Boolean)]",\
 54, true, 0.0,0.0,0.0,0,2610)
DeclareParameter("activeWall.pipe.nParallel", "Number of identical parallel pipes [1]",\
 55, 1, 1.0,1E+100,0.0,0,560)
DeclareVariable("activeWall.pipe.length", "Length [m]", 174.0, 0.0,0.0,0.0,0,513)
DeclareVariable("activeWall.pipe.isCircular", "= true if cross sectional area is circular [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("activeWall.pipe.diameter", "Diameter of circular pipe [m]", 0.0,\
 0.0,1E+100,0.0,0,513)
DeclareVariable("activeWall.pipe.crossArea", "Inner cross section area [m2]", \
0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("activeWall.pipe.perimeter", "Inner perimeter [m]", 0.0, \
0.0,0.0,0.0,0,513)
DeclareParameter("activeWall.pipe.roughness", "Average height of surface asperities (default: smooth steel pipe) [m]",\
 56, 2.5E-005, 0.0,1E+100,0.0,0,560)
DeclareVariable("activeWall.pipe.V", "volume size [m3]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("activeWall.pipe.height_ab", "Height(port_b) - Height(port_a) [m]",\
 0, 0.0,0.0,0.0,0,513)
DeclareVariable("activeWall.pipe.n", "Number of discrete volumes [:#(type=Integer)]",\
 2, 0.0,0.0,0.0,0,517)
DeclareVariable("activeWall.pipe.fluidVolumes[1]", "Discretized volume, determine in inheriting class [m3]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("activeWall.pipe.fluidVolumes[2]", "Discretized volume, determine in inheriting class [m3]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("activeWall.pipe.energyDynamics", "Formulation of energy balances [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("activeWall.pipe.massDynamics", "Formulation of mass balances [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("activeWall.pipe.substanceDynamics", "Formulation of substance balances [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("activeWall.pipe.traceDynamics", "Formulation of trace substance balances [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("activeWall.pipe.p_a_start", "Start value of pressure at port a [Pa|bar]",\
 100000.0, 0.0,100000000.0,100000.0,0,513)
DeclareVariable("activeWall.pipe.p_b_start", "Start value of pressure at port b [Pa|bar]",\
 100000.0, 0.0,100000000.0,100000.0,0,513)
DeclareVariable("activeWall.pipe.ps_start[1]", "Start value of pressure [Pa|bar]",\
 100000.0, 0.0,100000000.0,100000.0,0,513)
DeclareVariable("activeWall.pipe.ps_start[2]", "Start value of pressure [Pa|bar]",\
 100000.0, 0.0,100000000.0,100000.0,0,513)
DeclareVariable("activeWall.pipe.use_T_start", "Use T_start if true, otherwise h_start [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("activeWall.pipe.T_start", "Start value of temperature [K|degC]",\
 288.15, 1.0,10000.0,300.0,0,513)
DeclareVariable("activeWall.pipe.h_start", "Start value of specific enthalpy [J/kg]",\
 0.0, -10000000000.0,10000000000.0,1000000.0,0,513)
DeclareParameter("activeWall.pipe.X_start[1]", "Start value of mass fractions m_i/m [kg/kg]",\
 57, 1.0, 0.0,1.0,0.1,0,560)
DeclareVariable("activeWall.pipe.Us[1]", "Internal energy of fluid [J]", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("activeWall.pipe.Us[2]", "Internal energy of fluid [J]", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("activeWall.pipe.der(Us[1])", "der(Internal energy of fluid) [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("activeWall.pipe.der(Us[2])", "der(Internal energy of fluid) [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("activeWall.pipe.ms[1]", "Fluid mass [kg]", 0.0, 0.0,1E+100,0.0,\
0,513)
DeclareVariable("activeWall.pipe.ms[2]", "Fluid mass [kg]", 0.0, 0.0,1E+100,0.0,\
0,513)
DeclareVariable("activeWall.pipe.der(ms[1])", "der(Fluid mass) [kg/s]", 0.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("activeWall.pipe.der(ms[2])", "der(Fluid mass) [kg/s]", 0.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("activeWall.pipe.mb_flows[1]", "Mass flow rate, source or sink [kg/s]",\
 0.0, -100000.0,100000.0,0.0,0,513)
DeclareVariable("activeWall.pipe.mb_flows[2]", "Mass flow rate, source or sink [kg/s]",\
 0.0, -100000.0,100000.0,0.0,0,513)
DeclareVariable("activeWall.pipe.Hb_flows[1]", "Enthalpy flow rate, source or sink [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("activeWall.pipe.Hb_flows[2]", "Enthalpy flow rate, source or sink [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("activeWall.pipe.Qb_flows[1]", "Heat flow rate, source or sink [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("activeWall.pipe.Qb_flows[2]", "Heat flow rate, source or sink [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("activeWall.pipe.Wb_flows[1]", "Mechanical power, p*der(V) etc. [W]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("activeWall.pipe.Wb_flows[2]", "Mechanical power, p*der(V) etc. [W]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("activeWall.pipe.initialize_p", "= true to set up initial equations for pressure [:#(type=Boolean)]",\
 58, false, 0.0,0.0,0.0,0,2610)
DeclareVariable("activeWall.pipe.lengths[1]", "lengths of flow segments [m]", \
87.0, 0.0,0.0,0.0,0,513)
DeclareVariable("activeWall.pipe.lengths[2]", "lengths of flow segments [m]", \
87.0, 0.0,0.0,0.0,0,513)
DeclareVariable("activeWall.pipe.crossAreas[1]", "cross flow areas of flow segments [m2]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("activeWall.pipe.crossAreas[2]", "cross flow areas of flow segments [m2]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("activeWall.pipe.dimensions[1]", "hydraulic diameters of flow segments [m]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("activeWall.pipe.dimensions[2]", "hydraulic diameters of flow segments [m]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("activeWall.pipe.roughnesses[1]", "Average heights of surface asperities [m]",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("activeWall.pipe.roughnesses[2]", "Average heights of surface asperities [m]",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("activeWall.pipe.dheights[1]", "Differences in heights of flow segments [m]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("activeWall.pipe.dheights[2]", "Differences in heights of flow segments [m]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("activeWall.pipe.momentumDynamics", "Formulation of momentum balances [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("activeWall.pipe.m_flow_start", "Start value for mass flow rate [kg/s]",\
 0.0, -100000.0,100000.0,0.0,0,513)
DeclareVariable("activeWall.pipe.nNodes", "Number of discrete flow volumes [:#(type=Integer)]",\
 2, 1.0,1E+100,0.0,0,517)
DeclareVariable("activeWall.pipe.modelStructure", "Determines whether flow or volume models are present at the ports [:#(type=Modelica.Fluid.Types.ModelStructure)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("activeWall.pipe.useLumpedPressure", "=true to lump pressure states together [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("activeWall.pipe.nFM", "number of flow models in flowModel [:#(type=Integer)]",\
 1, 0.0,0.0,0.0,0,517)
DeclareVariable("activeWall.pipe.nFMDistributed", "[:#(type=Integer)]", 1, \
0.0,0.0,0.0,0,517)
DeclareVariable("activeWall.pipe.nFMLumped", "[:#(type=Integer)]", 1, 0.0,0.0,\
0.0,0,517)
DeclareVariable("activeWall.pipe.iLumped", "Index of control volume with representative state if useLumpedPressure [:#(type=Integer)]",\
 2, 0.0,0.0,0.0,0,517)
DeclareVariable("activeWall.pipe.useInnerPortProperties", "=true to take port properties for flow models from internal control volumes [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareAlias2("activeWall.pipe.state_a.p", "Absolute pressure of medium [Pa|bar]",\
 "activeWall.pipe.mediums[1].p", 1, 5, 415, 0)
DeclareVariable("activeWall.pipe.state_a.T", "Temperature of medium [K|degC]", \
350.0, 1.0,10000.0,300.0,0,513)
DeclareAlias2("activeWall.pipe.state_b.p", "Absolute pressure of medium [Pa|bar]",\
 "activeWall.pipe.mediums[2].p", 1, 5, 427, 0)
DeclareVariable("activeWall.pipe.state_b.T", "Temperature of medium [K|degC]", \
288.15, 1.0,10000.0,300.0,0,512)
DeclareAlias2("activeWall.pipe.statesFM[1].p", "Absolute pressure of medium [Pa|bar]",\
 "activeWall.pipe.mediums[1].p", 1, 5, 415, 0)
DeclareAlias2("activeWall.pipe.statesFM[1].T", "Temperature of medium [K|degC]",\
 "activeWall.pipe.mediums[1].T", 1, 1, 5, 0)
DeclareAlias2("activeWall.pipe.statesFM[2].p", "Absolute pressure of medium [Pa|bar]",\
 "activeWall.pipe.mediums[2].p", 1, 5, 427, 0)
DeclareAlias2("activeWall.pipe.statesFM[2].T", "Temperature of medium [K|degC]",\
 "activeWall.pipe.mediums[1].T", 1, 1, 5, 0)
DeclareVariable("activeWall.pipe.flowModel.from_dp", "= true, use m_flow = f(dp), otherwise dp = f(m_flow) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("activeWall.pipe.flowModel.n", "Number of discrete flow volumes [:#(type=Integer)]",\
 2, 0.0,0.0,0.0,0,517)
DeclareAlias2("activeWall.pipe.flowModel.states[1].p", "Absolute pressure of medium [Pa|bar]",\
 "activeWall.pipe.mediums[1].p", 1, 5, 415, 0)
DeclareAlias2("activeWall.pipe.flowModel.states[1].T", "Temperature of medium [K|degC]",\
 "activeWall.pipe.mediums[1].T", 1, 1, 5, 0)
DeclareAlias2("activeWall.pipe.flowModel.states[2].p", "Absolute pressure of medium [Pa|bar]",\
 "activeWall.pipe.mediums[2].p", 1, 5, 427, 0)
DeclareAlias2("activeWall.pipe.flowModel.states[2].T", "Temperature of medium [K|degC]",\
 "activeWall.pipe.mediums[1].T", 1, 1, 5, 0)
DeclareAlias2("activeWall.pipe.flowModel.vs[1]", "Mean velocities of fluid flow [m/s]",\
 "activeWall.pipe.vs[1]", 1, 5, 191, 0)
DeclareAlias2("activeWall.pipe.flowModel.vs[2]", "Mean velocities of fluid flow [m/s]",\
 "activeWall.pipe.vs[2]", 1, 5, 192, 0)
DeclareVariable("activeWall.pipe.flowModel.nParallel", "number of identical parallel flow devices [1]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("activeWall.pipe.flowModel.crossAreas[1]", "Cross flow areas at segment boundaries [m2]",\
 "activeWall.pipe.crossAreas[1]", 1, 5, 128, 0)
DeclareAlias2("activeWall.pipe.flowModel.crossAreas[2]", "Cross flow areas at segment boundaries [m2]",\
 "activeWall.pipe.crossAreas[2]", 1, 5, 129, 0)
DeclareAlias2("activeWall.pipe.flowModel.dimensions[1]", "Characteristic dimensions for fluid flow (diameters for pipe flow) [m]",\
 "activeWall.pipe.dimensions[1]", 1, 5, 130, 0)
DeclareAlias2("activeWall.pipe.flowModel.dimensions[2]", "Characteristic dimensions for fluid flow (diameters for pipe flow) [m]",\
 "activeWall.pipe.dimensions[2]", 1, 5, 131, 0)
DeclareAlias2("activeWall.pipe.flowModel.roughnesses[1]", "Average height of surface asperities [m]",\
 "activeWall.pipe.roughnesses[1]", 1, 5, 132, 0)
DeclareAlias2("activeWall.pipe.flowModel.roughnesses[2]", "Average height of surface asperities [m]",\
 "activeWall.pipe.roughnesses[2]", 1, 5, 133, 0)
DeclareVariable("activeWall.pipe.flowModel.dheights[1]", "Height(states[2:n]) - Height(states[1:n-1]) [m]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("activeWall.pipe.flowModel.g", "Constant gravity acceleration [m/s2]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("activeWall.pipe.flowModel.allowFlowReversal", "= true to allow flow reversal, false restricts to design direction (states[1] -> states[n+1]) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("activeWall.pipe.flowModel.momentumDynamics", "Formulation of momentum balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("activeWall.pipe.flowModel.m_flow_start", "Start value of mass flow rates [kg/s]",\
 0.0, -100000.0,100000.0,0.0,0,513)
DeclareVariable("activeWall.pipe.flowModel.p_a_start", "Start value for p[1] at design inflow [Pa|bar]",\
 100000.0, 0.0,100000000.0,100000.0,0,513)
DeclareVariable("activeWall.pipe.flowModel.p_b_start", "Start value for p[n+1] at design outflow [Pa|bar]",\
 100000.0, 0.0,100000000.0,100000.0,0,513)
DeclareVariable("activeWall.pipe.flowModel.m", "Number of flow segments [:#(type=Integer)]",\
 1, 0.0,0.0,0.0,0,517)
DeclareVariable("activeWall.pipe.flowModel.pathLengths[1]", "Lengths along flow path [m]",\
 174.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("activeWall.pipe.flowModel.m_flows[1]", "mass flow rates between states [kg/s]",\
 "activeWall.port_b1.m_flow", -1, 5, 82, 0)
DeclareVariable("activeWall.pipe.flowModel.Is[1]", "Momenta of flow segments [kg.m/s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("activeWall.pipe.flowModel.Ib_flows[1]", "Flow of momentum across boundaries [N]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("activeWall.pipe.flowModel.Fs_p[1]", "Pressure forces [N]", 0.0,\
 0.0,0.0,0.0,0,513)
DeclareVariable("activeWall.pipe.flowModel.der(Fs_p[1])", "der(Pressure forces) [N/s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("activeWall.pipe.flowModel.Fs_fg[1]", "Friction and gravity forces [N]",\
 "activeWall.pipe.flowModel.Fs_p[1]", -1, 5, 162, 0)
DeclareVariable("activeWall.pipe.flowModel.useUpstreamScheme", "= false to average upstream and downstream properties across flow segments [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("activeWall.pipe.flowModel.use_Ib_flows", "= true to consider differences in flow of momentum through boundaries [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("activeWall.pipe.flowModel.rhos[1]", "[kg/m3|g/cm3]", 995.586, \
0.0,100000.0,1.0,0,513)
DeclareVariable("activeWall.pipe.flowModel.rhos[2]", "[kg/m3|g/cm3]", 995.586, \
0.0,100000.0,1.0,0,513)
DeclareVariable("activeWall.pipe.flowModel.rhos_act[1]", "Actual density per segment [kg/m3|g/cm3]",\
 995.586, 0.0,100000.0,1.0,0,513)
DeclareVariable("activeWall.pipe.flowModel.mus[1]", "[Pa.s]", 0.001, 0.0,\
100000000.0,0.001,0,513)
DeclareVariable("activeWall.pipe.flowModel.mus[2]", "[Pa.s]", 0.001, 0.0,\
100000000.0,0.001,0,513)
DeclareVariable("activeWall.pipe.flowModel.mus_act[1]", "Actual viscosity per segment [Pa.s]",\
 0.001, 0.0,100000000.0,0.001,0,513)
DeclareVariable("activeWall.pipe.flowModel.dps_fg[1]", "pressure drop between states [Pa|bar]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("activeWall.pipe.flowModel.der(dps_fg[1])", "der(pressure drop between states) [Pa/s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("activeWall.pipe.flowModel.Re_turbulent", "Start of turbulent regime, depending on type of flow device [1]",\
 4000, 0.0,0.0,0.0,0,513)
DeclareVariable("activeWall.pipe.flowModel.show_Res", "= true, if Reynolds numbers are included for plotting [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("activeWall.pipe.flowModel.use_rho_nominal", "= true, if rho_nominal is used, otherwise computed from medium [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareParameter("activeWall.pipe.flowModel.rho_nominal", "Nominal density (e.g., rho_liquidWater = 995, rho_air = 1.2) [kg/m3|g/cm3]",\
 59, 995.586, 0.0,1E+100,0.0,0,2608)
DeclareVariable("activeWall.pipe.flowModel.use_mu_nominal", "= true, if mu_nominal is used, otherwise computed from medium [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareParameter("activeWall.pipe.flowModel.mu_nominal", "Nominal dynamic viscosity (e.g., mu_liquidWater = 1e-3, mu_air = 1.8e-5) [Pa.s]",\
 60, 0.001, 0.0,1E+100,0.0,0,2608)
DeclareVariable("activeWall.pipe.flowModel.pathLengths_internal[1]", \
"pathLengths used internally; to be defined by extending class [m]", 174.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("activeWall.pipe.flowModel.Res_turbulent_internal[1]", \
"Re_turbulent used internally; to be defined by extending class [1]", 4000, \
0.0,0.0,0.0,0,513)
DeclareVariable("activeWall.pipe.flowModel.dp_nominal", "Nominal pressure loss (only for nominal models) [Pa|bar]",\
 1, 0.0,1E+100,100000.0,0,513)
DeclareVariable("activeWall.pipe.flowModel.m_flow_nominal", "Nominal mass flow rate [kg/s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("activeWall.pipe.flowModel.m_flow_small", "Within regularization if |m_flows| < m_flow_small (may be wider for large discontinuities in static head) [kg/s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("activeWall.pipe.flowModel.dp_small", "Within regularization if |dp| < dp_small (may be wider for large discontinuities in static head) [Pa|bar]",\
 1, 0.0,1E+100,100000.0,0,2561)
DeclareVariable("activeWall.pipe.flowModel.constantPressureLossCoefficient", \
"= true if the pressure loss does not depend on fluid states [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("activeWall.pipe.flowModel.continuousFlowReversal", \
"= true if the pressure loss is continuous around zero flow [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("activeWall.pipe.flowModel.diameters[1]", "mean diameters between segments [m]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("activeWall.pipe.flowModel.dp_fric_nominal", "pressure loss for nominal conditions [Pa|bar]",\
 0.0, 0.0,1E+100,100000.0,0,2561)
DeclareAlias2("activeWall.pipe.m_flows[1]", "Mass flow rates of fluid across segment boundaries [kg/s]",\
 "activeWall.port_b1.m_flow", -1, 5, 82, 0)
DeclareAlias2("activeWall.pipe.m_flows[2]", "Mass flow rates of fluid across segment boundaries [kg/s]",\
 "activeWall.port_b1.m_flow", -1, 5, 82, 0)
DeclareAlias2("activeWall.pipe.m_flows[3]", "Mass flow rates of fluid across segment boundaries [kg/s]",\
 "activeWall.port_b1.m_flow", -1, 5, 82, 0)
DeclareVariable("activeWall.pipe.H_flows[1]", "Enthalpy flow rates of fluid across segment boundaries [W]",\
 0.0, -100000000.0,100000000.0,1000.0,0,512)
DeclareVariable("activeWall.pipe.H_flows[2]", "Enthalpy flow rates of fluid across segment boundaries [W]",\
 0.0, -100000000.0,100000000.0,1000.0,0,512)
DeclareVariable("activeWall.pipe.H_flows[3]", "Enthalpy flow rates of fluid across segment boundaries [W]",\
 0.0, -100000000.0,100000000.0,1000.0,0,512)
DeclareVariable("activeWall.pipe.vs[1]", "mean velocities in flow segments [m/s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("activeWall.pipe.vs[2]", "mean velocities in flow segments [m/s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("activeWall.pipe.pathLengths[1]", "Lengths along flow path [m]",\
 174.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("activeWall.pipe.dheightsFM[1]", "Differences in heights between flow segments [m]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareAlias2("activeWall.pipe.crossAreasFM[1]", "Cross flow areas of flow segments [m2]",\
 "activeWall.pipe.crossAreas[1]", 1, 5, 128, 1024)
DeclareAlias2("activeWall.pipe.crossAreasFM[2]", "Cross flow areas of flow segments [m2]",\
 "activeWall.pipe.crossAreas[2]", 1, 5, 129, 1024)
DeclareAlias2("activeWall.pipe.vsFM[1]", "Mean velocities in flow segments [m/s]",\
 "activeWall.pipe.vs[1]", 1, 5, 191, 1024)
DeclareAlias2("activeWall.pipe.vsFM[2]", "Mean velocities in flow segments [m/s]",\
 "activeWall.pipe.vs[2]", 1, 5, 192, 1024)
DeclareAlias2("activeWall.pipe.dimensionsFM[1]", "Hydraulic diameters of flow segments [m]",\
 "activeWall.pipe.dimensions[1]", 1, 5, 130, 1024)
DeclareAlias2("activeWall.pipe.dimensionsFM[2]", "Hydraulic diameters of flow segments [m]",\
 "activeWall.pipe.dimensions[2]", 1, 5, 131, 1024)
DeclareAlias2("activeWall.pipe.roughnessesFM[1]", "Average heights of surface asperities [m]",\
 "activeWall.pipe.roughnesses[1]", 1, 5, 132, 1024)
DeclareAlias2("activeWall.pipe.roughnessesFM[2]", "Average heights of surface asperities [m]",\
 "activeWall.pipe.roughnesses[2]", 1, 5, 133, 1024)
DeclareVariable("activeWall.pipe.use_HeatTransfer", "= true to use the HeatTransfer model [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareAlias2("activeWall.pipe.heatPorts[1].T", "Port temperature [K|degC]", \
"activeWall.pipe.mediums[1].T", 1, 1, 5, 4)
DeclareAlias2("activeWall.pipe.heatPorts[1].Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "activeWall.pipe.Qb_flows[1]", 1, 5, 122, 132)
DeclareAlias2("activeWall.pipe.heatPorts[2].T", "Port temperature [K|degC]", \
"activeWall.pipe.mediums[1].T", 1, 1, 5, 4)
DeclareAlias2("activeWall.pipe.heatPorts[2].Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "activeWall.pipe.Qb_flows[2]", 1, 5, 123, 132)
DeclareVariable("activeWall.pipe.heatTransfer.n", "Number of heat transfer segments [:#(type=Integer)]",\
 2, 0.0,0.0,0.0,0,517)
DeclareAlias2("activeWall.pipe.heatTransfer.states[1].p", "Absolute pressure of medium [Pa|bar]",\
 "activeWall.pipe.mediums[1].p", 1, 5, 415, 0)
DeclareAlias2("activeWall.pipe.heatTransfer.states[1].T", "Temperature of medium [K|degC]",\
 "activeWall.pipe.mediums[1].T", 1, 1, 5, 0)
DeclareAlias2("activeWall.pipe.heatTransfer.states[2].p", "Absolute pressure of medium [Pa|bar]",\
 "activeWall.pipe.mediums[2].p", 1, 5, 427, 0)
DeclareAlias2("activeWall.pipe.heatTransfer.states[2].T", "Temperature of medium [K|degC]",\
 "activeWall.pipe.mediums[1].T", 1, 1, 5, 0)
DeclareVariable("activeWall.pipe.heatTransfer.surfaceAreas[1]", "Heat transfer areas [m2]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("activeWall.pipe.heatTransfer.surfaceAreas[2]", "Heat transfer areas [m2]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("activeWall.pipe.heatTransfer.Q_flows[1]", "Heat flow rates [W]", \
"activeWall.pipe.Qb_flows[1]", 1, 5, 122, 0)
DeclareAlias2("activeWall.pipe.heatTransfer.Q_flows[2]", "Heat flow rates [W]", \
"activeWall.pipe.Qb_flows[2]", 1, 5, 123, 0)
DeclareVariable("activeWall.pipe.heatTransfer.use_k", "= true to use k value for thermal isolation [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("activeWall.pipe.heatTransfer.k", "Heat transfer coefficient to ambient [W/(m2.K)]",\
 0, 0.0,0.0,0.0,0,513)
DeclareVariable("activeWall.pipe.heatTransfer.T_ambient", "Ambient temperature [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareAlias2("activeWall.pipe.heatTransfer.heatPorts[1].T", "Port temperature [K|degC]",\
 "activeWall.pipe.mediums[1].T", 1, 1, 5, 4)
DeclareAlias2("activeWall.pipe.heatTransfer.heatPorts[1].Q_flow", \
"Heat flow rate (positive if flowing from outside into the component) [W]", \
"activeWall.pipe.Qb_flows[1]", 1, 5, 122, 132)
DeclareAlias2("activeWall.pipe.heatTransfer.heatPorts[2].T", "Port temperature [K|degC]",\
 "activeWall.pipe.mediums[1].T", 1, 1, 5, 4)
DeclareAlias2("activeWall.pipe.heatTransfer.heatPorts[2].Q_flow", \
"Heat flow rate (positive if flowing from outside into the component) [W]", \
"activeWall.pipe.Qb_flows[2]", 1, 5, 123, 132)
DeclareAlias2("activeWall.pipe.heatTransfer.Ts[1]", "Temperatures defined by fluid states [K|degC]",\
 "activeWall.pipe.mediums[1].T", 1, 1, 5, 0)
DeclareAlias2("activeWall.pipe.heatTransfer.Ts[2]", "Temperatures defined by fluid states [K|degC]",\
 "activeWall.pipe.mediums[1].T", 1, 1, 5, 0)
DeclareAlias2("activeWall.pipe.heatTransfer.vs[1]", "Mean velocities of fluid flow in segments [m/s]",\
 "activeWall.pipe.vs[1]", 1, 5, 191, 0)
DeclareAlias2("activeWall.pipe.heatTransfer.vs[2]", "Mean velocities of fluid flow in segments [m/s]",\
 "activeWall.pipe.vs[2]", 1, 5, 192, 0)
DeclareVariable("activeWall.pipe.heatTransfer.nParallel", "number of identical parallel flow devices [1]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("activeWall.pipe.heatTransfer.lengths[1]", "Lengths along flow path [m]",\
 87.0, 0.0,0.0,0.0,0,513)
DeclareVariable("activeWall.pipe.heatTransfer.lengths[2]", "Lengths along flow path [m]",\
 87.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("activeWall.pipe.heatTransfer.dimensions[1]", "Characteristic dimensions for fluid flow (diameter for pipe flow) [m]",\
 "activeWall.pipe.dimensions[1]", 1, 5, 130, 0)
DeclareAlias2("activeWall.pipe.heatTransfer.dimensions[2]", "Characteristic dimensions for fluid flow (diameter for pipe flow) [m]",\
 "activeWall.pipe.dimensions[2]", 1, 5, 131, 0)
DeclareAlias2("activeWall.pipe.heatTransfer.roughnesses[1]", "Average heights of surface asperities [m]",\
 "activeWall.pipe.roughnesses[1]", 1, 5, 132, 0)
DeclareAlias2("activeWall.pipe.heatTransfer.roughnesses[2]", "Average heights of surface asperities [m]",\
 "activeWall.pipe.roughnesses[2]", 1, 5, 133, 0)
DeclareVariable("activeWall.pipe.dxs[1]", "[1]", 0.5, 0.0,0.0,0.0,0,513)
DeclareVariable("activeWall.pipe.dxs[2]", "[1]", 0.5, 0.0,0.0,0.0,0,513)
DeclareVariable("activeWall.thermalResistor.Q_flow", "Heat flow rate from port_a -> port_b [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("activeWall.thermalResistor.dT", "port_a.T - port_b.T [K,]", 0.0,\
 0.0,0.0,0.0,0,512)
DeclareAlias2("activeWall.thermalResistor.port_a.T", "Port temperature [K|degC]",\
 "activeWall.Wall.portActiveLayer_a.T", 1, 5, 72, 4)
DeclareAlias2("activeWall.thermalResistor.port_a.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "activeWall.thermalResistor.Q_flow", 1, 5, 207, 132)
DeclareAlias2("activeWall.thermalResistor.port_b.T", "Port temperature [K|degC]",\
 "activeWall.pipe.mediums[1].T", 1, 1, 5, 4)
DeclareAlias2("activeWall.thermalResistor.port_b.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "activeWall.thermalResistor.Q_flow", -1, 5, 207, 132)
DeclareVariable("activeWall.thermalResistor.R", "Constant thermal resistance of material [K/W]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("thermStar_Demux.thermStarComb.Therm.T", "Port temperature [K|degC]",\
 "airload.T", 1, 1, 0, 4)
DeclareAlias2("thermStar_Demux.thermStarComb.Therm.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "activeWall.thermStarComb_inside.Therm.Q_flow", -1, 5, 79, 132)
DeclareAlias2("thermStar_Demux.thermStarComb.Star.T", "Port temperature [K|degC]",\
 "activeWall.thermStarComb_inside.Star.T", 1, 5, 80, 4)
DeclareVariable("thermStar_Demux.thermStarComb.Star.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareAlias2("thermStar_Demux.star.T", "Port temperature [K|degC]", \
"activeWall.thermStarComb_inside.Star.T", 1, 5, 80, 4)
DeclareVariable("thermStar_Demux.star.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareAlias2("thermStar_Demux.therm.T", "Port temperature [K|degC]", \
"airload.T", 1, 1, 0, 4)
DeclareAlias2("thermStar_Demux.therm.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "activeWall.thermStarComb_inside.Therm.Q_flow", 1, 5, 79, 132)
DeclareParameter("airload.rho", "Density of air [kg/m3|g/cm3]", 61, 1.19, 0.0,\
1E+100,0.0,0,560)
DeclareParameter("airload.c", "Specific heat capacity of air [J/(kg.K)]", 62, 1007,\
 0.0,0.0,0.0,0,560)
DeclareParameter("airload.V", "Volume of the room [m3]", 63, 10, 0.0,0.0,0.0,0,560)
DeclareState("airload.T", "Temperature of airload [K|degC]", 0, 290, 278.15,\
323.15,293.15,0,560)
DeclareDerivative("airload.der(T)", "der(Temperature of airload) [K/s]", 0.0, \
0.0,0.0,0.0,0,512)
DeclareAlias2("airload.port.T", "Port temperature [K|degC]", "airload.T", 1, 1, 0,\
 4)
DeclareAlias2("airload.port.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "activeWall.thermStarComb_inside.Therm.Q_flow", -1, 5, 79, 132)
DeclareVariable("airload.m", "[kg]", 0.0, 0.0,1E+100,0.0,0,2561)
DeclareVariable("tempOutside.port.T", "Port temperature [K|degC]", 250.0, 0.0,\
1E+100,300.0,0,521)
DeclareAlias2("tempOutside.port.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "activeWall.port_outside.Q_flow", -1, 5, 76, 132)
DeclareVariable("tempOutside.T", "[K]", 250.0, 0.0,0.0,0.0,0,513)
DeclareVariable("realExpression.y", "Value of Real output [K]", 250.0, 0.0,0.0,\
0.0,0,513)
DeclareVariable("pump.allowFlowReversal", "= false to simplify equations, assuming, but not enforcing, no flow reversal [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareAlias2("pump.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "activeWall.port_b1.m_flow", -1, 5, 82, 132)
DeclareVariable("pump.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 10000, 0.0,100000000.0,100000.0,0,521)
DeclareAlias2("pump.port_a.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "activeWall.port_a1.h_outflow", 1, 5, 85, 4)
DeclareAlias2("pump.port_b.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "activeWall.port_b1.m_flow", 1, 5, 82, 132)
DeclareAlias2("pump.port_b.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "activeWall.pipe.mediums[1].p", 1, 5, 415, 4)
DeclareVariable("pump.port_b.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 321540.4000000001, -10000000000.0,10000000000.0,1000000.0,0,521)
DeclareParameter("pump.dp_start", "Guess value of dp = port_a.p - port_b.p [Pa|Pa]",\
 64, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("pump.m_flow_start", "Guess value of m_flow = port_a.m_flow [kg/s]",\
 65, 0, -100000.0,100000.0,0.0,0,560)
DeclareParameter("pump.m_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 66, 0.01, -100000.0,100000.0,0.0,0,560)
DeclareVariable("pump.show_T", "= true, if temperatures at port_a and port_b are computed [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("pump.show_V_flow", "= true, if volume flow rate at inflowing port is computed [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareAlias2("pump.m_flow", "Mass flow rate in design flow direction [kg/s]", \
"activeWall.port_b1.m_flow", -1, 5, 82, 0)
DeclareVariable("pump.dp", "Pressure difference between port_a and port_b (= port_a.p - port_b.p) [Pa|Pa]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("pump.V_flow", "Volume flow rate at inflowing port (positive when flow from port_a to port_b) [m3/s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("pump.der(V_flow)", "der(Volume flow rate at inflowing port (positive when flow from port_a to port_b)) [m3/s2]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("pump.port_a_T", "Temperature close to port_a, if show_T = true [K|degC]",\
 288.15, 1.0,10000.0,300.0,0,512)
DeclareVariable("pump.port_b_T", "Temperature close to port_b, if show_T = true [K|degC]",\
 288.15, 1.0,10000.0,300.0,0,512)
DeclareVariable("_GlobalScope.Modelica.Media.Interfaces.PartialPureSubstance.X_default[1]",\
 "Default value for mass fractions of medium (for initialization) [kg/kg]", 1.0,\
 0.0,1.0,0.1,0,2561)
DeclareParameter("pump.MinMaxCharacteristics.minMaxHead[1, 1]", "V_flow | min Head | max Head",\
 67, 0.0, 0.0,0.0,0.0,0,560)
DeclareParameter("pump.MinMaxCharacteristics.minMaxHead[1, 2]", "V_flow | min Head | max Head",\
 68, 0.6, 0.0,0.0,0.0,0,560)
DeclareParameter("pump.MinMaxCharacteristics.minMaxHead[1, 3]", "V_flow | min Head | max Head",\
 69, 5.0, 0.0,0.0,0.0,0,560)
DeclareParameter("pump.MinMaxCharacteristics.minMaxHead[2, 1]", "V_flow | min Head | max Head",\
 70, 0.5, 0.0,0.0,0.0,0,560)
DeclareParameter("pump.MinMaxCharacteristics.minMaxHead[2, 2]", "V_flow | min Head | max Head",\
 71, 0.4, 0.0,0.0,0.0,0,560)
DeclareParameter("pump.MinMaxCharacteristics.minMaxHead[2, 3]", "V_flow | min Head | max Head",\
 72, 4.5, 0.0,0.0,0.0,0,560)
DeclareParameter("pump.MinMaxCharacteristics.minMaxHead[3, 1]", "V_flow | min Head | max Head",\
 73, 0.75, 0.0,0.0,0.0,0,560)
DeclareParameter("pump.MinMaxCharacteristics.minMaxHead[3, 2]", "V_flow | min Head | max Head",\
 74, 0.3, 0.0,0.0,0.0,0,560)
DeclareParameter("pump.MinMaxCharacteristics.minMaxHead[3, 3]", "V_flow | min Head | max Head",\
 75, 4.0, 0.0,0.0,0.0,0,560)
DeclareParameter("pump.MinMaxCharacteristics.minMaxHead[4, 1]", "V_flow | min Head | max Head",\
 76, 1.3, 0.0,0.0,0.0,0,560)
DeclareParameter("pump.MinMaxCharacteristics.minMaxHead[4, 2]", "V_flow | min Head | max Head",\
 77, 0.0, 0.0,0.0,0.0,0,560)
DeclareParameter("pump.MinMaxCharacteristics.minMaxHead[4, 3]", "V_flow | min Head | max Head",\
 78, 3.0, 0.0,0.0,0.0,0,560)
DeclareParameter("pump.MinMaxCharacteristics.minMaxHead[5, 1]", "V_flow | min Head | max Head",\
 79, 1.5, 0.0,0.0,0.0,0,560)
DeclareParameter("pump.MinMaxCharacteristics.minMaxHead[5, 2]", "V_flow | min Head | max Head",\
 80, 0.0, 0.0,0.0,0.0,0,560)
DeclareParameter("pump.MinMaxCharacteristics.minMaxHead[5, 3]", "V_flow | min Head | max Head",\
 81, 2.5, 0.0,0.0,0.0,0,560)
DeclareParameter("pump.MinMaxCharacteristics.minMaxHead[6, 1]", "V_flow | min Head | max Head",\
 82, 2.5, 0.0,0.0,0.0,0,560)
DeclareParameter("pump.MinMaxCharacteristics.minMaxHead[6, 2]", "V_flow | min Head | max Head",\
 83, 0.0, 0.0,0.0,0.0,0,560)
DeclareParameter("pump.MinMaxCharacteristics.minMaxHead[6, 3]", "V_flow | min Head | max Head",\
 84, 1.5, 0.0,0.0,0.0,0,560)
DeclareParameter("pump.MinMaxCharacteristics.minMaxHead[7, 1]", "V_flow | min Head | max Head",\
 85, 3.0, 0.0,0.0,0.0,0,560)
DeclareParameter("pump.MinMaxCharacteristics.minMaxHead[7, 2]", "V_flow | min Head | max Head",\
 86, 0.0, 0.0,0.0,0.0,0,560)
DeclareParameter("pump.MinMaxCharacteristics.minMaxHead[7, 3]", "V_flow | min Head | max Head",\
 87, 1.0, 0.0,0.0,0.0,0,560)
DeclareParameter("pump.MinMaxCharacteristics.minMaxHead[8, 1]", "V_flow | min Head | max Head",\
 88, 3.5, 0.0,0.0,0.0,0,560)
DeclareParameter("pump.MinMaxCharacteristics.minMaxHead[8, 2]", "V_flow | min Head | max Head",\
 89, 0.0, 0.0,0.0,0.0,0,560)
DeclareParameter("pump.MinMaxCharacteristics.minMaxHead[8, 3]", "V_flow | min Head | max Head",\
 90, 0.5, 0.0,0.0,0.0,0,560)
DeclareParameter("pump.MinMaxCharacteristics.minMaxHead[9, 1]", "V_flow | min Head | max Head",\
 91, 4.0, 0.0,0.0,0.0,0,560)
DeclareParameter("pump.MinMaxCharacteristics.minMaxHead[9, 2]", "V_flow | min Head | max Head",\
 92, 0.0, 0.0,0.0,0.0,0,560)
DeclareParameter("pump.MinMaxCharacteristics.minMaxHead[9, 3]", "V_flow | min Head | max Head",\
 93, 0.0, 0.0,0.0,0.0,0,560)
DeclareParameter("pump.MinMaxCharacteristics.minMaxHead[10, 1]", \
"V_flow | min Head | max Head", 94, 4.5, 0.0,0.0,0.0,0,560)
DeclareParameter("pump.MinMaxCharacteristics.minMaxHead[10, 2]", \
"V_flow | min Head | max Head", 95, 0.0, 0.0,0.0,0.0,0,560)
DeclareParameter("pump.MinMaxCharacteristics.minMaxHead[10, 3]", \
"V_flow | min Head | max Head", 96, 0.0, 0.0,0.0,0.0,0,560)
DeclareVariable("pump.ControlStrategy", "Control Strategy [:#(type=Integer)]", 1,\
 0.0,0.0,0.0,0,517)
DeclareParameter("pump.Head_max", "Set head for the control strategy [m]", 97, 3,\
 0.0,1E+100,0.0,0,560)
DeclareParameter("pump.V_flow_max", "Vmax in m3/h for the control strategy", 98,\
 2, 0.0,0.0,0.0,0,560)
DeclareVariable("pump.Head", "Pumping head [m]", 0, 0.0,1E+100,0.0,0,513)
DeclareVariable("pump.der(Head)", "der(Pumping head) [m/s]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("pump.table_minMaxCharacteristics.nout", "Number of outputs [:#(type=Integer)]",\
 2, 0.0,0.0,0.0,0,517)
DeclareVariable("pump.table_minMaxCharacteristics.u", "Connector of Real input signal",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("pump.table_minMaxCharacteristics.der(u)", "der(Connector of Real input signal)",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("pump.table_minMaxCharacteristics.y[1]", "Connector of Real output signals",\
 "pump.Head", 1, 5, 228, 0)
DeclareVariable("pump.table_minMaxCharacteristics.y[2]", "Connector of Real output signals",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("pump.table_minMaxCharacteristics.tableOnFile", "= true, if table is defined on file or in function usertab [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("pump.table_minMaxCharacteristics.table[1, 1]", "Table matrix (grid = first column; e.g., table=[0,2])",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("pump.table_minMaxCharacteristics.table[1, 2]", "Table matrix (grid = first column; e.g., table=[0,2])",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("pump.table_minMaxCharacteristics.table[1, 3]", "Table matrix (grid = first column; e.g., table=[0,2])",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("pump.table_minMaxCharacteristics.table[2, 1]", "Table matrix (grid = first column; e.g., table=[0,2])",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("pump.table_minMaxCharacteristics.table[2, 2]", "Table matrix (grid = first column; e.g., table=[0,2])",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("pump.table_minMaxCharacteristics.table[2, 3]", "Table matrix (grid = first column; e.g., table=[0,2])",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("pump.table_minMaxCharacteristics.table[3, 1]", "Table matrix (grid = first column; e.g., table=[0,2])",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("pump.table_minMaxCharacteristics.table[3, 2]", "Table matrix (grid = first column; e.g., table=[0,2])",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("pump.table_minMaxCharacteristics.table[3, 3]", "Table matrix (grid = first column; e.g., table=[0,2])",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("pump.table_minMaxCharacteristics.table[4, 1]", "Table matrix (grid = first column; e.g., table=[0,2])",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("pump.table_minMaxCharacteristics.table[4, 2]", "Table matrix (grid = first column; e.g., table=[0,2])",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("pump.table_minMaxCharacteristics.table[4, 3]", "Table matrix (grid = first column; e.g., table=[0,2])",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("pump.table_minMaxCharacteristics.table[5, 1]", "Table matrix (grid = first column; e.g., table=[0,2])",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("pump.table_minMaxCharacteristics.table[5, 2]", "Table matrix (grid = first column; e.g., table=[0,2])",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("pump.table_minMaxCharacteristics.table[5, 3]", "Table matrix (grid = first column; e.g., table=[0,2])",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("pump.table_minMaxCharacteristics.table[6, 1]", "Table matrix (grid = first column; e.g., table=[0,2])",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("pump.table_minMaxCharacteristics.table[6, 2]", "Table matrix (grid = first column; e.g., table=[0,2])",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("pump.table_minMaxCharacteristics.table[6, 3]", "Table matrix (grid = first column; e.g., table=[0,2])",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("pump.table_minMaxCharacteristics.table[7, 1]", "Table matrix (grid = first column; e.g., table=[0,2])",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("pump.table_minMaxCharacteristics.table[7, 2]", "Table matrix (grid = first column; e.g., table=[0,2])",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("pump.table_minMaxCharacteristics.table[7, 3]", "Table matrix (grid = first column; e.g., table=[0,2])",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("pump.table_minMaxCharacteristics.table[8, 1]", "Table matrix (grid = first column; e.g., table=[0,2])",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("pump.table_minMaxCharacteristics.table[8, 2]", "Table matrix (grid = first column; e.g., table=[0,2])",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("pump.table_minMaxCharacteristics.table[8, 3]", "Table matrix (grid = first column; e.g., table=[0,2])",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("pump.table_minMaxCharacteristics.table[9, 1]", "Table matrix (grid = first column; e.g., table=[0,2])",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("pump.table_minMaxCharacteristics.table[9, 2]", "Table matrix (grid = first column; e.g., table=[0,2])",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("pump.table_minMaxCharacteristics.table[9, 3]", "Table matrix (grid = first column; e.g., table=[0,2])",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("pump.table_minMaxCharacteristics.table[10, 1]", \
"Table matrix (grid = first column; e.g., table=[0,2])", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("pump.table_minMaxCharacteristics.table[10, 2]", \
"Table matrix (grid = first column; e.g., table=[0,2])", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("pump.table_minMaxCharacteristics.table[10, 3]", \
"Table matrix (grid = first column; e.g., table=[0,2])", 0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("pump.table_minMaxCharacteristics.verboseRead", \
"= true, if info message that file is loading is to be printed [:#(type=Boolean)]",\
 99, true, 0.0,0.0,0.0,0,562)
DeclareParameter("pump.table_minMaxCharacteristics.columns[1]", "Columns of table to be interpolated [:#(type=Integer)]",\
 100, 2, 0.0,0.0,0.0,0,564)
DeclareParameter("pump.table_minMaxCharacteristics.columns[2]", "Columns of table to be interpolated [:#(type=Integer)]",\
 101, 3, 0.0,0.0,0.0,0,564)
DeclareVariable("pump.table_minMaxCharacteristics.smoothness", "Smoothness of table interpolation [:#(type=Modelica.Blocks.Types.Smoothness)]",\
 1, 1.0,5.0,0.0,0,517)
DeclareVariable("pump.table_minMaxCharacteristics.tableID.id", "[:#(type=Integer)]",\
 0, 0.0,0.0,0.0,0,2565)
DeclareVariable("pump.table_minMaxCharacteristics.tableOnFileRead", \
"= 1, if table was successfully read from file", 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("pump.IsNight", "[:#(type=Boolean)]", true, 0.0,0.0,0.0,0,515)
DeclareVariable("boundary.nPorts", "Number of ports [:#(type=Integer)]", 1, \
0.0,0.0,0.0,0,517)
DeclareVariable("boundary.medium.p", "Absolute pressure of medium [Pa|bar]", \
10000.0, 0.0,1E+100,100000.0,0,513)
DeclareVariable("boundary.medium.h", "Specific enthalpy of medium [J/kg]", \
321540.4000000001, 0.0,0.0,0.0,0,513)
DeclareVariable("boundary.medium.d", "Density of medium [kg/m3|g/cm3]", 995.586,\
 0.0,100000.0,1.0,0,513)
DeclareVariable("boundary.medium.T", "Temperature of medium [K|degC]", 350.0, \
1.0,10000.0,300.0,0,513)
DeclareVariable("boundary.medium.X[1]", "Mass fractions (= (component mass)/total mass  m_i/m) [kg/kg]",\
 1.0, 0.0,1.0,0.1,0,513)
DeclareVariable("boundary.medium.u", "Specific internal energy of medium [J/kg]",\
 321540.4000000001, -100000000.0,100000000.0,1000000.0,0,513)
DeclareVariable("boundary.medium.R", "Gas constant (of mixture if applicable) [J/(kg.K)]",\
 0, 0.0,10000000.0,1000.0,0,513)
DeclareVariable("boundary.medium.MM", "Molar mass (of mixture or single fluid) [kg/mol]",\
 0.018015268, 0.001,0.25,0.032,0,513)
DeclareVariable("boundary.medium.state.p", "Absolute pressure of medium [Pa|bar]",\
 10000.0, 0.0,100000000.0,100000.0,0,513)
DeclareVariable("boundary.medium.state.T", "Temperature of medium [K|degC]", \
350.0, 1.0,10000.0,300.0,0,513)
DeclareVariable("boundary.medium.preferredMediumStates", "= true if StateSelect.prefer shall be used for the independent property variables of the medium [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("boundary.medium.standardOrderComponents", "If true, and reducedX = true, the last element of X will be computed from the other ones [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("boundary.medium.T_degC", "Temperature of medium in [degC] [degC;]",\
 76.85000000000002, 0.0,0.0,0.0,0,513)
DeclareVariable("boundary.medium.p_bar", "Absolute pressure of medium in [bar] [bar]",\
 0.1, 0.0,0.0,0.0,0,513)
DeclareAlias2("boundary.ports[1].m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "activeWall.port_b1.m_flow", 1, 5, 82, 132)
DeclareVariable("boundary.ports[1].p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 10000.0, 0.0,100000000.0,100000.0,0,521)
DeclareVariable("boundary.ports[1].h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 321540.4000000001, -10000000000.0,10000000000.0,1000000.0,0,521)
DeclareVariable("boundary.flowDirection", "Allowed flow direction [:#(type=Modelica.Fluid.Types.PortFlowDirection)]",\
 3, 1.0,3.0,0.0,0,2565)
DeclareVariable("boundary.use_p_in", "Get the pressure from the input connector [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("boundary.use_T_in", "Get the temperature from the input connector [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,1539)
DeclareVariable("boundary.use_X_in", "Get the composition from the input connector [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("boundary.use_C_in", "Get the trace substances from the input connector [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("boundary.p", "Fixed value of pressure [Pa|bar]", 10000, 0.0,\
100000000.0,100000.0,0,513)
DeclareVariable("boundary.T", "Fixed value of temperature [K|degC]", 293.15, 1.0,\
10000.0,300.0,0,513)
DeclareVariable("boundary.X[1]", "Fixed value of composition [kg/kg]", 1.0, 0.0,\
1.0,0.1,0,513)
DeclareVariable("boundary.T_in", "Prescribed boundary temperature [K]", 350.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("boundary.p_in_internal", "Needed to connect to conditional connector [Pa]",\
 10000.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("boundary.T_in_internal", "Needed to connect to conditional connector [K]",\
 350, 1.0,10000.0,300.0,0,2561)
DeclareVariable("boundary.X_in_internal[1]", "Needed to connect to conditional connector [1]",\
 1.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("realExpression1.y", "Value of Real output [K]", 350.0, 0.0,0.0,\
0.0,0,513)
DeclareVariable("boundary1.nPorts", "Number of ports [:#(type=Integer)]", 1, \
0.0,0.0,0.0,0,517)
DeclareVariable("boundary1.medium.p", "Absolute pressure of medium [Pa|bar]", \
10000.0, 0.0,1E+100,100000.0,0,513)
DeclareAlias2("boundary1.medium.h", "Specific enthalpy of medium [J/kg]", \
"boundary1.ports[1].h_outflow", 1, 5, 312, 0)
DeclareVariable("boundary1.medium.d", "Density of medium [kg/m3|g/cm3]", 995.586,\
 0.0,100000.0,1.0,0,513)
DeclareAlias2("boundary1.medium.T", "Temperature of medium [K|degC]", \
"boundary1.T_in_internal", 1, 5, 322, 0)
DeclareVariable("boundary1.medium.X[1]", "Mass fractions (= (component mass)/total mass  m_i/m) [kg/kg]",\
 1.0, 0.0,1.0,0.1,0,513)
DeclareVariable("boundary1.medium.u", "Specific internal energy of medium [J/kg]",\
 0.0, -100000000.0,100000000.0,1000000.0,0,512)
DeclareVariable("boundary1.medium.R", "Gas constant (of mixture if applicable) [J/(kg.K)]",\
 0, 0.0,10000000.0,1000.0,0,513)
DeclareVariable("boundary1.medium.MM", "Molar mass (of mixture or single fluid) [kg/mol]",\
 0.018015268, 0.001,0.25,0.032,0,513)
DeclareVariable("boundary1.medium.state.p", "Absolute pressure of medium [Pa|bar]",\
 10000.0, 0.0,100000000.0,100000.0,0,513)
DeclareAlias2("boundary1.medium.state.T", "Temperature of medium [K|degC]", \
"boundary1.T_in_internal", 1, 5, 322, 0)
DeclareVariable("boundary1.medium.preferredMediumStates", "= true if StateSelect.prefer shall be used for the independent property variables of the medium [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("boundary1.medium.standardOrderComponents", "If true, and reducedX = true, the last element of X will be computed from the other ones [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("boundary1.medium.T_degC", "Temperature of medium in [degC] [degC;]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("boundary1.medium.p_bar", "Absolute pressure of medium in [bar] [bar]",\
 0.1, 0.0,0.0,0.0,0,513)
DeclareAlias2("boundary1.ports[1].m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "activeWall.port_b1.m_flow", -1, 5, 82, 132)
DeclareVariable("boundary1.ports[1].p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 10000, 0.0,100000000.0,100000.0,0,521)
DeclareVariable("boundary1.ports[1].h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 0.0, -10000000000.0,10000000000.0,1000000.0,0,520)
DeclareVariable("boundary1.flowDirection", "Allowed flow direction [:#(type=Modelica.Fluid.Types.PortFlowDirection)]",\
 3, 1.0,3.0,0.0,0,2565)
DeclareVariable("boundary1.use_p_in", "Get the pressure from the input connector [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("boundary1.use_T_in", "Get the temperature from the input connector [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,1539)
DeclareVariable("boundary1.use_X_in", "Get the composition from the input connector [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("boundary1.use_C_in", "Get the trace substances from the input connector [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("boundary1.p", "Fixed value of pressure [Pa|bar]", 10000, 0.0,\
100000000.0,100000.0,0,513)
DeclareVariable("boundary1.T", "Fixed value of temperature [K|degC]", 573.15, \
1.0,10000.0,300.0,0,513)
DeclareVariable("boundary1.X[1]", "Fixed value of composition [kg/kg]", 1.0, 0.0,\
1.0,0.1,0,513)
DeclareAlias2("boundary1.T_in", "Prescribed boundary temperature [K]", \
"boundary1.T_in_internal", 1, 5, 322, 0)
DeclareVariable("boundary1.p_in_internal", "Needed to connect to conditional connector [Pa]",\
 10000.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("boundary1.T_in_internal", "Needed to connect to conditional connector [K]",\
 288.15, 1.0,10000.0,300.0,0,2560)
DeclareVariable("boundary1.X_in_internal[1]", "Needed to connect to conditional connector [1]",\
 1.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("pipe.allowFlowReversal", "= true to allow flow reversal, false restricts to design direction (port_a -> port_b) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareAlias2("pipe.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "activeWall.port_b1.m_flow", -1, 5, 82, 132)
DeclareAlias2("pipe.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "activeWall.pipe.mediums[2].p", 1, 5, 427, 4)
DeclareVariable("pipe.port_a.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 0.0, -10000000000.0,10000000000.0,1000000.0,0,520)
DeclareAlias2("pipe.port_b.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "activeWall.port_b1.m_flow", 1, 5, 82, 132)
DeclareVariable("pipe.port_b.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 10000.0, 0.0,100000000.0,100000.0,0,521)
DeclareVariable("pipe.port_b.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 0.0, -10000000000.0,10000000000.0,1000000.0,0,520)
DeclareParameter("pipe.port_a_exposesState", "= true if port_a exposes the state of a fluid volume [:#(type=Boolean)]",\
 102, false, 0.0,0.0,0.0,0,2610)
DeclareParameter("pipe.port_b_exposesState", "= true if port_b.p exposes the state of a fluid volume [:#(type=Boolean)]",\
 103, false, 0.0,0.0,0.0,0,2610)
DeclareParameter("pipe.showDesignFlowDirection", "= false to hide the arrow in the model icon [:#(type=Boolean)]",\
 104, true, 0.0,0.0,0.0,0,2610)
DeclareParameter("pipe.nParallel", "Number of identical parallel pipes [1]", 105,\
 1, 1.0,1E+100,0.0,0,560)
DeclareParameter("pipe.length", "Length [m]", 106, 1, 0.0,0.0,0.0,0,560)
DeclareVariable("pipe.isCircular", "= true if cross sectional area is circular [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareParameter("pipe.diameter", "Diameter of circular pipe [m]", 107, 0.5, 0.0,\
1E+100,0.0,0,560)
DeclareVariable("pipe.crossArea", "Inner cross section area [m2]", 0.0, 0.0,0.0,\
0.0,0,513)
DeclareVariable("pipe.perimeter", "Inner perimeter [m]", 0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("pipe.roughness", "Average height of surface asperities (default: smooth steel pipe) [m]",\
 108, 2.5E-005, 0.0,1E+100,0.0,0,560)
DeclareVariable("pipe.V", "volume size [m3]", 0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("pipe.height_ab", "Height(port_b) - Height(port_a) [m]", 109, 0,\
 0.0,0.0,0.0,0,560)
DeclareVariable("pipe.p_a_start", "Start value of pressure at port a [Pa|bar]", \
100000.0, 0.0,100000000.0,100000.0,0,513)
DeclareVariable("pipe.p_b_start", "Start value of pressure at port b [Pa|bar]", \
100000.0, 0.0,100000000.0,100000.0,0,513)
DeclareVariable("pipe.m_flow_start", "Start value for mass flow rate [kg/s]", \
0.0, -100000.0,100000.0,0.0,0,513)
DeclareVariable("pipe.flowModel.from_dp", "= true, use m_flow = f(dp), otherwise dp = f(m_flow) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("pipe.flowModel.n", "Number of discrete flow volumes [:#(type=Integer)]",\
 2, 0.0,0.0,0.0,0,517)
DeclareAlias2("pipe.flowModel.states[1].p", "Absolute pressure of medium [Pa|bar]",\
 "activeWall.pipe.mediums[2].p", 1, 5, 427, 0)
DeclareVariable("pipe.flowModel.states[1].T", "Temperature of medium [K|degC]", \
288.15, 1.0,10000.0,300.0,0,512)
DeclareVariable("pipe.flowModel.states[2].p", "Absolute pressure of medium [Pa|bar]",\
 10000.0, 0.0,100000000.0,100000.0,0,513)
DeclareVariable("pipe.flowModel.states[2].T", "Temperature of medium [K|degC]", \
288.15, 1.0,10000.0,300.0,0,512)
DeclareVariable("pipe.flowModel.vs[1]", "Mean velocities of fluid flow [m/s]", \
0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("pipe.flowModel.vs[2]", "Mean velocities of fluid flow [m/s]", \
0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("pipe.flowModel.nParallel", "number of identical parallel flow devices [1]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("pipe.flowModel.crossAreas[1]", "Cross flow areas at segment boundaries [m2]",\
 "pipe.crossArea", 1, 5, 329, 0)
DeclareAlias2("pipe.flowModel.crossAreas[2]", "Cross flow areas at segment boundaries [m2]",\
 "pipe.crossArea", 1, 5, 329, 0)
DeclareVariable("pipe.flowModel.dimensions[1]", "Characteristic dimensions for fluid flow (diameters for pipe flow) [m]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("pipe.flowModel.dimensions[2]", "Characteristic dimensions for fluid flow (diameters for pipe flow) [m]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("pipe.flowModel.roughnesses[1]", "Average height of surface asperities [m]",\
 "pipe.roughness", 1, 7, 108, 0)
DeclareAlias2("pipe.flowModel.roughnesses[2]", "Average height of surface asperities [m]",\
 "pipe.roughness", 1, 7, 108, 0)
DeclareAlias2("pipe.flowModel.dheights[1]", "Height(states[2:n]) - Height(states[1:n-1]) [m]",\
 "pipe.height_ab", 1, 7, 109, 0)
DeclareVariable("pipe.flowModel.g", "Constant gravity acceleration [m/s2]", 0.0,\
 0.0,0.0,0.0,0,513)
DeclareVariable("pipe.flowModel.allowFlowReversal", "= true to allow flow reversal, false restricts to design direction (states[1] -> states[n+1]) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("pipe.flowModel.momentumDynamics", "Formulation of momentum balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("pipe.flowModel.m_flow_start", "Start value of mass flow rates [kg/s]",\
 0.0, -100000.0,100000.0,0.0,0,513)
DeclareVariable("pipe.flowModel.p_a_start", "Start value for p[1] at design inflow [Pa|bar]",\
 100000.0, 0.0,100000000.0,100000.0,0,513)
DeclareVariable("pipe.flowModel.p_b_start", "Start value for p[n+1] at design outflow [Pa|bar]",\
 100000.0, 0.0,100000000.0,100000.0,0,513)
DeclareVariable("pipe.flowModel.m", "Number of flow segments [:#(type=Integer)]",\
 1, 0.0,0.0,0.0,0,517)
DeclareAlias2("pipe.flowModel.pathLengths[1]", "Lengths along flow path [m]", \
"pipe.length", 1, 7, 106, 0)
DeclareAlias2("pipe.flowModel.m_flows[1]", "mass flow rates between states [kg/s]",\
 "activeWall.port_b1.m_flow", -1, 5, 82, 0)
DeclareVariable("pipe.flowModel.Is[1]", "Momenta of flow segments [kg.m/s]", 0.0,\
 0.0,0.0,0.0,0,513)
DeclareVariable("pipe.flowModel.Ib_flows[1]", "Flow of momentum across boundaries [N]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("pipe.flowModel.Fs_p[1]", "Pressure forces [N]", 0.0, 0.0,0.0,\
0.0,0,513)
DeclareVariable("pipe.flowModel.der(Fs_p[1])", "der(Pressure forces) [N/s]", 0.0,\
 0.0,0.0,0.0,0,513)
DeclareAlias2("pipe.flowModel.Fs_fg[1]", "Friction and gravity forces [N]", \
"pipe.flowModel.Fs_p[1]", -1, 5, 354, 0)
DeclareVariable("pipe.flowModel.useUpstreamScheme", "= false to average upstream and downstream properties across flow segments [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("pipe.flowModel.use_Ib_flows", "= true to consider differences in flow of momentum through boundaries [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("pipe.flowModel.rhos[1]", "[kg/m3|g/cm3]", 995.586, 0.0,100000.0,\
1.0,0,513)
DeclareVariable("pipe.flowModel.rhos[2]", "[kg/m3|g/cm3]", 995.586, 0.0,100000.0,\
1.0,0,513)
DeclareVariable("pipe.flowModel.rhos_act[1]", "Actual density per segment [kg/m3|g/cm3]",\
 995.586, 0.0,100000.0,1.0,0,513)
DeclareVariable("pipe.flowModel.mus[1]", "[Pa.s]", 0.001, 0.0,100000000.0,0.001,\
0,513)
DeclareVariable("pipe.flowModel.mus[2]", "[Pa.s]", 0.001, 0.0,100000000.0,0.001,\
0,513)
DeclareVariable("pipe.flowModel.mus_act[1]", "Actual viscosity per segment [Pa.s]",\
 0.001, 0.0,100000000.0,0.001,0,513)
DeclareVariable("pipe.flowModel.dps_fg[1]", "pressure drop between states [Pa|bar]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("pipe.flowModel.der(dps_fg[1])", "der(pressure drop between states) [Pa/s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("pipe.flowModel.Re_turbulent", "Start of turbulent regime, depending on type of flow device [1]",\
 4000, 0.0,0.0,0.0,0,513)
DeclareVariable("pipe.flowModel.show_Res", "= true, if Reynolds numbers are included for plotting [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("pipe.flowModel.use_rho_nominal", "= true, if rho_nominal is used, otherwise computed from medium [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareParameter("pipe.flowModel.rho_nominal", "Nominal density (e.g., rho_liquidWater = 995, rho_air = 1.2) [kg/m3|g/cm3]",\
 110, 995.586, 0.0,1E+100,0.0,0,2608)
DeclareVariable("pipe.flowModel.use_mu_nominal", "= true, if mu_nominal is used, otherwise computed from medium [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareParameter("pipe.flowModel.mu_nominal", "Nominal dynamic viscosity (e.g., mu_liquidWater = 1e-3, mu_air = 1.8e-5) [Pa.s]",\
 111, 0.001, 0.0,1E+100,0.0,0,2608)
DeclareAlias2("pipe.flowModel.pathLengths_internal[1]", "pathLengths used internally; to be defined by extending class [m]",\
 "pipe.length", 1, 7, 106, 0)
DeclareVariable("pipe.flowModel.Res_turbulent_internal[1]", "Re_turbulent used internally; to be defined by extending class [1]",\
 4000, 0.0,0.0,0.0,0,513)
DeclareVariable("pipe.flowModel.dp_nominal", "Nominal pressure loss (only for nominal models) [Pa|bar]",\
 1, 0.0,1E+100,100000.0,0,513)
DeclareVariable("pipe.flowModel.m_flow_nominal", "Nominal mass flow rate [kg/s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("pipe.flowModel.m_flow_small", "Within regularization if |m_flows| < m_flow_small (may be wider for large discontinuities in static head) [kg/s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("pipe.flowModel.dp_small", "Within regularization if |dp| < dp_small (may be wider for large discontinuities in static head) [Pa|bar]",\
 1, 0.0,1E+100,100000.0,0,2561)
DeclareVariable("pipe.flowModel.constantPressureLossCoefficient", \
"= true if the pressure loss does not depend on fluid states [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("pipe.flowModel.continuousFlowReversal", "= true if the pressure loss is continuous around zero flow [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("pipe.flowModel.diameters[1]", "mean diameters between segments [m]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("pipe.flowModel.dp_fric_nominal", "pressure loss for nominal conditions [Pa|bar]",\
 0.0, 0.0,1E+100,100000.0,0,2561)
DeclareVariable("temperature.port.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 0, 0.0,100000.0,0.0,0,777)
DeclareAlias2("temperature.port.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "activeWall.pipe.mediums[2].p", 1, 5, 427, 4)
DeclareVariable("temperature.port.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 83680.0, -10000000000.0,10000000000.0,1000000.0,0,521)
DeclareVariable("_GlobalScope.Modelica.Media.Interfaces.PartialPureSubstance.X_default_Unique19[1]",\
 "Default value for mass fractions of medium (for initialization) [kg/kg]", 1.0,\
 0.0,1.0,0.1,0,2561)
DeclareAlias2("temperature.T", "Temperature in port medium [K|degC]", \
"boundary1.T_in_internal", 1, 5, 322, 0)
DeclareVariable("booleanExpression.y", "Value of Boolean output [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("temperature1.port.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 0, 0.0,100000.0,0.0,0,777)
DeclareAlias2("temperature1.port.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "activeWall.pipe.mediums[1].p", 1, 5, 415, 4)
DeclareVariable("temperature1.port.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 83680.0, -10000000000.0,10000000000.0,1000000.0,0,521)
DeclareVariable("temperature1.T", "Temperature in port medium [K|degC]", 0.0, \
0.0,1E+100,0.0,0,512)
DeclareVariable("activeWall.Wall.HeatCondb[1].Q_flow", "Heat flow rate from port_a -> port_b [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("activeWall.Wall.HeatCondb[1].dT", "port_a.T - port_b.T [K,]", \
0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("activeWall.Wall.HeatCondb[1].port_a.T", "Port temperature [K|degC]",\
 "activeWall.Wall.Load[1].T", 1, 1, 1, 4)
DeclareAlias2("activeWall.Wall.HeatCondb[1].port_a.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "activeWall.Wall.HeatCondb[1].Q_flow", 1, 5, 386, 132)
DeclareVariable("activeWall.Wall.HeatCondb[1].port_b.T", "Port temperature [K|degC]",\
 0.0, 0.0,1E+100,300.0,0,520)
DeclareAlias2("activeWall.Wall.HeatCondb[1].port_b.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "activeWall.Wall.HeatCondb[1].Q_flow", -1, 5, 386, 132)
DeclareVariable("activeWall.Wall.HeatCondb[1].G", "Constant thermal conductance of material [W/K]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("activeWall.Wall.HeatCondb[2].Q_flow", "Heat flow rate from port_a -> port_b [W]",\
 "activeWall.Wall.portActiveLayer_a.Q_flow", -1, 5, 73, 0)
DeclareVariable("activeWall.Wall.HeatCondb[2].dT", "port_a.T - port_b.T [K,]", \
0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("activeWall.Wall.HeatCondb[2].port_a.T", "Port temperature [K|degC]",\
 "activeWall.Wall.Load[2].T", 1, 1, 2, 4)
DeclareAlias2("activeWall.Wall.HeatCondb[2].port_a.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "activeWall.Wall.portActiveLayer_a.Q_flow", -1, 5, 73, 132)
DeclareAlias2("activeWall.Wall.HeatCondb[2].port_b.T", "Port temperature [K|degC]",\
 "activeWall.Wall.portActiveLayer_a.T", 1, 5, 72, 4)
DeclareAlias2("activeWall.Wall.HeatCondb[2].port_b.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "activeWall.Wall.portActiveLayer_a.Q_flow", 1, 5, 73, 132)
DeclareVariable("activeWall.Wall.HeatCondb[2].G", "Constant thermal conductance of material [W/K]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("activeWall.Wall.HeatCondb[3].Q_flow", "Heat flow rate from port_a -> port_b [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("activeWall.Wall.HeatCondb[3].dT", "port_a.T - port_b.T [K,]", \
0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("activeWall.Wall.HeatCondb[3].port_a.T", "Port temperature [K|degC]",\
 "activeWall.Wall.Load[3].T", 1, 1, 3, 4)
DeclareAlias2("activeWall.Wall.HeatCondb[3].port_a.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "activeWall.Wall.HeatCondb[3].Q_flow", 1, 5, 392, 132)
DeclareVariable("activeWall.Wall.HeatCondb[3].port_b.T", "Port temperature [K|degC]",\
 0.0, 0.0,1E+100,300.0,0,520)
DeclareAlias2("activeWall.Wall.HeatCondb[3].port_b.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "activeWall.Wall.HeatCondb[3].Q_flow", -1, 5, 392, 132)
DeclareVariable("activeWall.Wall.HeatCondb[3].G", "Constant thermal conductance of material [W/K]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("activeWall.Wall.HeatCondb[4].Q_flow", "Heat flow rate from port_a -> port_b [W]",\
 "activeWall.thermStarComb_inside.Therm.Q_flow", -1, 5, 79, 0)
DeclareVariable("activeWall.Wall.HeatCondb[4].dT", "port_a.T - port_b.T [K,]", \
0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("activeWall.Wall.HeatCondb[4].port_a.T", "Port temperature [K|degC]",\
 "activeWall.Wall.Load[4].T", 1, 1, 4, 4)
DeclareAlias2("activeWall.Wall.HeatCondb[4].port_a.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "activeWall.thermStarComb_inside.Therm.Q_flow", -1, 5, 79, 132)
DeclareAlias2("activeWall.Wall.HeatCondb[4].port_b.T", "Port temperature [K|degC]",\
 "activeWall.Wall.HeatConv1.port_b.T", 1, 5, 59, 4)
DeclareAlias2("activeWall.Wall.HeatCondb[4].port_b.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "activeWall.thermStarComb_inside.Therm.Q_flow", 1, 5, 79, 132)
DeclareVariable("activeWall.Wall.HeatCondb[4].G", "Constant thermal conductance of material [W/K]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("activeWall.Wall.HeatConda[1].Q_flow", "Heat flow rate from port_a -> port_b [W]",\
 "activeWall.port_outside.Q_flow", 1, 5, 76, 0)
DeclareVariable("activeWall.Wall.HeatConda[1].dT", "port_a.T - port_b.T [K,]", \
0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("activeWall.Wall.HeatConda[1].port_a.T", "Port temperature [K|degC]",\
 250.0, 0.0,1E+100,300.0,0,521)
DeclareAlias2("activeWall.Wall.HeatConda[1].port_a.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "activeWall.port_outside.Q_flow", 1, 5, 76, 132)
DeclareAlias2("activeWall.Wall.HeatConda[1].port_b.T", "Port temperature [K|degC]",\
 "activeWall.Wall.Load[1].T", 1, 1, 1, 4)
DeclareAlias2("activeWall.Wall.HeatConda[1].port_b.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "activeWall.port_outside.Q_flow", -1, 5, 76, 132)
DeclareVariable("activeWall.Wall.HeatConda[1].G", "Constant thermal conductance of material [W/K]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("activeWall.Wall.HeatConda[2].Q_flow", "Heat flow rate from port_a -> port_b [W]",\
 "activeWall.Wall.HeatCondb[1].Q_flow", 1, 5, 386, 0)
DeclareVariable("activeWall.Wall.HeatConda[2].dT", "port_a.T - port_b.T [K,]", \
0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("activeWall.Wall.HeatConda[2].port_a.T", "Port temperature [K|degC]",\
 "activeWall.Wall.HeatCondb[1].port_b.T", 1, 5, 388, 4)
DeclareAlias2("activeWall.Wall.HeatConda[2].port_a.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "activeWall.Wall.HeatCondb[1].Q_flow", 1, 5, 386, 132)
DeclareAlias2("activeWall.Wall.HeatConda[2].port_b.T", "Port temperature [K|degC]",\
 "activeWall.Wall.Load[2].T", 1, 1, 2, 4)
DeclareAlias2("activeWall.Wall.HeatConda[2].port_b.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "activeWall.Wall.HeatCondb[1].Q_flow", -1, 5, 386, 132)
DeclareVariable("activeWall.Wall.HeatConda[2].G", "Constant thermal conductance of material [W/K]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("activeWall.Wall.HeatConda[3].Q_flow", "Heat flow rate from port_a -> port_b [W]",\
 "activeWall.Wall.portActiveLayer_b.Q_flow", 1, 5, 74, 0)
DeclareVariable("activeWall.Wall.HeatConda[3].dT", "port_a.T - port_b.T [K,]", \
0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("activeWall.Wall.HeatConda[3].port_a.T", "Port temperature [K|degC]",\
 "activeWall.Wall.portActiveLayer_a.T", 1, 5, 72, 4)
DeclareAlias2("activeWall.Wall.HeatConda[3].port_a.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "activeWall.Wall.portActiveLayer_b.Q_flow", 1, 5, 74, 132)
DeclareAlias2("activeWall.Wall.HeatConda[3].port_b.T", "Port temperature [K|degC]",\
 "activeWall.Wall.Load[3].T", 1, 1, 3, 4)
DeclareAlias2("activeWall.Wall.HeatConda[3].port_b.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "activeWall.Wall.portActiveLayer_b.Q_flow", -1, 5, 74, 132)
DeclareVariable("activeWall.Wall.HeatConda[3].G", "Constant thermal conductance of material [W/K]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("activeWall.Wall.HeatConda[4].Q_flow", "Heat flow rate from port_a -> port_b [W]",\
 "activeWall.Wall.HeatCondb[3].Q_flow", 1, 5, 392, 0)
DeclareVariable("activeWall.Wall.HeatConda[4].dT", "port_a.T - port_b.T [K,]", \
0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("activeWall.Wall.HeatConda[4].port_a.T", "Port temperature [K|degC]",\
 "activeWall.Wall.HeatCondb[3].port_b.T", 1, 5, 394, 4)
DeclareAlias2("activeWall.Wall.HeatConda[4].port_a.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "activeWall.Wall.HeatCondb[3].Q_flow", 1, 5, 392, 132)
DeclareAlias2("activeWall.Wall.HeatConda[4].port_b.T", "Port temperature [K|degC]",\
 "activeWall.Wall.Load[4].T", 1, 1, 4, 4)
DeclareAlias2("activeWall.Wall.HeatConda[4].port_b.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "activeWall.Wall.HeatCondb[3].Q_flow", -1, 5, 392, 132)
DeclareVariable("activeWall.Wall.HeatConda[4].G", "Constant thermal conductance of material [W/K]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("activeWall.Wall.Load[1].C", "Heat capacity of element (= cp*m) [J/K]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareState("activeWall.Wall.Load[1].T", "Temperature of element [K|degC]", 1, \
0.0, 0.0,1E+100,300.0,0,544)
DeclareDerivative("activeWall.Wall.Load[1].der(T)", "der(Temperature of element) [K/s]",\
 0, 0.0,0.0,0.0,0,512)
DeclareAlias2("activeWall.Wall.Load[1].der_T", "Time derivative of temperature (= der(T)) [K/s]",\
 "activeWall.Wall.Load[1].der(T)", 1, 6, 1, 0)
DeclareAlias2("activeWall.Wall.Load[1].port.T", "Port temperature [K|degC]", \
"activeWall.Wall.Load[1].T", 1, 1, 1, 4)
DeclareVariable("activeWall.Wall.Load[1].port.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 0.0, 0.0,0.0,0.0,0,776)
DeclareVariable("activeWall.Wall.Load[2].C", "Heat capacity of element (= cp*m) [J/K]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareState("activeWall.Wall.Load[2].T", "Temperature of element [K|degC]", 2, \
0.0, 0.0,1E+100,300.0,0,544)
DeclareDerivative("activeWall.Wall.Load[2].der(T)", "der(Temperature of element) [K/s]",\
 0, 0.0,0.0,0.0,0,512)
DeclareAlias2("activeWall.Wall.Load[2].der_T", "Time derivative of temperature (= der(T)) [K/s]",\
 "activeWall.Wall.Load[2].der(T)", 1, 6, 2, 0)
DeclareAlias2("activeWall.Wall.Load[2].port.T", "Port temperature [K|degC]", \
"activeWall.Wall.Load[2].T", 1, 1, 2, 4)
DeclareVariable("activeWall.Wall.Load[2].port.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 0.0, 0.0,0.0,0.0,0,776)
DeclareVariable("activeWall.Wall.Load[3].C", "Heat capacity of element (= cp*m) [J/K]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareState("activeWall.Wall.Load[3].T", "Temperature of element [K|degC]", 3, \
0.0, 0.0,1E+100,300.0,0,544)
DeclareDerivative("activeWall.Wall.Load[3].der(T)", "der(Temperature of element) [K/s]",\
 0, 0.0,0.0,0.0,0,512)
DeclareAlias2("activeWall.Wall.Load[3].der_T", "Time derivative of temperature (= der(T)) [K/s]",\
 "activeWall.Wall.Load[3].der(T)", 1, 6, 3, 0)
DeclareAlias2("activeWall.Wall.Load[3].port.T", "Port temperature [K|degC]", \
"activeWall.Wall.Load[3].T", 1, 1, 3, 4)
DeclareVariable("activeWall.Wall.Load[3].port.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 0.0, 0.0,0.0,0.0,0,776)
DeclareVariable("activeWall.Wall.Load[4].C", "Heat capacity of element (= cp*m) [J/K]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareState("activeWall.Wall.Load[4].T", "Temperature of element [K|degC]", 4, \
0.0, 0.0,1E+100,300.0,0,544)
DeclareDerivative("activeWall.Wall.Load[4].der(T)", "der(Temperature of element) [K/s]",\
 0, 0.0,0.0,0.0,0,512)
DeclareAlias2("activeWall.Wall.Load[4].der_T", "Time derivative of temperature (= der(T)) [K/s]",\
 "activeWall.Wall.Load[4].der(T)", 1, 6, 4, 0)
DeclareAlias2("activeWall.Wall.Load[4].port.T", "Port temperature [K|degC]", \
"activeWall.Wall.Load[4].T", 1, 1, 4, 4)
DeclareVariable("activeWall.Wall.Load[4].port.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 0.0, 0.0,0.0,0.0,0,776)
DeclareVariable("activeWall.pipe.mediums[1].p", "Absolute pressure of medium [Pa|bar]",\
 0.0, 0.0,100000000.0,100000.0,0,513)
DeclareVariable("activeWall.pipe.mediums[1].der(p)", "der(Absolute pressure of medium) [Pa/s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("activeWall.pipe.mediums[1].h", "Specific enthalpy of medium [J/kg]",\
 "activeWall.port_a1.h_outflow", 1, 5, 85, 0)
DeclareVariable("activeWall.pipe.mediums[1].d", "Density of medium [kg/m3|g/cm3]",\
 995.586, 0.0,100000.0,1.0,0,513)
DeclareState("activeWall.pipe.mediums[1].T", "Temperature of medium [K|degC]", 5,\
 300.0, 1.0,10000.0,300.0,0,544)
DeclareDerivative("activeWall.pipe.mediums[1].der(T)", "der(Temperature of medium) [K/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("activeWall.pipe.mediums[1].X[1]", "Mass fractions (= (component mass)/total mass  m_i/m) [kg/kg]",\
 1.0, 0.0,1.0,0.1,0,513)
DeclareVariable("activeWall.pipe.mediums[1].u", "Specific internal energy of medium [J/kg]",\
 0.0, -100000000.0,100000000.0,1000000.0,0,512)
DeclareVariable("activeWall.pipe.mediums[1].der(u)", "der(Specific internal energy of medium) [m2/s3]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("activeWall.pipe.mediums[1].R", "Gas constant (of mixture if applicable) [J/(kg.K)]",\
 0, 0.0,10000000.0,1000.0,0,513)
DeclareVariable("activeWall.pipe.mediums[1].MM", "Molar mass (of mixture or single fluid) [kg/mol]",\
 0.018015268, 0.001,0.25,0.032,0,513)
DeclareAlias2("activeWall.pipe.mediums[1].state.p", "Absolute pressure of medium [Pa|bar]",\
 "activeWall.pipe.mediums[1].p", 1, 5, 415, 0)
DeclareAlias2("activeWall.pipe.mediums[1].state.T", "Temperature of medium [K|degC]",\
 "activeWall.pipe.mediums[1].T", 1, 1, 5, 0)
DeclareVariable("activeWall.pipe.mediums[1].preferredMediumStates", \
"= true if StateSelect.prefer shall be used for the independent property variables of the medium [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("activeWall.pipe.mediums[1].standardOrderComponents", \
"If true, and reducedX = true, the last element of X will be computed from the other ones [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("activeWall.pipe.mediums[1].T_degC", "Temperature of medium in [degC] [degC;]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("activeWall.pipe.mediums[1].p_bar", "Absolute pressure of medium in [bar] [bar]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("activeWall.pipe.mediums[2].p", "Absolute pressure of medium [Pa|bar]",\
 0.0, 0.0,100000000.0,100000.0,0,513)
DeclareVariable("activeWall.pipe.mediums[2].der(p)", "der(Absolute pressure of medium) [Pa/s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("activeWall.pipe.mediums[2].h", "Specific enthalpy of medium [J/kg]",\
 "activeWall.port_b1.h_outflow", 1, 5, 84, 0)
DeclareVariable("activeWall.pipe.mediums[2].d", "Density of medium [kg/m3|g/cm3]",\
 995.586, 0.0,100000.0,1.0,0,513)
DeclareAlias2("activeWall.pipe.mediums[2].T", "Temperature of medium [K|degC]", \
"activeWall.pipe.mediums[1].T", 1, 1, 5, 0)
DeclareAlias2("activeWall.pipe.mediums[2].der(T)", "der(Temperature of medium) [K/s]",\
 "activeWall.pipe.mediums[1].der(T)", 1, 6, 5, 0)
DeclareVariable("activeWall.pipe.mediums[2].X[1]", "Mass fractions (= (component mass)/total mass  m_i/m) [kg/kg]",\
 1.0, 0.0,1.0,0.1,0,513)
DeclareVariable("activeWall.pipe.mediums[2].u", "Specific internal energy of medium [J/kg]",\
 0.0, -100000000.0,100000000.0,1000000.0,0,512)
DeclareVariable("activeWall.pipe.mediums[2].der(u)", "der(Specific internal energy of medium) [m2/s3]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("activeWall.pipe.mediums[2].R", "Gas constant (of mixture if applicable) [J/(kg.K)]",\
 0, 0.0,10000000.0,1000.0,0,513)
DeclareVariable("activeWall.pipe.mediums[2].MM", "Molar mass (of mixture or single fluid) [kg/mol]",\
 0.018015268, 0.001,0.25,0.032,0,513)
DeclareAlias2("activeWall.pipe.mediums[2].state.p", "Absolute pressure of medium [Pa|bar]",\
 "activeWall.pipe.mediums[2].p", 1, 5, 427, 0)
DeclareAlias2("activeWall.pipe.mediums[2].state.T", "Temperature of medium [K|degC]",\
 "activeWall.pipe.mediums[1].T", 1, 1, 5, 0)
DeclareVariable("activeWall.pipe.mediums[2].preferredMediumStates", \
"= true if StateSelect.prefer shall be used for the independent property variables of the medium [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("activeWall.pipe.mediums[2].standardOrderComponents", \
"If true, and reducedX = true, the last element of X will be computed from the other ones [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("activeWall.pipe.mediums[2].T_degC", "Temperature of medium in [degC] [degC;]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("activeWall.pipe.mediums[2].p_bar", "Absolute pressure of medium in [bar] [bar]",\
 0.0, 0.0,0.0,0.0,0,513)
EndNonAlias(0)

#define DymolaHaveUpdateInitVars 1
#include <dsblock5.c>

DYMOLA_STATIC void UpdateInitVars(double*time, double* X_, double* XD_, double* U_, double* DP_, int IP_[], Dymola_bool LP_[], double* F_, double* Y_, double* W_, double QZ_[], double duser_[], int iuser_[], void*cuser_[],struct DYNInstanceData*did_,int initialCall) {
if (initialCall) DYNX(did_->xInitial_var, 1)=DYNX(W_,427);
else if (DYNHReject) DYNX(W_,427)=did_->xInitial_var2[1]; else did_->xInitial_var2[1]=
  DYNX(W_,427);
if (initialCall) DYNX(did_->xInitial_var, 0)=DYNX(W_,221);
else if (DYNHReject) DYNX(W_,221)=did_->xInitial_var2[0]; else did_->xInitial_var2[0]=
  DYNX(W_,221);
}
StartDataBlock
StartEqBlock
if (final_==2) {
DYNX(W_,388) = DYNX(W_,57);
DYNX(W_,394) = DYNX(W_,57);
DYNX(W_,59) = DYNX(W_,57);
DYNX(W_,72) = DYNX(W_,57);
DYNX(W_,80) = DYNX(W_,57);
}
DoRemember_(DYNX(Aux_,13), 0.0, 11);
DoRemember_(DYNX(W_,388), DYNX(W_,57), 8);
DoRemember_(DYNX(W_,394), DYNX(W_,57), 5);
DoRemember_(DYNX(W_,59), DYNX(W_,57), 3);
DoRemember_(DYNX(W_,72), DYNX(W_,57), 1);
DoRemember_(DYNX(W_,80), DYNX(W_,57), 12);
DoRemember_(DYNX(W_,322), 288.15, 0);
DoRemember_(DYNX(F_,1), 0, 10);
DoRemember_(DYNX(F_,2), 0, 9);
DoRemember_(DYNX(F_,3), 0, 7);
DoRemember_(DYNX(F_,4), 0, 6);
DoRemember_(DYNX(F_,5), 0.0, 2);
DoRemember_(DYNX(F_,0), 0.0, 4);
EndEqBlock
EndDataBlock
  BreakSectionStart(2);

  { /* Non-linear system of equations to solve. */
  /* Tag: homotopy-zero.nonlinear[1] */
  /* Introducing 14 common subexpressions used in 25 expressions */
  /* Of the common subexpressions 14 are reals, 0 are integers, and 0
     are booleans. */
  const char*const varnames_[]={"pump.dp", "activeWall.pipe.mediums[2].p"};
  const double nominal_[]={1e5, 100000.0};
  NonLinearSystemOfEquations(Jacobian__, residue__, x__, 2, 0, 1, 5, 
    DYNX(DYNhelp,8), 53, DYNX(did_->helpvari_vec,0), 24);
  SetInitVector(x__, 1, DYNX(W_,221), DYNX(DP_,64));
  SetInitVector(x__, 2, DYNX(W_,427), DYNX(W_,106));
  Residues;
    DYNX(W_,415) = 10000.0-DYNX(W_,221);
    DYNX(DYNhelp,61) = DYNX(W_,128)+DYNX(W_,129);
    DYNX(W_,162) = 0.5*DYNX(W_,150)*DYNX(DYNhelp,61)*(DYNX(W_,427)-DYNX(W_,415));
    DYNX(DYNhelp,62) = divmacro(1.0,"1.0",DYNX(W_,150),"activeWall.pipe.flowModel.nParallel");
    DYNX(DYNhelp,63) = divmacro(1.0,"1.0",DYNX(DYNhelp,61),"activeWall.pipe.crossAreas[1]+activeWall.pipe.crossAreas[2]");
    DYNX(W_,172) = DYNX(DYNhelp,63)*DYNX(DYNhelp,62)*(-2)*DYNX(W_,162);
    DYNX(W_,354) = DYNX(W_,342)*DYNX(W_,329)*(10000.0-DYNX(W_,427));
    DYNX(DYNhelp,64) = divmacro(1.0,"1.0",DYNX(W_,342),"pipe.flowModel.nParallel");
    DYNX(DYNhelp,65) = 2.0*DYNX(W_,329);
    DYNX(DYNhelp,66) = divmacro(1.0,"1.0",DYNX(DYNhelp,65),"2.0*pipe.crossArea");
    DYNX(W_,364) = DYNX(DYNhelp,66)*DYNX(DYNhelp,64)*(-2)*DYNX(W_,354);
    DYNX(DYNhelp,67) = divmacro(1.0,"1.0",DYNX(W_,180),"activeWall.pipe.flowModel.dp_nominal");
    DYNX(W_,82) =  -DYNX(DYNhelp,67)*DYNX(W_,181)*DYNX(W_,172);
    DYNX(W_,222) = (-0.0010044335697769957)*DYNX(W_,82);
    DYNX(W_,231) = DYNX(W_,222)*3600;
    DYNX(W_,228) = (PushModelContext(1,"Modelica.Blocks.Tables.CombiTable1Ds.getTableValue(\npump.table_minMaxCharacteristics.tableID, \n1, \npump.table_minMaxCharacteristics.u, \npump.table_minMaxCharacteristics.tableOnFileRead)")
      Modelica_Blocks_Tables_CombiTable1Ds_getTableValue_M(DymStruc0_construct(
      (Integer)(DYNX(W_,266))), 1, DYNX(W_,231), DYNX(W_,267)));
    PopModelContext();
  DYNX(DYNhelp,68) = DYNX(DP_,110)*DYNX(W_,345);
  DYNX(DYNhelp,69) = divmacro(1.0,"1.0",DYNX(W_,371),"pipe.flowModel.dp_nominal");
  SetVector(residue__, 1, DYNX(W_,228)+0.00010242371959608998*DYNX(W_,221));
  SetVector(residue__, 2, DYNX(W_,82)+DYNX(DYNhelp,69)*DYNX(W_,372)*(
    DYNX(W_,364)-DYNX(DYNhelp,68)*DYNX(DP_,109)));

  Jacobian(Jacobian__)
  MatrixZeros(Jacobian__);
  DYNX(DYNhelp,70) = DYNX(W_,150)*DYNX(DYNhelp,61);
  DYNX(DYNhelp,71) = DYNX(DYNhelp,70)*DYNX(W_,181)*(PushModelContext(1,
    "Modelica.Blocks.Tables.CombiTable1Ds.getDerTableValue(\npump.table_minMaxCharacteristics.tableID, \n1, \npump.table_minMaxCharacteristics.u, \npump.table_minMaxCharacteristics.tableOnFileRead, \n1.0)")
    Modelica_Blocks_Tables_CombiTable1Ds_getDerTableValue_M(DymStruc0_construct(
    (Integer)(DYNX(W_,266))), 1, DYNX(W_,231), DYNX(W_,267), 1.0));
  PopModelContext();
  DYNX(DYNhelp,72) = DYNX(DYNhelp,67)*DYNX(DYNhelp,63)*DYNX(DYNhelp,62)*
    3.6159608511971846*DYNX(DYNhelp,71);
  DYNX(DYNhelp,73) = DYNX(DYNhelp,67)*DYNX(DYNhelp,63)*DYNX(DYNhelp,62)*(-1.0)*
    DYNX(DYNhelp,70)*DYNX(W_,181);
  DYNX(DYNhelp,74) = DYNX(W_,372)*DYNX(W_,342)*DYNX(W_,329);
  SetMatrixLeading(Jacobian__, 1, 1, 2, 0.00010242371959608998-DYNX(DYNhelp,72));
  SetMatrixLeading(Jacobian__, 1, 2, 2,  -DYNX(DYNhelp,72));
  SetMatrixLeading(Jacobian__, 2, 1, 2,  -DYNX(DYNhelp,73));
  SetMatrixLeading(Jacobian__, 2, 2, 2, DYNX(DYNhelp,69)*DYNX(DYNhelp,66)*
    DYNX(DYNhelp,64)*2.0*DYNX(DYNhelp,74)-DYNX(DYNhelp,73));

  SolveNonLinearSystemOfEquationsInit(Jacobian__, residue__, x__,"Tag: homotopy-zero.nonlinear[1]");
  DYNX(W_,221) = GetVector(x__, 1);
  DYNX(W_,427) = GetVector(x__, 2);
  EndNonLinearSystemOfEquationsInit(residue__, x__, 1);
   /* End of Non-Linear Equation Block */ }



  BreakSectionEnd()
  BreakSectionStart(4);

   /* Linear system of equations to solve. */
  /* Tag: homotopy-zero.linear[1] */
  /* Introducing 12 common subexpressions used in 32 expressions */
  /* Of the common subexpressions 12 are reals, 0 are integers, and 0
     are booleans. */
  /* Automatic tearing of linear system of 10 simultaneous equations
  gave a linear system of 2 equations for numerical solution.*/
  {
    const char*const varnames_[]={"activeWall.pipe.mediums[1].der(p)", 
      "activeWall.pipe.mediums[2].der(p)"};
    const double nominal_[]={1, 1};
    DidLinearSystemOfEquations(J, b, y, 2, DYNX(DYNhelp,148), 24, 
      DYNX(did_->helpvari_vec,48), 8);
    /* Parameter dependent Jacobian */
    if (NewParametersJac) SetNeedFactor(J);
    if (NeedFactor(J)) {
      MatrixZeros(J);
      DYNX(DYNhelp,172) = DYNX(W_,128)+DYNX(W_,129);
      DYNX(DYNhelp,173) = DYNX(W_,150)*DYNX(DYNhelp,172);
      DYNX(DYNhelp,174) = DYNX(W_,181)*(PushModelContext(1,"Modelica.Blocks.Tables.CombiTable1Ds.getDerTableValue(\npump.table_minMaxCharacteristics.tableID, \n1, \npump.table_minMaxCharacteristics.u, \npump.table_minMaxCharacteristics.tableOnFileRead, \n1.0)")
        Modelica_Blocks_Tables_CombiTable1Ds_getDerTableValue_M(DymStruc0_construct(
        (Integer)(DYNX(W_,266))), 1, DYNX(W_,231), DYNX(W_,267), 1.0))*
        DYNX(DYNhelp,173);
      PopModelContext();
      DYNX(DYNhelp,175) = divmacro(1.0,"1.0",DYNX(W_,150),"activeWall.pipe.flowModel.nParallel");
      DYNX(DYNhelp,176) = divmacro(1.0,"1.0",DYNX(DYNhelp,172),"activeWall.pipe.crossAreas[1]+activeWall.pipe.crossAreas[2]");
      DYNX(DYNhelp,177) = divmacro(1.0,"1.0",DYNX(W_,180),"activeWall.pipe.flowModel.dp_nominal");
      DYNX(DYNhelp,178) = DYNX(W_,181)*DYNX(DYNhelp,173);
      DYNX(DYNhelp,179) = DYNX(W_,372)*DYNX(W_,342)*DYNX(W_,329);
      DYNX(DYNhelp,180) = divmacro(1.0,"1.0",DYNX(W_,342),"pipe.flowModel.nParallel");
      DYNX(DYNhelp,181) = 2.0*DYNX(W_,329);
      DYNX(DYNhelp,182) = divmacro(1.0,"1.0",DYNX(DYNhelp,181),"2.0*pipe.crossArea");
      DYNX(DYNhelp,183) = divmacro(1.0,"1.0",DYNX(W_,371),"pipe.flowModel.dp_nominal");
      SetMatrixLeading(J, 1, 1, 2, (-0.00010242371959608998)-DYNX(DYNhelp,177)*
        DYNX(DYNhelp,176)*DYNX(DYNhelp,175)*(-3.6159608511971846)*
        DYNX(DYNhelp,174));
      SetMatrixLeading(J, 1, 2, 2,  -DYNX(DYNhelp,177)*DYNX(DYNhelp,176)*
        DYNX(DYNhelp,175)*3.6159608511971846*DYNX(DYNhelp,174));
      SetMatrixLeading(J, 2, 1, 2,  -DYNX(DYNhelp,177)*DYNX(DYNhelp,176)*
        DYNX(DYNhelp,175)*DYNX(DYNhelp,178));
      SetMatrixLeading(J, 2, 2, 2,  -(DYNX(DYNhelp,177)*DYNX(DYNhelp,176)*
        DYNX(DYNhelp,175)*(-1.0)*DYNX(DYNhelp,178)+DYNX(DYNhelp,183)*
        DYNX(DYNhelp,182)*DYNX(DYNhelp,180)*(-2.0)*DYNX(DYNhelp,179)));
    }
    SetVector(y, 1, 0.0);
    SetVector(y, 2, 0.0);
    SolveLinearSystemOfEquations(J, b, y, 1);
    DYNX(W_,416) = GetVector(y, 1);
    DYNX(W_,428) = GetVector(y, 2);
    EndStaticLinearSystemOfEquations(J);
  }
  DYNX(W_,163) = 0.5*DYNX(W_,150)*DYNX(DYNhelp,172)*(DYNX(W_,428)-DYNX(W_,416));
  DYNX(W_,173) = DYNX(DYNhelp,176)*DYNX(DYNhelp,175)*(-2)*DYNX(W_,163);
  DYNX(W_,83) =  -DYNX(DYNhelp,177)*DYNX(W_,181)*DYNX(W_,173);
  DYNX(W_,223) = (-0.0010044335697769957)*DYNX(W_,83);
  DYNX(W_,232) = 3600*DYNX(W_,223);
  DYNX(W_,229) = (PushModelContext(1,"Modelica.Blocks.Tables.CombiTable1Ds.getDerTableValue(\npump.table_minMaxCharacteristics.tableID, \n1, \npump.table_minMaxCharacteristics.u, \npump.table_minMaxCharacteristics.tableOnFileRead, \nder(pump.table_minMaxCharacteristics.u))")
    Modelica_Blocks_Tables_CombiTable1Ds_getDerTableValue_M(DymStruc0_construct(
    (Integer)(DYNX(W_,266))), 1, DYNX(W_,231), DYNX(W_,267), DYNX(W_,232)));
  PopModelContext();
  DYNX(W_,355) =  -DYNX(W_,342)*DYNX(W_,329)*DYNX(W_,428);
  DYNX(W_,365) = DYNX(DYNhelp,182)*DYNX(DYNhelp,180)*(-2)*DYNX(W_,355);
   /* End of Equation Block */ 

  BreakSectionEnd()

BreakSectionFunctionStart(0);
BreakSectionFunctionCallNew(1);
BreakSectionFunctionCallNew(3);
BreakSectionFunctionEnd()
